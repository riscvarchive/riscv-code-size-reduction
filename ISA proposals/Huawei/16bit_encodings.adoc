= RISC-V 16-bit code-size reduction extension proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16-bit instructions proposed to help reduce code-size.

. Instructions proposed for v1.0 are in normal text
. Instructions proposed for the `future` are in _italics_

== Issues for v1.0

. there are probably too many instructions listed, so we need to reduce the list
. confirm immediate bits for `c.sb, c.lbu, c.sh, c.lhu`

== Issues for the `future` proposals

. Need to resolve whether to have C.LWPC or L.LI / C.CALL or L.JAL
. Maybe add table index instruction - table index offset into a jump table specified by a CSR similar to MTVEC instead of C.CALL

== C-extension subsets

https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/C-extension%20subsets.xlsx[This spreadsheet has a proposal for how to divide the C-extension into subsets, and how to select code-size reduction instructons for all relevant base architectures and extensions]

== Rationale

16-bit instructions are highly valuable for code-size reduction. The proposal is split into two phases
. v1.0 to be ratified in 2021
. `future` to be ratified later

The most useful instructions will be ratified in v1.0, whilst also limiting the complexity to adding multi-step instructions.

== v1.0 proposal

=== v1.0 Opcode Assignment and Semantics

Discussion should be mainly focussed on the proposals for v1.0 

[#proposed-16bit-encodings-1]
.proposed 16-bit encodings-1 
[width="100%",options=header]
|=============================================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction
3+|100|1|0|0|0 2+|rcount|0 |0 2+|00 | spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|ret_sreg[0]|1 3+|spimm 2+|00|C.POPRET
3+|110|1|0|0 3+|rcount|1 |0 3+|spimm 2+|00|C.PUSH
17+|C.TBLJAL has very high benefit - the 8 bit immediate is valuable
3+|100|1|1|1 8+|    index8        2+| 00  | C.TBLJAL
|=============================================================================================


[#proposed-16bit-encodings-1]
.proposed 16-bit encodings-1 
[width="100%",options=header]
|=============================================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction
3+|100|1|0|0|0 2+|rcount|0 |0 2+|00 | spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|ret_sreg[0]|1 3+|spimm 2+|00|C.POPRET
3+|110|1|0|0 3+|rcount|1 |0 3+|spimm 2+|00|C.PUSH
17+|C.TBLJAL has very high benefit - the 8 bit immediate is valuable
3+|100|1|1|1 8+|    index8        2+| 00  | C.TBLJAL
|=============================================================================================

[#proposed-16bit-encodings-2]
.proposed 16-bit encodings-2 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|Single source/dest with room for 3 more encodings
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 0  | 1  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 0  3+| 010     2+| 00  | C.SEXT.B
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 1  3+| 011     2+| 00  | C.SEXT.H
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 1  3+| 100     2+| 00  | C.LSBNOT
3+|  100       | 1  | 0  | 0 3+|          | 1  | 1  3+| >=101   2+| 00  | *reserved*
3+|  100       | 1  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 1  | 0  | 1 3+|        2+| not 00  3+|         2+| 00  | *reserved*
|=============================================================================================

[#proposed-16bit-encodings-3]
.proposed 16-bit encodings-3 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 0  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 0  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 0  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 0  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
17+|two-step execution, load PC relative value and then jump to the loaded value
3+|  100       | 0  | 1 2+| 00     7+| uimm[8:2]                    2+|00 | *reserved*
|=============================================================================================

[#proposed-16bit-encodings-4]
.proposed 16-bit encodings-4 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|This encoding space is also available for RV32 only
3+|  000       | 1  2+| uimm[8:7] 3+| rd' 5+| uimm[6:2]         2+| 10  | *reserved*
17+|This encoding space is also available for RV32 only
3+|  100       | 1  | 0  9+|                                    2+| 01  | *reserved*
|=============================================================================================

[#b-extension 16-bit encodings]
.B-extension proposed 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These are taken fromthe B-extension draft specification and are subject to change
3+|  011       |0 2+|00     3+| rs1'/rd'  5+| 00000             2+| 00  | C.NOT
3+|  011       |0 2+|01     3+| rs1'/rd'  5+| 00000             2+| 00  | C.NEG
3+|  011       |0 2+|10     3+| rs1'/rd'  5+| 00000             2+| 00  | *reserved*
3+|  011       |0 2+|11     3+| rs1'/rd'  5+| 00000             2+| 00  | *reserved*
|=============================================================================================

[#doubleprecisionreuse]
.Reuse of double precision encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|D-extension load/stores, reallocated if D is not implemented
3+|  101     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 00  | C.SB  (behind C.FSD)
3+|  001     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 00  | C.LBU (behind C.FLD)
3+|  101     3+|uimm[5:3]   3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 10  | C.SH  (behind C.FSDSP)
3+|  001     3+|uimm[5:3]   3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 10  | C.LHU (behind C.FLDSP)
17+|F-extension load/stores for reference, will *not* be reallocated
3+|  111    11+|                                                2+| 00  | *reserved* (behind C.FSW)
3+|  011    11+|                                                2+| 00  | *reserved* (behind C.FLW)
3+|  111    11+|                                                2+| 10  | *reserved* (behind C.FSWSP)
3+|  011    11+|                                                2+| 10  | *reserved* (behind C.FLWSP)
|=============================================================================================

[#v1.0semantics]
.v1.0 semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.POP         | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers]
| C.POPRET      | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers and return]
| C.PUSH        | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[PUSH registers]
| C.TBLJAL      | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[Table jump]
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.LSBNOT      | rd' = rd' XOR 1
| C.MUL         | rd' = rd' * rs2'
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
| C.NOT         | rd' = ~rd'
| C.NEG         | rd' = -rd'
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
|=======================================================================

[#v1.0-32bit]
.v1.0 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding       | 32-bit extension
|C.POP       | pop    {reg_list}     | reg_list maps to a 16-bit encoding     | code-size reduction
|C.POPRET    | popret {reg_list}     | reg_list maps to a 16-bit encoding     | code-size reduction
|C.PUSH      | push   {reg_list}     | reg_list maps to a 16-bit encoding     | code-size reduction
|C.SEXT.B    | sext.b rd, rs1        | all registers x8-x15, rd==rs1          | B-extension
|C.SEXT.H    | sext.h rd, rs1        | all registers x8-x15, rd==rs1          | B-extension
|C.MUL       | mul    rd, rs1, rs2   | all registers x8-x15, rd==rs1          | I-extension
|C.LBU       | lbu    rd, imm(sp)    | all registers x8-x15, rd==rs1          | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | all registers x8-x15, rd==rs1          | I-extension
|C.SBSP      | sb     rd, imm(sp)    | all registers x8-x15, rd==rs1          | I-extension
|C.SHSP      | sh     rd, imm(sp)    | all registers x8-x15, rd==rs1          | I-extension
|C.SB        | sb     rd, imm(rs1)   | all registers x8-x15, rd==rs1          | I-extension
|C.SH        | sh     rd, imm(rs1)   | all registers x8-x15, rd==rs1          | I-extension
|C.LBU       | lbu    rd, imm(rs1)   | all registers x8-x15, rd==rs1          | I-extension
|C.LHU       | lhu    rd, imm(rs1)   | all registers x8-x15, rd==rs1          | I-extension
|======================================================================================================

[#v1.0-32bit]
.v1.0 32-bit equivalent pseudo-instructions
[width="100%",options=header]
|=================================================================================================================================
|instruction | assembly syntax        |real 32-bit insn  | requirements for 16-bit encoding       | extension for 32-bit encoding
|C.ZEXT.B    | zext.b rd, rs1         |andi rd, rs1, 255 | all registers x8-x15, rd==rs1          | I-extension
|C.ZEXT.H    | zext.h rd, rs1         |pack rd, rs1, zero| all registers x8-x15, rd==rs1          | B-extension
|C.LSBNOT    | lsbnot rd, rs1         |xori rd, rs1, 1   | all registers x8-x15, rd==rs1          | I-extension
|C.NOT       | not    rd, rs1         |xori rd, rs1, -1  | all registers x8-x15, rd==rs1          | I-extension
|C.NEG       | neg    rd, rs1         |sub  rd, zero, rs1| all registers x8-x15, rd==rs1          | I-extension
|=================================================================================================================================

The B-extension adds the following pseudo-instructions

. `zext.b`
. `zext.h`

Therefore the code-size reduction extension will add the additional pseudo-instructions

. `lsbnot`
. `not`

The pseudo-instructions give the same assembly syntax between all 32-bit and 16-bit encodings.


=== v1.0 Assembly Examples

[source,sourceCode,text]
----
zext.b a5, a5;  # a5 = zero_ext(a5[7:0])
zext.h a5, a5;  # a5 = zero_ext(a5[15:0])
sext.b a5, a5;  # a5 = sign_ext(a5[7:0])
sext.h a5, a5;  # a5 = sign_ext(a5[15:0])

lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   

mul a5, a5, a6; # a5 = a5 * a6

not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion

lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0])
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0]
----

=== v1.0 Benchmarking results on the Huawei IoT code

[#analysis_results]
.Analysis results
[width="100%",options=header]
|=======================================================================================================
| Instruction             | saving | status 
| C.SB, C.LBU, C.SH, C.LHU| 3.68%  | implemented in HCC and measured
| C.PUSH, C.POP, C.POPRET | 3.46%  | implemented in HCC and measured
| C.ZEXT.B, C.ZEXT.H      | 0.34%  | implemented in HCC and measured
| C.LBUSP, C.SBSP         | 0.25%  | estimated based on 32-bit encoding
| C.LHUSP, C.SHSP         | 0.23%  | estimated based on 32-bit encoding
| C.MUL                   | 0.03%  | estimated based on 32-bit encoding
| C.LSBNOT                | 0.02%  | estimated based on 32-bit encoding "XORI 1"
| C.NOT                   | -      | no estimate - should search for "XORI -1"
| C.SEXT.B, C.SEXT.H      | -      | no estimate - should search for shift left/shift right?
| C.NEG                   | -      | no estimate - should search for 0-A?
|=======================================================================================================


== `Future` Proposals

=== `Future` Opcode Assignment and Semantics

[#future-proposed-16bit-encodings]
.`Future` 16-bit encodings 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|two-step execution, load PC relative value and then jump to the loaded value
3+|  100       | 0  | 1 2+| 00     7+| uimm[8:2]                2+| 00  | _C.CALL_
17+|PC relative load, only available for RV32 as this encoding is C.SLLI with an out of range shift
3+|  000       | 1  2+| uimm[8:7] 3+| rd' 5+| uimm[6:2]         2+| 10  | _C.LWPC_
17+|From the B-extension
3+|  011       |0 2+|10     3+| rs1'/rd'  5+| 00000             2+| 00  | _C.ZEXT.W (RV64+)_
3+|  011       |0 2+|11     3+| rs1'/rd'  5+| 00000             2+| 00  | _C.ZEXT.D (RV128)_
|=============================================================================================

[#futuresemantics]
.`Future` semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| _C.LSBNOT_      | rd' = rs1' XOR 1
| _C.CALL_        | ra  = sign_ext(Memory[pc_offset(PC, zero_ext(uimm))][31:0])); JAL(ra);
| _C.LWPC_        | rd' = sign_ext(Memory[pc_offset(PC, zero_ext(uimm))][31:0])
|=======================================================================

The `pc_offset` function is defined to always allow a word offset to be encoded without encoding bit 1
of the immediate. Therefore if the result is a 16-bit aligned PC offset, increment by 2 to point to the next
word aligned address. This means that the final address is *always* word aligned.
[source,sourceCode,text]
----

//PC=0x18, offset=0x4, pc_offset=0x24 - non-word aligned PC adds uimm+2
//PC=0x20, offset=0x4, pc_offset=0x24 - word aligned PC adds uimm
//PC=0x22, offset=0x4, pc_offset=0x28 - non-word aligned PC adds uimm+2
//PC=0x24, offset=0x4, pc_offset=0x28 - word aligned PC adds uimm

int pc_offset(int PC,  int uimm){
        pc_offset = (PC + uimm + 2) & sign_ext(0xc)
}

----


The idea of `C.LWPC` is to load constant values from the end of the current function, which is why the immediate is unsigned. 

`C.CALL` was suggested by Guo Ren from Alibaba - it's similar to LOADPC on ARM - PC relative load and then `JAL ra` to the loaded value. It may take any load related exception (PMP fault, page fault etc.) although
alignment faults are not possible as the result of `pc_offset()` is always word aligned. 

_Both `C.LWPC` and `C.CALL` require the instruction memory to have PMP read permission as well as execute permission, which allows searching for ROP gadgets. Therefore I think we should implement the 48-bit encodings instead (`L.LI` and `L.JAL`) for better security, less chance of cache fragmentation (loading instruction memory into the D-cache) and saving 16-bit encoding space._

=== `Future` Assembly Examples

[source,sourceCode,text]
----

lw  a5, 16(pc); # a5 = zero_extend(Memory[PC + 16<<2)[31:0]), for 16-bit encoding offset must be in range and rd=x8-x15
jal ra, 16(pc); # jump to Memory(pc_16), ra=PC+2, for 16-bit encoding offset must be in range, the link register must be ra
----

== Rejected instructions

Jim Wilson pointed at that we should fix `-mno-strict-align` and mandate that cores which need `C.ORSLL[8|16|24]` support unaligned load/store, so that we don't need to assemble bytes into words

`C.RORI` is only useful under limited circumstances

`C.
` a lot of extra complexity for little extra gain
