= Code-size reduction ISA extension status

This shows the code-size reduction status of proposed ISA extensions on the four main benchmarks.
Huawei IoT (2 cores - application and protocol)
Zephyr (2 cores - central and peripheral)

[NOTE]

  We need more large, real benchmarks which we can recompile with different compiler options

[NOTE]

  The baseline code-size for these tables is to compile the benchmarks on HCC with `-msave-restore`

== A nice example of the code size reduction

This function is probably from glibc and is linked to FPMark executables

[source,sourceCode,text]
----
00018e0c <_open_r>:
   18e0c:	1141                	addi	sp,sp,-16 ;#PUSH (1)
   18e0e:	c422                	sw	s0,8(sp)  ;#PUSH (2)
   18e10:	c226                	sw	s1,4(sp)  ;#PUSH (3)
   18e12:	00cf2437          	lui	s0,0xcf2
   18e16:	84aa                	mv	s1,a0     ;#PUSH (4) - will target s0 not s1
   18e18:	852e                	mv	a0,a1     ;#MVAA (1)
   18e1a:	85b2                	mv	a1,a2     ;#MVAA (2)
   18e1c:	8636                	mv	a2,a3     ;#MVAA (3)
   18e1e:	c606                	sw	ra,12(sp) ;#PUSH (4)
   18e20:	e0042e23          	sw	zero,-484(s0) # cf1e1c <errno>
   18e24:	3290f0ef          	jal	ra,2894c <_open> ;#TBLJAL
   18e28:	57fd                	li	a5,-1                       ;#BNEI (1)
   18e2a:	00f51663          	bne	a0,a5,18e36 <_open_r+0x2a>  ;#BNEI(2)
   18e2e:	e1c42783          	lw	a5,-484(s0)
   18e32:	c391                	beqz	a5,18e36 <_open_r+0x2a>
   18e34:	c09c                	sw	a5,0(s1)
   18e36:	40b2                	lw	ra,12(sp)   ;#POPRET (1)
   18e38:	4422                	lw	s0,8(sp)    ;#POPRET (2)
   18e3a:	4492                	lw	s1,4(sp)    ;#POPRET (3)
   18e3c:	0141                	addi	sp,sp,16    ;#POPRET (4)
   18e3e:	8082                	ret                 ;#POPRET (5)
----

After using many of the proposed new instructions the result is (note that I have to swap `s0` and `s1` as `push` moves `a0` into `s0`):

[source,sourceCode,text]
----
00018e0c <_open_r>:
   18e0c:	<16-bit>                push	{ra,s0-s2},{a0},-16
   18e12:	00cf2437          	lui	s1,0xcf2
   18e18:	<16-bit>                mv	(a0,a1), (a1,a2), (a2,a3)
   18e20:	e0042e23          	sw	zero,-484(s1) # cf1e1c <errno>
   18e24:	<16-bit>            	tbljal	#x
   18e2a:	<32-bit>          	bnei	a0,-1,18e36 <_open_r+0x2a>
   18e2e:	e1c42783          	lw	a5,-484(s1)
   18e32:	c391                	beqz	a5,18e36 <_open_r+0x2a>
   18e34:	c09c                	sw	a5,0(s0)
   18e36:	<16-bit>                popret	{ra,s0-s2},-16
----

This function reduces from 54-bytes to 28-bytes, ~48% reduction in size. Clearly not all functions will benefit this much and the lack of `-msave-restore` means the comparison is maybe a bit optimistic.

== Proposals which save > 0.5%

=== PUSH/POP or PUSH+MV/POP

[push_pop_status_table]
.PUSH/POP status
[width=100%,options="header",]
|===================================================================================================
| Extension       |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Measured by compiling with HCC vs baseline
| PUSH/POP           | 4.90%  | 3.31% | 5.0%   | 4.08%  
5+|Improvement of PUSH+MV proposal over PUSH/POP estimated by a script
| PUSH+MV           | 0.94% |1.02% | 1.55%    | 1.35%  
5+|Cumulative benefit of PUSH/POP and PUSH+MV, previous two rows added
|*PUSH+MV/POP*       | *5.84%* |*4.33%*|*6.57%* |*5.43%* 
|===================================================================================================

PUSH/POP spec is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here]

=== Table jump

[table_jump_status_table]
.Table Jump status, for jump table mode
[width=100%,options="header",]
|===================================================================================================
|                 2+|IoT application 2+|IoT protocol 2+|Zephyr Central 2+|Zephyr Peripheral
9+|Estimated by a script, so elf files don't exist, relative to the baseline above, 256 table entries
| TBLJAL            2+| 9.90%  2+| 7.37% 2+| 7.23%  2+| 6.83%  
9+|relative the the HCC PUSH/POP output above, estimated by a script, 256 table entries
| TBLJAL + PUSH/POP 2+| 11.15%  2+| 8.20% 2+| 8.29%  2+| 8.57%  
9+|add in estimated benefit of PUSH+MV
|*TBLJAL + PUSH+MV/POP* 2+| *12.09%*  2+| *9.22%* 2+| *9.84%*  2+| *9.92%*
|===================================================================================================

Table jump spec is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here]

=== 16-bit load/store byte/half unsigned

[ldstbh_status_table]
.`c.lbu/c.lhu/c.sb/c.sh` status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| C.LBU/C.SB | 1.39%  | 1.80% | 2.56% | 1.88%  
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| C.LHU/C.SH | 0.54%  | 0.79% | 0.68%  | 0.45%
5+|Add in estimated benefit of TBLJAL + PUSH+MV/POP
|*Total*       |*14.02%*|*11.81%*|*13.08%*|*12.25%*
|===================================================================================================

We may decide that a shorter immediate value is acceptable for `c.lbu/c.lhu/c.sb/c.sh` or to only implement `c.lbu/c.sb` as the benefit is highest.
The proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_ldst_bh_extension.rst[here]

=== 32-bit compare-immediate-branch

[cmpimmbr_status_table]
.compare-imediate-branch status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| all cmp-imm-br | 0.79%  | 0.80% | 0.81% | 0.68%  
5+|Only BEQI/BNEI, the most commonly used two (69% of the benefit)
| BEQI/BNEI | 0.55%  | 0.55% | 0.56% | 0.47%  
5+|Add in estimated benefit of TBLJAL, PUSH+MV/POP and load/store byte/half
|*Total*        |*14.57%*|*12.36%*|*13.64%*|*12.71%*
|===================================================================================================

The proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_condbr_imm_extension.rst[here]
We need to analyse the encoding space used - which includes two immediates - branch offset and compare immediate.

==== maybe implement incblz?

Andy Glew suggested `incblz rd,target`:
  
`rd += 1; if( rd < 0 ) goto target`
  
This requires no immediate value for comparison, so requires the loop counter to start negative and count up, so gives a bigger branch offset range which could be extremely valuable.

== Proposals which save < 0.5%

=== Multi-move

The multi-move proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/multi_move.adoc[here]. I'm roughly estimating about 0.4% reduction (accurate analysis to be done). 

=== 32-bit MULIADD

[muliadd_status_table]
.compare-imediate-branch status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, relative to baseline
| MULIADD    | 0.20%  | 0.32% | 0.15% | 0.10%  
|===================================================================================================

Proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[here].
It takes too much encoding space, Clare Wolf has a proposal for a cheaper version:

See the https://lists.riscv.org/g/tech-bitmanip/topic/multiply_immediate_add/78289291?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,78289291[email thread] and the 
https://docs.google.com/spreadsheets/d/1rZnfWd4_K50rtPeg-yQD4h5mKcjOoghwzNg4u30Hyx0/edit#gid=0[analysis results]

Clare also proposed `MULI` and `ADDIADD`.

Maybe these should go into the next version of bit manip?

=== `C.ZEXT[BH]`

[czext_status_table]
.`c.zext[bh]` status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, relative to baseline
| c.zext[bh] | 0.29%  | 0.32% | 0.17% | 0.12%  
|===================================================================================================

The benchmarks are for two 3-bit operand specifiers: `c.zext[bh] rd', rs1'`
It would be more sensible to limit the encoding space an use a single 3-bit src/dst operand: `c.zext[bh] rd'`
The instructions zero extend either a byte or half-word up to the full register width, and expand to `zext.[bh]` in the B-extension.

== To be analysed

== `lwgp/swgp`

Proposal is listed on https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/32bit_encodings.adoc[this page].
It could benefit from a separate proposal page.
I expect the benefit to be high (> 2%),

== others

These will probably offer small improvements, I estimate around 0.1% for each. They could be considered more as speed improvements for specific algorithms which need them.

- `C.NOT/C.LSBNOT`
- `C.SEXT.*`
- `C.MUL`
- https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_preshifted_arithmetic.rst[preshifted arithmetic - delay to next time?]
- ...and look at the B-extension


