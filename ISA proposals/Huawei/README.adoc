= Code-size reduction ISA extension status

This shows the code-size reduction status of proposed ISA extensions on the four main benchmarks.
Huawei IoT (2 cores - application and protocol)
Zephyr (2 cores - central and peripheral)

[NOTE]

  We need more large, real benchmarks which we can recompile with different compiler options

[NOTE]

  The baseline code-size for these tables is to compile the benchmarks on HCC with `-msave-restore`

== Proposals which save > 0.5%

=== PUSH/POP or PUSH+MV/POP

[push_pop_status_table]
.PUSH/POP status
[width=100%,options="header",]
|===================================================================================================
| Extension       |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Measured by compiling with HCC vs baseline
| PUSH/POP           | 4.90%  | 3.31% | 5.0%   | 4.08%  
5+|Improvement of PUSH+MV proposal over PUSH/POP estimated by a script
| PUSH+MV           | 0.94% |1.02% | 1.55%    | 1.35%  
5+|Cumulative benefit of PUSH/POP and PUSH+MV, previous two rows added
|*PUSH+MV/POP*       | *5.84%* |*4.33%*|*6.57%* |*5.43%* 
|===================================================================================================

PUSH/POP spec is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here]

=== Table jump

[table_jump_status_table]
.Table Jump status, for jump table mode
[width=100%,options="header",]
|===================================================================================================
|                 2+|IoT application 2+|IoT protocol 2+|Zephyr Central 2+|Zephyr Peripheral
9+|Estimated by a script, so elf files don't exist, relative to the baseline above, 256 table entries
| TBLJAL            2+| 9.90%  2+| 7.37% 2+| 7.23%  2+| 6.83%  
9+|relative the the HCC PUSH/POP output above, estimated by a script, 256 table entries
| TBLJAL + PUSH/POP 2+| 11.15%  2+| 8.20% 2+| 8.29%  2+| 8.57%  
9+|add in estimated benefit of PUSH+MV
|*TBLJAL + PUSH+MV/POP* 2+| *12.09%*  2+| *9.22%* 2+| *9.84%*  2+| *9.92%*
|===================================================================================================

Table jump spec is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here]

=== 16-bit load/store byte/half unsigned

[ldstbh_status_table]
.`c.lbu/c.lhu/c.sb/c.sh` status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| C.LBU/C.SB | 1.39%  | 1.80% | 2.56% | 1.88%  
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| C.LHU/C.SH | 0.54%  | 0.79% | 0.68%  | 0.45%
5+|Add in estimated benefit of TBLJAL + PUSH+MV/POP
|*Total*       |*14.02%*|*11.81%*|*13.08%*|*12.25%*
|===================================================================================================

We may decide that a shorter immediate value is acceptable for `c.lbu/c.lhu/c.sb/c.sh` or to only implement `c.lbu/c.sb` as the benefit is highest.
The proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_ldst_bh_extension.rst[here]

=== 32-bit compare-immediate-branch

[cmpimmbr_status_table]
.compare-imediate-branch status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, 5-bit unsigned immediate, relative to baseline
| all cmp-imm-br | 0.79%  | 0.80% | 0.81% | 0.68%  
5+|Only BEQI/BNEI, the most commonly used two (69% of the benefit)
| BEQI/BNEI | 0.55%  | 0.55% | 0.56% | 0.47%  
5+|Add in estimated benefit of TBLJAL, PUSH+MV/POP and load/store byte/half
|*Total*        |*14.57%*|*12.36%*|*13.64%*|*12.71%*
|===================================================================================================

The proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_condbr_imm_extension.rst[here]
We need to analyse the encoding space used - which includes two immediates - branch offset and compare immediate.

==== maybe implement incblz?

Andy Glew suggested `incblz rd,target`:
  
`rd += 1; if( rd < 0 ) goto target`
  
This requires no immediate value for comparison, so requires the loop counter to start negative and count up, so gives a bigger branch offset range which could be extremely valuable.

== Proposals which save < 0.5%

=== Multi-move

The multi-move proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/multi_move.adoc[here]. I'm roughly estimating about 0.4% reduction (accurate analysis to be done). 

=== 32-bit MULIADD

[muliadd_status_table]
.compare-imediate-branch status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, relative to baseline
| MULIADD    | 0.20%  | 0.32% | 0.15% | 0.10%  
|===================================================================================================

Proposal is https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[here].
It takes too much encoding space, Clare Wolf has a proposal for a cheaper version:

See the https://lists.riscv.org/g/tech-bitmanip/topic/multiply_immediate_add/78289291?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,78289291[email thread] and the 
https://docs.google.com/spreadsheets/d/1rZnfWd4_K50rtPeg-yQD4h5mKcjOoghwzNg4u30Hyx0/edit#gid=0[analysis results]

Clare also proposed `MULI` and `ADDIADD`.

Maybe these should go into the next version of bit manip?

=== `C.ZEXT[BH]`

[czext_status_table]
.`c.zext[bh]` status
[width=100%,options="header",]
|===================================================================================================
|            |IoT application |IoT protocol |Zephyr Central |Zephyr Peripheral
5+|Compiled with HCC, relative to baseline
| c.zext[bh] | 0.29%  | 0.32% | 0.17% | 0.12%  
|===================================================================================================

The benchmarks are for two 3-bit operand specifiers: `c.zext[bh] rd', rs1'`
It would be more sensible to limit the encoding space an use a single 3-bit src/dst operand: `c.zext[bh] rd'`
The instructions zero extend either a byte or half-word up to the full register width, and expand to `zext.[bh]` in the B-extension.

== To be analysed

== `lwgp/swgp`

Proposal is listed on https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/32bit_encodings.adoc[this page].
It could benefit from a separate proposal page.
I expect the benefit to be high (> 2%),

== others

These will probably offer small improvements, I estimate around 0.1% for each. They could be considered more as speed improvements for specific algorithms which need them.

- `C.NOT/C.LSBNOT`
- `C.SEXT.*`
- `C.MUL`
- https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_preshifted_arithmetic.rst[preshifted arithmetic - delay to next time?]
- ...and look at the B-extension


