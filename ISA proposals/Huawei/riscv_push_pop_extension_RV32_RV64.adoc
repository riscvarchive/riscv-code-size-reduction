= RISC-V Push/Pop Extension
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 32-bit and 16-bit encodings for `[C.]PUSH`,
`[C.]POP` and `[C.]POPRET` instructions for RV32 and RV64,
architectures, I and E variants.

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

- `POPRET` with `rcount=15` is not useful so should be illegal. Because these cases are for the interrupt handler entry/exit a different mnemonic would make sense like `PUSHINT/POPINT` for example
- should `PUSHINT/POPINT` have the option to avoid saving/restoring `ra`? Should this be an option in general? it could be an extra bit in the 32-bit encoding, or maybe allocated some new rcount values to save (for example) `s0,s0-1,s0-2` without `ra`
- should `PUSHINT/POPINT` also save/restore some CSRs e.g. `MCAUSE/MEPC/MTVAL` to save more code size, and so allow uarch tricks to save cycles?
- need to review usage of register lists, and make sure the proposal matches load/store multiple requirements

We _may_ find that a 4-bit `rcount` field is enough for the 32-bit encoding, or we may think of more functionlity to add.

== Rationale

`[C.]PUSH/[C.]POP/[C.]POPRET` are designed to replace the
most commonly called functions generated by the compiler using
_–m-save-restore_. When the _–msave-restore_ option is used the compiler
replaces the sequence of stores plus `sp` decrement operation required
to spill/push registers to the stack with a call to a shared co-routine
that performs this operation. In addition the equivalent fill/pop
sequence is replaced with a jump to a shared co-routine (which then
performs the return to the caller of the function). The code savings can
be significant (provided that the co-routine jump/calls can be encoded
in a single 32-bit instruction) but the run-time overhead is high as an
additional 3 jumps are required for each push/pop sequence; in addition
the shared save/restore routines include redundant memory operations
when the number of registers to spill is not a multiple of 4.

The most useful forms of these instructions are the 16-bit encodings, as
these give the largest code size reduction, whilst covering the vast
majority of useful cases.

== 16-bit encodings

=== `C.PUSH` instruction

`C.PUSH` which allows most spill sequences to only take 16-bits of
code space instead of 32-bits for the call to the save routine (or in
some cases 64-bits if the target function is too far away).

=== `C.POP` instruction

`C.POP` which allows most fill sequences to be performed with two
16-bit instructions (`C.POP+RET` ) which matches the cost of the
co-routine jump (for jumps <1Mbyte) but with significantly better
performance.

=== `C.POPRET` instructions

`C.POPRET` which allows both the `C.POP` and `RET` to be
performed in a single instruction saving 16-bits of code with respect to
a `C.POP+RET` or a jump to a restore co-routine.

=== Opcode Assignment

.proposed encoding
[width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction

17+|*These replace reserved encodings, PUSH/POP with support for UABI and EABI*

3+|100|1|0|0 3+|rcount|0|0 3+|spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|0|1 3+|spimm 2+|00|C.POPRET
3+|100|1|0|0 3+|rcount|1|0 3+|spimm 2+|00|C.PUSH
|=======================================================================

Notes

* The `spimm` field is an unsigned immediate that indicates the number
of additional _n_-byte blocks to adjust the stack pointer by. See <<spimm-table>>
and <<rcount-table>>
* the instructions are designed to support the UABI and EABI for RV32 and for RV64
* RV64E is not currently in the RISC-V standard, but may be included in
the future so it is fully included in this specification
* For UABI documentation see Chapter 20 of
http://riscv.org/specifications/isa-spec-pdf[The RISC-V ISA
specification]
* For the EABI, see this
https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[proposal]


[#spimm-table]
.`spimm` and register holes for different architectures and ABIs
[options="header"]
|=======================================================================
|arch+ABI |spimm _n_ |total stack adjustment for _r_ registers |register holes to skip
|RV32[IE] EABI |8 |adjust = 8*((r+1)/2+spimm) |holes = r mod 2

|RV32I UABI |16 |adjust = 16*((r+3)/4+spimm) |holes = 3-((r+3) mod 4)

|RV64I UABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2

|RV64[IE] EABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2
|=======================================================================

The purpose of `spimm` is to allow a function to allocate additional
space on the stack for automatic variables without having to perform an
additional stack adjustment (and therefore save more code size).

The encodings contain no explicit register index fields as the memory
accesses and pointer increments are all based on the stack pointer
register as defined in the standard RISC-V ABIs `sp` and the registers
to be loaded/stored are specified using the `rcount` field (see
<<rcount-table>>)

The behaviour of each value of `rcount` and `spimm` is shown in
<<rcount-table>>, where:

* x = `spimm`
* y = `spimm`, but the encoding should have spimm[0]=1 for legal stack alignment for the UABI
* z = `spimm`, but the encoding should have spimm[0]=0 for legal stack alignment for the UABI

[#rcount-table]
.`rcount` values for different architectures
[options="header",width=100%]
|===================================================================================================================================
|rcount| ABI names            6+|Stack pointer adjustment                         5+|reg holes to skip          
|      |                      6+|x=spimm -for PUSH, +for POP                      5+|                           
|      |                        |RV32I UABI|RV32I EABI|RV64I UABI|RV64I EABI  |RV32E     |RV64E  |RV32I UABI|RV32I EABI|RV64I  |RV32E|RV64E    
13+| `rcount` 0-2 for RV32I UABI requires restricted `spimm` values to avoid SP misalignment so the formulae use *y* or *z* instead of x
|0     |ra                      | 8(1+*y*) | 8(1+x)   |16(1+x)   |16(1+x)     | 8(1+x)   |16(1+x)| 3        | 1        | 1     | 1  | 1
|1     |ra, s0                  | 8(1+*y*) | 8(1+x)   |16(1+x)   |16(1+x)     | 8(1+x)   |16(1+x)| 2        | 0        | 0     | 0  | 0
|2     |ra, s0-s1               | 8(2+*z*) | 8(2+x)   |16(2+x)   |16(2+x)     | 8(2+x)   |16(2+x)| 1        | 1        | 1     | 1  | 1
13+| `rcount` 3+ are UABI only, these encodings should not be used for RV32I/RV64I EABI
|3     |ra, s0-s2               |16(1+x)   |N/A       |16(2+x)   |N/A       2+|*reserved*        | 0        | N/A      | 0   2+|*reserved*    
|4     |ra, s0-s3               |16(2+x)   |N/A       |16(3+x)   |N/A       2+|*reserved*        | 3        | N/A      | 1   2+|*reserved*    
|5     |ra, s0-s5               |16(2+x)   |N/A       |16(4+x)   |N/A       2+|*reserved*        | 1        | N/A      | 1   2+|*reserved*    
|6     |ra, s0-s8               |16(3+x)   |N/A       |16(5+x)   |N/A       2+|*reserved*        | 2        | N/A      | 0   2+|*reserved*    
|7     |ra, s0-s11              |16(4+x)   |N/A       |16(7+x)   |N/A       2+|*reserved*        | 3        | N/A      | 1   2+|*reserved*    
|===================================================================================================================================

[NOTE]
  currently the EABI and UABI define s2 to be different X registers. This proposal does not allow s2 to be saved/restored under the EABI - the 32-bit encoding must be used for this.
  As a result RV32E/RV64E cores will take an illegal instruction exception for encodings which have `rcount>2`

=== `C.PUSH` Operation

A `C.PUSH` instruction writes the set of registers selected by
_rcount_ to memory, the registers are written to the memory immediately
below the current stack pointer. The last register in the list is stored to
the lowest memory location to be written by the `C.PUSH`

[source,sourceCode,text]
----
sp-(XLEN/8)*r
----

where _r_ is the number registers to store

The selected registers are written to contiguous incrementing
(XLEN/8)-byte words starting with the register in the reverse of the
order shown in <<rcount-table>> above (ra is always stored last).

Once all stores have completed the stack pointer register `sp` is
decremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>.

Note that 'spimm' allows up to an additional bytes of stack to be
allocated for automatic variables without having to issue additional
stack manipulation instructions.

=== `C.POP/C.POPRET` Operation

A `C.POP/C.POPRET` instruction loads the set of registers
selected by _rcount_ from the memory. The loads start at the lowest
memory location to be read by the `C.POP/C.POPRET`. To get to
that location the stack pointer is first incremented by the scaled value
of `spimm` from <<spimm-table>>, and then incremented by the number of holes
required to mantain the stack alignment (see <<spimm-table>> and  <<rcount-table>>).

The selected registers are loaded from contiguous incrementing
(XLEN/8)-byte words in the reverse of the order shown in  <<rcount-table>>
above (ra is always loaded last).

See <<spimm-table>> for stack increment calculations for all architectures.

Once all loads have completed the stack pointer register `sp` is
incremented by the stack adjustment value from <<spimm-table>> and
 <<rcount-table>>, placing it immediately above the block of memory read
by the `C.POP/C.POPRET` instruction.

`C.POPRET` executes a `RET` as the final step in the sequence

=== Instruction sequences

The behaviour of these instructions is specified using instruction sequences.

All loads and stores in the sequences can be executed multiple times, and in any order, including being merged into wider loads or stores.

The `ADDI` (`ADDI, RET` for `C.POPRET`) only execute if all other steps have completed without causing an exception (load or store access fault, load or stage page fault, breakpoint), 
taking an interrupt or entering into debug mode (breakpoint or external debug halt). It is possible to interrupt the sequence between the final load or store and the `ADDI` instruction.
It is _not_ possible to interrupt `C.POPRET` between the `ADDI` and the `RET`.

When execution resumes any number of the loads or stores may be re-executed.

In the tables:

* `N` is the stack pointer adjustment value from  <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

[#cpush_sequence]
.`C.PUSH` sequence
[options="header",width=50%]
|===============================================================================
| C.PUSH step                               |Execute if
| sw x27,  (-13*M)(x2)                      |rcount==7
| sw x26,  (-12*M)(x2)                      |rcount==7
| sw x25,  (-11*M)(x2)                      |rcount==7
| sw x24,  (-10*M)(x2)                      |rcount>=6
| sw x23,  ( -9*M)(x2)                      |rcount>=6
| sw x22,  ( -8*M)(x2)                      |rcount>=6
| sw x21,  ( -7*M)(x2)                      |rcount>=5
| sw x20,  ( -6*M)(x2)                      |rcount>=5
| sw x19,  ( -5*M)(x2)                      |rcount>=4
| sw x18,  ( -4*M)(x2)                      |rcount>=3
| sw x9,   ( -3*M)(x2)                      |rcount>=2
| sw x8,   ( -2*M)(x2)                      |rcount>=1
| sw x1,   ( -1*M)(x2)                      |1 
| addi x2, x2,  -N                          |1 
|===============================================================================

.`C.POP/C.POPRET` sequence
[options="header",width=50%]
|===============================================================================
| C.POP/C.POPRET step                      |Execute if
| lw x27,  (-13*M+N)(x2)                   |rcount==7
| lw x26,  (-12*M+N)(x2)                   |rcount==7
| lw x25,  (-11*M+N)(x2)                   |rcount==7
| lw x24,  (-10*M+N)(x2)                   |rcount>=6
| lw x23,  (-9*M+N)(x2)                    |rcount>=6
| lw x22,  (-8*M+N)(x2)                    |rcount>=6
| lw x21,  (-7*M+N)(x2)                    |rcount>=5
| lw x20,  (-6*M+N)(x2)                    |rcount>=5
| lw x19,  (-5*M+N)(x2)                    |rcount>=4
| lw x18,  (-4*M+N)(x2)                    |rcount>=3
| lw x9,   (-3*M+N)(x2)                    |rcount>=2
| lw x8,   (-2*M+N)(x2)                    |rcount>=1
| lw x1,   (-1*M+N)(x2)                    |1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================



=== Suggested C.POP/C.POPRET UOP sequences

The exact implementation will vary, this is one possible set of
sequences of UOPs (micro-ops) which can be used to implement
`C.POP/C.POPRET`

The `sp` adjustment is made last to deallocate space after loading from
memory, so that if the sequence is interrupted/resumed then the stack
memory is still reserved so that the interrupt handler is able to
allocate stack space and write to the stack without affecting the
interrupted instruction. It is possible to increment the stack pointer
afterwards instead, and adjust the load addresses accordingly.

In the tables:
* `N` is the stack pointer adjustment value from  <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV6
4

`ra` is loaded early for performance because the value is needed by
`ret`. This may complicate burst reads from memory so may not be a
performance advantage.


.UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount<=5``
[options="header",width=50%]
|===============================================================================
| C.POP.E/C.POPRET.E UOP                   |Execute if
| lw x1,   (-1*M+N)(x2)                    |1
| lw x7,   (-6*M+N)(x2)                    |rcount==5
| lw x6,   (-5*M+N)(x2)                    |rcount<=5 && rcount>=4
| lw x14,  (-4*M+N)(x2)                    |rcount<=5 && rcount>=3
| lw x9,   (-3*M+N)(x2)                    |rcount<=5 && rcount>=2
| lw x8,   (-2*M+N)(x2)                    |rcount<=5 && rcount>=1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET.E
|===============================================================================

.UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.POP.E/C.POPRET.E RV32 UOP              |Execute if
| lw x1,   (-1*M+N)(x2)                    |1
| lw x15,  (-7*M+N)(x2)                    |rcount==15
| lw x13,  (-6*M+N)(x2)                    |rcount==15
| lw x12,  (-5*M+N)(x2)                    |rcount==15
| lw x11,  (-4*M+N)(x2)                    |rcount==15
| lw x10,  (-3*M+N)(x2)                    |rcount==15
| lw x5,   (-2*M+N)(x2)                    |rcount==15
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET.E
|===============================================================================


=== Exceptions

If `eabi` is zero and `sp` is not 16 byte aligned when a
`C.PUSH/C.POP/C.POPRET` instruction is executed a memory alignment
exception will be generated (Store Access Fault for `C.PUSH`, Load
Access Fault for `C.POP/C.POPRET`).

If `eabi` is one and `sp` is not 8 byte aligned (RV32) or 16 byte
aligned (RV64) when a `C.PUSH.E/C.POP.E/C.POPRET.E` instruction is
executed a memory alignment exception will be generated (Store Access
Fault for `C.PUSH.E`, Load Access Fault for `C.POP.E/C.POPRET.E`).

Illegal instructions are taken for illegal `rcount` values (see
 <<rcount-table>>).

If `eabi` is zero on an RV32E/RV64E architecture take an illegal
instruction exception.

=== Assembler Syntax

The `C.PUSH/C.POP/C.POPRET` instructions are represented in
assembler as the mnemonic followed by a braced and comma separated list
of registers, followed by the total size of the stack adjustment
expressed in bytes. The stack adjustment should include an appropriate
sign bit and the space needed to accommodate the registers in the
register list. Register ranges are also permitted and indicated using a
hyphen (-). The register list may only contain registers supported by
`C.PUSH/C.POP/C.POPRET` instructions but these can be listed
in any order and use the ABI or "x plus index register" representation.

To be legal the stack adjustment must:

1.  Be negative for a `C.PUSH` and positive for a `C.POP`/`C.POPRET`
2.  Match the value range in  <<rcount-table>> for the current architecture and ABI

To use the 16-bit encoding of `C.PUSH/C.POP/C.POPRET` then
the registers specified in the encoding must match one of the sets of
entries in  <<rcount-table>> above, and the stack adjustment must be
legal. Otherwise the assembler will attempt to use the 32-bit encoding,
if it is implemented and is suitable. If not then this will cause an
`illegal operands` error from the assembler.

=== RV32I Examples

.push 1 to 5 registers, loads can happen in any order, note 3 register holes in the stack pointer increment
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/push_1to5_regs_170pc_zoom.png[push example]

.pop 1 to 5 registers, stores can happen in any order, note 3 register holes in the stack pointer decrement
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/pop_1to5_regs_170pc_zoom.png[pop example]

=== RV32I Assembler Examples

==== C.PUSH RV32I

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Micro operation sequence:

[source,sourceCode,text]
----
sw  s5, -28(sp);
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra, -4(sp);
addi sp, sp, -64;
----

==== C.PUSH.E RV32I EABI

[source,sourceCode,text]
----
c.push.e {ra, s0-s4}, -64
----

Encoding: rcount=5, spimm=5

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== C.POP RV32I UABI

[source,sourceCode,text]
----
c.pop   {x1, x8-x9, x18-x25}, 160
----

Encoding: rcount=10, spimm=7 

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 156(sp);
lw  x25, 116(sp);  lw  x24, 120(sp);
lw  x23, 124(sp);  lw  x22, 128(sp)
lw  x21, 132(sp);  lw  x20, 136(sp);
lw  x19, 140(sp);  lw  x18, 144(sp)
lw   x9, 148(sp);  lw   x8, 152(sp);
addi sp, sp, 160
----

==== C.POPRET RV32I UABI

[source,sourceCode,text]
----
c.popret   {x1, x8-x9, x18-x19}, 32
----

Encoding: rcount=4, spimm=0 

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== C.POPRET.E RV32I EABI

[source,sourceCode,text]
----
c.popret.e  {x1, x8-x9, x14, x6}, 32
----

Encoding: rcount=4, spimm=1

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
lw   x6, 12(sp);  lw  x14, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== Varargs Support

Functions using varargs also spill the argument registers to the stack,
which requires a `SWM` custom instruction (store-word-multiple).

HCC produces this prologue:

[source,sourceCode,text]
----
16: addi sp,sp,-64 
16: sw   ra,28(sp)
16: sw   s0,24(sp)

16: sw   a7,60(sp)
16: sw   a6,56(sp)
16: sw   a5,52(sp)
16: sw   a4,48(sp)
16: sw   a3,44(sp)
16: sw   a2,40(sp)
16: sw   a1,36(sp)
----

This can be optimised to be:

[source,sourceCode,text]
----
16: addi sp,sp,-32
16: push {ra, s0},-32
16: addi sp,sp,(-32+36)
16: swm  {a1-a7},sp
16: addi sp,sp,-36 
----

saving 3x16-bit encodings, but the stack pointer adjustments are awkward
because `SWM` doesn't have an immediate offset

HCC produces this epilogue

[source,sourceCode,text]
----
16: lw   ra,28(sp)
16: lw   s0,24(sp)
16: addi sp,sp,64
16: ret
----

which could become:

[source,sourceCode,text]
----
16: addi sp,sp,32
16: popret {ra,s0},32
----

saving 2x16-bit encodings.

So in total 14 instructions can be reduced to 9.

== 32-bit encodings - needs updating - DON'T READ

The 32-bit versions of the instructions allow greater flexibility in
specifying the list of registers by allowing floating point registers to
be saved/restored. Therefore the register list also allows floating
point registers to be included. They can included in any order, but will
always be accessed in the same order by the instruction. They also allow
a larger range of _spimm_ values. Otherwise the semantics are identical
to the 16-bit versions and so the specification is not repeated here.
The instructions are called `PUSH[.E]`/`POP[.E]`/`POPRET[.E]`

These instructions will _not_ cover all possible push/pop scenarios,
they are designed to cover the common cases without using excessive
encoding space.

This specification does not include the case in RV32D where an odd
number of `X` registers are stored followed by one or more `F`
registers. This _may_ require an adjustment in address between the `X`
and `F` registers to maintain the stack alignment, and the tables
showing the overall stack adjustment _may not_ be correct as every `F`
register is twice as wide as the `X` registers

_Maybe avoid pushing/popping `ra` for tail calls? Could be an extra bit to specify that_

A C-function using varargs will also spill the argument registers to the
stack. They can be achieved by a store-multiple command after the PUSH
instruction and vararg support is not directly implemented by PUSH

=== Opcode Assignment

[options="header",width="90%",cols="14%,6%,12%,10%,12%,9%,9%,12%,16%",]
|================================================================
|31:28 |27 |26:24 |23:20 |19:15 |14:12 |11:7 |6:0 |name
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |PUSH
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POP
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POPRET
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |PUSH.E
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POP.E
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POPRET.E
|================================================================

* bit [27] is `eabi` which specifies which ABI is in use

The `x` registers are specified by <<rcount-table>>, there is no
difference in the specification except that `spimm` has a larger range.
The addition field `frcount` allows callee save `f` registers to be
saved/restored as well. The `f` registers are always appended to the
list of integer registers.

[options="header",width="50%"]
|====================================
  |frcount | ABI names               
  | 0      |none                     
  | 1      |fs0                      
  | 2      |fs0-fs1                  
  | 3      |fs0-fs2                  
  | 4      |fs0-fs3                  
  | 5      |fs0-fs4                  
  | 6      |fs0-fs5                  
  | 7      |fs0-fs6                  
  | 8      |fs0-fs7                  
  | 9      |fs0-fs8                  
  | 10     |fs0-fs9                  
  | 11     |fs0-fs10                 
  | 12     |fs0-fs11                 
  | 13-14  |*reserved*               
  | 15     |ft0-7, fa0-7, ft8-11     
|====================================

`frcount=15` is to save/restore the caller registers for the interrupt
handler. There are different rules for the instruction if `rcount` or
`frcount` are 15

The total stack adjustment is based upon the total number of registers
accessed, not just the `x` registers.

==== Specification if rcount < 15

The order of registers load/stored is:

* ra
* if (`rcount` > 0) s0-s `rcount`
* if (`frcount` != 0 && `frcount` < 13) fs0-fs `frcount`

This is the same as the 16-bit encoding, except that the register list
may be extended with `fs0-fs11`. The final stack pointer offset is the
same as for the 16-bit encoding, but with a larger range see
regcount_table2_eab_0

Therefore the 16-bit encoding allows up to 13 registers to be
saved/restored. The 32-bit encoding also allows up to 12 additional
registers giving a maximum of 25.

If `frcount` >0 and the F extension is not implemented, without `Zfinx`
, then take an illegal instruction exception.

if `frcount` >12 then take an illegal instruction exception.

The other illegal instruction checks are identical to those for the
16-bit encodings.

==== Specification if rcount == 15

The order of registers load/stored is:

* ra
* all `X` caller save registers
* if (`frcount` == 15) all `F` caller save registers

This is the same as the 16-bit encoding with `rcount=15`, except that
the register list may be extended with the `F` caller registers. The
final stack pointer offset is the same as for the 16-bit encoding, but
with a larger range.

* `PUSH/POP/POPRET`: the 16-bit encoding allows 16 `X` registers to be
saved/restored. The 32-bit encoding also allows an additional 20 `F`
registers giving a maximum of 36.
* `PUSH.E/POP.E/POPRET.E`: the 16-bit encoding allows 7 `X` registers to
be saved/restored. The 32-bit encoding also allows an additional 20 `F`
registers giving a maximum of 27.

If `frcount` !=0 && `frcount` !=15 then take an illegal instruction
exception.

If `frcount` ==15 and the F extension is not implemented, without
`Zfinx`, then take an illegal instruction exception.

The other illegal instruction checks are identical to those for the
16-bit encodings.

.Register count mapping for ``PUSH/POP/POPRET``
[options="header",width="50%"]
|==============================================
  |total  2+|SP adjustment   2+|reg holes  
  |# regs 2+|x=spimm,        2+|to skip    
  |       2+|-for PUSH,      2+|           
  |       2+|+for POP/POPRET 2+|           
  |         |RV32I  |RV64I     |RV32I|RV64I
  5+|*eabi = 0*                         
  |1     |16(1+x)|16(1+x) | 3   | 1   
  |2     |16(1+x)|16(1+x) | 2   | 0   
  |3     |16(1+x)|16(2+x) | 1   | 1   
  |4     |16(1+x)|16(2+x) | 0   | 0   
  |5     |16(2+x)|16(3+x) | 3   | 1   
  |6     |16(2+x)|16(3+x) | 2   | 0   
  |7     |16(2+x)|16(4+x) | 1   | 1   
  |8     |16(2+x)|16(4+x) | 0   | 0   
  |9     |16(3+x)|16(5+x) | 3   | 1   
  |10    |16(3+x)|16(5+x) | 2   | 0   
  |11    |16(3+x)|16(6+x) | 1   | 1   
  |12    |16(3+x)|16(6+x) | 0   | 0   
  |13    |16(4+x)|16(7+x) | 3   | 1   
  |14    |16(4+x)|16(7+x) | 2   | 0   
  |15    |16(4+x)|16(8+x) | 1   | 1   
  |16    |16(4+x)|16(8+x) | 0   | 0   
  |17    |16(5+x)|16(9+x) | 3   | 1   
  |18    |16(5+x)|16(9+x) | 2   | 0   
  |19    |16(5+x)|16(10+x)| 1   | 1   
  |20    |16(5+x)|16(10+x)| 0   | 0   
  |21    |16(6+x)|16(11+x)| 3   | 1   
  |22    |16(6+x)|16(11+x)| 2   | 0   
  |23    |16(6+x)|16(12+x)| 1   | 1   
  |24    |16(6+x)|16(12+x)| 0   | 0   
  |25    |16(7+x)|16(13+x)| 3   | 1   
  |25-35 | *reserved*                 
  |36    |16(9+x)|16(18+x)| 0   | 0   
|==============================================


.`rcount` in proposed 32-bit encoding
[options="header",width=100%,cols="5%,5%,5%,5%,80%",]
|=======================================================================================================
|rcount|PUSH/POP/POPRET      | ABI names | spimm alignment | comment
|0     |PUSH/POP/POPRET      |ra         | 8-byte          | Use for either ABI (UABI should set spimm[0]=1 to round up to 16-byte blocks)
|1     |PUSH/POP/POPRET      |ra, s0     | 8-byte          | Use for either ABI (UABI should set spimm[0]=1 to round up to 16-byte blocks)
|2     |PUSH/POP/POPRET      |ra, s0-s1  | 8-byte          | Use for either ABI (UABI should set spimm[0]=0 as 3 registers already round up to 16-byte blocks)
|3     |PUSH/POP/POPRET      |ra, s0-s2  | 16-byte         | UABI only, s2 maps to different X reg in EABI
|4     |PUSH/POP/POPRET      |ra, s0-s3  | 16-byte         | 
|5     |PUSH/POP/POPRET      |ra, s0-s4  | 16-byte         | 
|6     |PUSH/POP/POPRET      |ra, s0-s5  | 16-byte         | 
|7     |PUSH/POP/POPRET      |ra, s0-s6  | 16-byte         | 
|8     |PUSH/POP/POPRET      |ra, s0-s7  | 16-byte         | 
|9     |PUSH/POP/POPRET      |ra, s0-s8  | 16-byte         | 
|10    |PUSH/POP/POPRET      |ra, s0-s9  | 16-byte         | 
|11    |PUSH/POP/POPRET      |ra, s0-s10 | 16-byte         | 
|12    |PUSH/POP/POPRET      |ra, s0-s11 | 16-byte         | 
|13    |PUSH.E/POP.E/POPRET.E|ra, s0-s2  | 16-byte         | TBD: EABI only as s2 maps to a different X register
5+|POPRET encoding illegal for rcount>13
|14    |PUSHINT/POPINT       |t0-t6,a0-a7                     | 16-byte         | UABI smaller IRQ handler entry/exit
|15    |PUSHINT/POPINT       |ra,t0-t6,a0-a7,mcause,mtval,mepc| 16-byte         | UABI large IRQ handler entry/exit
|16    |PUSHINT.E/POPINT.E   |t0-t1,a0-a3                     | 8-byte          | EABI smaller IRQ handler entry/exit	
|17    |PUSHINT.E/POPINT.E   |ra,t0-t1,a0-a3,mcause,mtval,mepc| 8-byte          | EABI large IRQ handler entry/exit	
|=======================================================================================================

.Register count mapping for PUSH.E/POP.E/POPRET.E`
[options="header",width="70%"]
|===========================================================================
|total  4+|Stack pointer adjustment         |reg holes to skip      
|# regs 4+|x=spimm -for PUSH, +for POP      |                       
|         |RV32I  |RV64I   |RV32E  |RV64E   |                       
6+|*eabi = 1*                                                      
|1     | 8(1+x)|16(1+x) | 8(1+x)|16(1+x) | 1                     
|2     | 8(1+x)|16(1+x) | 8(1+x)|16(1+x) | 0                     
|3     | 8(2+x)|16(2+x) | 8(2+x)|16(2+x) | 1                     
|4     | 8(2+x)|16(2+x) | 8(2+x)|16(2+x) | 0                     
|5     | 8(3+x)|16(3+x) | 8(3+x)|16(3+x) | 1                     
|6     | 8(3+x)|16(3+x) | 8(3+x)|16(3+x) | 0                     
|7     | 8(4+x)|16(4+x) | 8(4+x)|16(4+x) | 1                     
|8     | 8(4+x)|16(4+x) | 8(4+x)|16(4+x) | 0                     
|9     | 8(5+x)|16(5+x) | 8(5+x)|16(5+x) | 1                     
|10    | 8(5+x)|16(5+x) | 8(5+x)|16(5+x) | 0                     
|11    | 8(6+x)|16(6+x) | 8(6+x)|16(6+x) | 1                     
|12    | 8(6+x)|16(6+x) | 8(6+x)|16(6+x) | 0                     
|13    | 8(7+x)|16(7+x) | 8(7+x)|16(7+x) | 1                     
|14    | 8(7+x)|16(7+x) | 8(7+x)|16(7+x) | 0                     
|15    | 8(8+x)|16(8+x) | 8(8+x)|16(8+x) | 1                     
|16    | 8(8+x)|16(8+x) | 8(8+x)|16(8+x) | 0                     
|17    | 8(9+x)|16(9+x) | 8(9+x)|16(9+x) | 1                     
|18    | 8(9+x)|16(9+x) | 8(9+x)|16(9+x) | 0                     
|18-26 5+| *reserved*                                              
|27    |8(14+x)|16(14+x)|8(14+x)|16(14+x)| 1                     
|===========================================================================

.UOPs for `PUSHINT`
[options="header",width=50%]
|===============================================================================
| C.PUSH UOP                                |Execute if
| sw x31,  (-16*M+N)(x2)                    |rcount==15
| sw x30,  (-15*M+N)(x2)                    |rcount==15
| sw x29,  (-14*M+N)(x2)                    |rcount==15
| sw x28,  (-13*M+N)(x2)                    |rcount==15
| sw x17,  (-12*M+N)(x2)                    |rcount==15
| sw x16,  (-11*M+N)(x2)                    |rcount==15
| sw x15,  (-10*M+N)(x2)                    |rcount==15
| sw x14,  ( -9*M+N)(x2)                    |rcount==15
| sw x13,  ( -8*M+N)(x2)                    |rcount==15
| sw x12,  ( -7*M+N)(x2)                    |rcount==15
| sw x11,  ( -6*M+N)(x2)                    |rcount==15
| sw x10,  ( -5*M+N)(x2)                    |rcount==15
| sw x7,   ( -4*M+N)(x2)                    |rcount==15
| sw x6,   ( -3*M+N)(x2)                    |rcount==15
| sw x5,   ( -2*M+N)(x2)                    |rcount==15
| sw x1,   ( -1*M+N)(x2)                    |1
| addi x2, x2,  -N                          |1
|===============================================================================

.UOPs for ``C.POPINT`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.POP/C.POPRET UOP                       |Execute if
| lw x1,   (-1*+N)(x2)                     |1
| lw x31,  (-16*+N)(x2)                    |rcount==15
| lw x30,  (-15*+N)(x2)                    |rcount==15
| lw x29,  (-14*+N)(x2)                    |rcount==15
| lw x28,  (-13*+N)(x2)                    |rcount==15
| lw x17,  (-12*+N)(x2)                    |rcount==15
| lw x16,  (-11*+N)(x2)                    |rcount==15
| lw x15,  (-10*+N)(x2)                    |rcount==15
| lw x14,  (-9*+N)(x2)                     |rcount==15
| lw x13,  (-8*+N)(x2)                     |rcount==15
| lw x12,  (-7*+N)(x2)                     |rcount==15
| lw x11,  (-6*+N)(x2)                     |rcount==15
| lw x10,  (-5*+N)(x2)                     |rcount==15
| lw x7,   (-4*+N)(x2)                     |rcount==15
| lw x6,   (-3*+N)(x2)                     |rcount==15
| lw x5,   (-2*+N)(x2)                     |rcount==15
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================


=== Assembler Examples

==== PUSH RV32I UABI

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: rcount=5, frcount=1, spimm=2, eabi=0 (16-byte aligned, C.PUSH
doesn't support f registers)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0, 36(sp)
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== PUSH.E RV32I EABI

[source,sourceCode,text]
----
push.e  {ra, s0-s4, fs0}, -64
----

Encoding: rcount=5, frcount=1, spimm=4 eabi=1 (8-byte aligned, so spimm
is larger than the UABI version)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0, 36(sp)
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== POP RV32I UABI

[source,sourceCode,text]
----
pop   {x1, x8-x9, x18-x25}, 256
----

Encoding: rcount=10, frcount=0, spimm=13 eabi=0 (16-byte aligned, spimm
out of range for C.POP)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 252(sp);
lw  x25, 212(sp);  lw  x24, 216(sp);
lw  x23, 220(sp);  lw  x22, 224(sp)
lw  x21, 228(sp);  lw  x20, 232(sp);
lw  x19, 236(sp);  lw  x18, 240(sp)
lw   x9, 244(sp);  lw   x8, 248(sp);
addi sp, sp, 256
----

==== POPRET RV32I UABI

[source,sourceCode,text]
----
popret   {x1, x8-x9, x18-x19, f8-f9}, 32
----

Encoding: rcount=4, frcount=2, spimm=0, eabi=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
flw  f9,  4(s0);  flw  f8,  8(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== POPRET RV32I EABI

[source,sourceCode,text]
----
popret.e  {x1, x8-x9, x14, x6, f8-f9}, 32
----

Encoding: rcount=4, frcount=2, spimm=0 eabi=1 (8-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
flw  f9,  4(s0);  flw  f8,  8(sp);
lw   x6, 12(sp);  lw  x14, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----
