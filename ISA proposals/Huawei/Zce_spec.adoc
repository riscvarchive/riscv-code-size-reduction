= RISC-V Zce code-size reduction extension proposal v0.51
Version 0.50.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes the `Zce` extension to reduce code-size.

[NOTE]

  This document is currently in a *stable* state but will certainly change before ratification, as some custom encodings are in use.

== Spec update history

|===================================================================
| version | change
| 0.51    | remove areg_list from PUSH/C.PUSH (https://github.com/riscv/riscv-code-size-reduction/issues/116), add C.MVS07A01 instead
|         | remove ret_val from POP (https://github.com/riscv/riscv-code-size-reduction/issues/115)
| 0.50.1  | fix typo - all instructions are available in RV32 (some tables said otherwise)
| 0.50    | release version.
|         | fix https://github.com/riscv/riscv-code-size-reduction/issues/103 (BEQI/BNEI format)
| 0.41.12 | Simplify table jump CSRs (https://github.com/riscv/riscv-code-size-reduction/issues/84[github issue]) and enhance the table jump pesudo-code to include debug triggers/haltreq/step
| 0.41.11 | Change memory order for PUSH/POP (https://github.com/riscv/riscv-code-size-reduction/issues/99[github issue])
| 0.41.10 | Change definition of C.TBLJ* exceptions
| 0.41.9  | Update Zcee definition to include C.MUL
| 0.41.8  | fix table jump pseudo-code to show that two memory exceptions are possible during execution
| 0.41.7  | fix c.push assembler syntax so <areg_list> must always be included, even if null
| 0.41.6  | simplify c.mva01s07 assembler syntax, and fix encoding in table 16 (it was inconsistent)
|         | fix ZCE-type format for 32-bit PUSH/POP (no actual spec change)
| 0.41.5  | remove # from c.tblj* assembly syntax, as it's a comment character
| 0.41.4  | correct table 30 so that the C.LB/C.LH encodings are in the 001____10 group (the spec was inconsistent)
| 0.41.3  | remove requirement that writing to xTBLJALVEC flushes the jump table cache - just use FENCE.I or other standard mechanism
|         | change pseudo-code for POP so that the return value can be interrupted / repeated
|         | beq/bne assembly example should have been beqi/bnei
| 0.41.2  | bug fix: PUSH/PUSH.E were missing the `areg` field which controls wether the PUSH moves a[i] into s[i]
| 0.41.1  | bug fix: move PUSH/POP/POPRET to custom-1 as they were overlapping (so will have to change again in the future)
| 0.41    | bug fix: change MULI encoding, as it overlapped with SLLI (it's now in custom-0, so will have to change again in the future)
|         | bug fix: C.TBLJ and C.TBLJALM were reserved in the encoding table and example usage
|         | add compiler switches for the prototype compiler
| 0.40    | *Stable version for toolchain/simulator prototyping*
|===================================================================

== Github issues (may not be a complete list)

* https://github.com/riscv/riscv-code-size-reduction/issues/106[MULI has a temporary encoding]
* https://github.com/riscv/riscv-code-size-reduction/issues/105[TBLJALVEC needs address to be allocated]
* https://github.com/riscv/riscv-code-size-reduction/issues/104[EABI spec is not frozen - so it's not clear which formats of PUSH.E/POP.E/POPRET.E etc that are needed]
* https://github.com/riscv/riscv-code-size-reduction/issues/102[May need an EABI version of C.MVA01S07]

== `Zce` configurations

image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/Zce_subsets%20simplified6.png[Zce subsets]

`Zce` is split into two main subsets

* `Zcea` which is compatible with all existing standard extensions designed for small embedded cores
** `Zcee` is a simpler subset of `Zcea` for high performance cores, it can be implemented without the rest of `Zcea`
* `Zceb` reuses encoding from the `D`-extension, and so is incompatible with `D`
** `Zceb` is fully compatible with `Zdinx`

[NOTE]

  To get 32-bit versions of the instructions from `Zcee` the `B`-extension subsets `Zba` and `Zbb` should be implemented. This is recommended but not required by this specification.

[#zcea]
.Zcea extension
[width="100%",options=header]
|===============================================================================
|Instruction|RV32|RV64|RV128|Extension|Notes
6+|Zcee subset
|C.SEXT.B|y|y|y|Zcea/Zcee|
|C.SEXT.H|y|y|y|Zcea/Zcee|
|C.SEXT.W| |y|y|Zcea/Zcee|pseudo-instruction
|C.ZEXT.B|y|y|y|Zcea/Zcee|
|C.ZEXT.H|y|y|y|Zcea/Zcee|
|C.ZEXT.W| |y|y|Zcea/Zcee|
6+|Require M or Zmmul to be inferred
|C.MUL|y|y|y|Zcea/Zcee|requires M or Zmmul
|MULI|y|y|y|Zcea|requires M or Zmmul
6+|other 16-bit encodings
|C.MVA01S07|y|y|y|Zcea|
|C.MVS07S01|y|y|y|Zcea|
|C.NOT|y|y|y|Zcea|
|C.NEG|y|y|y|Zcea|
|C.TBLJ|y|y|y|Zcea|
|C.TBLJAL|y|y|y|Zcea|
|C.TBLJALM|y|y|y|Zcea|
|C.PUSH|y|y|y|Zcea|
|C.POP|y|y|y|Zcea|
|C.POPRET|y|y|y|Zcea|
|C.PUSH.E|y| | |Zcea|
|C.POP.E|y| | |Zcea|
|C.POPRET.E|y| | |Zcea|
6+|other 32-bit encodings
|PUSH|y|y|y|Zcea|
|POP|y|y|y|Zcea|
|POPRET|y|y|y|Zcea|
|PUSH.E|y| | |Zcea|
|POP.E|y| | |Zcea|
|POPRET.E|y| | |Zcea|
|BEQI|y|y|y|Zcea|
|BNEI|y|y|y|Zcea|
|===============================================================================

[#zceb]
.Zceb extension, incompatible with D, compatible with Zdinx
[width="100%",options=header]
|===============================================================================
|Instruction|RV32|RV64|RV128|Extension|Notes
6+| 16-bit encodings
|C.DECBNEZ|y|y| |Zceb|incompatible with D
|C.LBU|y|y| |Zceb|incompatible with D
|C.LHU|y|y| |Zceb|incompatible with D
|C.LB|y|y| |Zceb|incompatible with D
|C.LH|y|y| |Zceb|incompatible with D
|C.SB|y|y| |Zceb|incompatible with D
|C.SH|y|y| |Zceb|incompatible with D
6+| 32-bit encodings
|LWGP|y|y|y|Zceb|incompatible with D
|SWGP|y|y|y|Zceb|incompatible with D
|LDGP| |y|y|Zceb|incompatible with D
|SDGP| |y|y|Zceb|incompatible with D
|===============================================================================

`Zcea/Zceb` are compatible with both the `I` and `E` extensions. 

All systems which implement `Zcea/Zceb` must also implement the `C` extension. 

If `M` or `Zmmul` is specified then `Zcea/Zcee` also include the `C.MUL, MULI` instructions.

== C-extension subsets

The C-extension already reuses encodings between different architectures. `Zce` extends this concept further. <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>> show how each encoding is allocated for different architectures or for different combinations of extensions.

For example:

* `C.FSD`, `C.SQ`, and `{C.LBU, C.SB}` share opcodes, so for different configurations the encodings represent:
** `C.FSD` for `RV32CD/RV64CD`
** `C.SQ`  for `RV128C`
** `{C.LBU, C.SB}` for `RV32C_Zceb, RV64C_Zceb, RV32C_Zceb_Zdinx, RV64C_Zceb_Zdinx`
** illegal encoding for `RV32C, RV64C`, as neither `D` nor `Zce` was specified

The shared encoding column in the tables assigns an arbitrary number to show which encodings are grouped together (I can't find a better way of highlighting groups of cells in the table in adoc format). `Zce` instructions are in *bold*.

[NOTE]

  The names `Zci, Zcf, Zcd, Zcq, Zc32, Zc64, Zc128` are not official subset names, I have used them to help explain how the 16-bit encoding space is divided up and reused.

[#zce_quad0]
.C-extension quadrant 0
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension
|000       |C.ADDI4SPN| |Zci |y|y |y  |C

|001       |C.FLD     |1|Zcd |y|y |   |C+D
|001       |C.LQ      |1|Zcq |  |  |y  |C
|001       |*C.LBU*    |1|*Zceb*|y|y| |C+*Zceb*
|001       |*C.LHU*    |1|*Zceb*|y|y| |C+*Zceb*

|010       |C.LW      | |Zci |y|y |y  |C

|011       |C.FLW     |2|Zcf |y|   |   |C+F
|011       |C.LD      |2|Zc64/Zc128| |y|y|C

|100       |*C.POP*     | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.POPRET*  | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.PUSH*    | |*Zcea*|	y|	y|	y|	C+*Zcea*

|100       |*C.POP.E*   | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.POPRET.E*| |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.PUSH.E*  | |*Zcea*|	y|	y|	y|	C+*Zcea*

|100       |*C.TBLJ*    | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.TBLJAL*  | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.TBLJALM* | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.SEXT.B*  | |*Zcea/Zcee*|	y|	y|	y|	C+*Zcea/Zcee*
|100       |*C.SEXT.H*  | |*Zcea/Zcee*|	y|	y|	y|	C+*Zcea/Zcee*
|100       |*C.ZEXT.B*  | |*Zcea/Zcee*|	y|	y|	y|	C+*Zcea/Zcee*
|100       |*C.ZEXT.H*  | |*Zcea/Zcee*|	y|	y|	y|	C+*Zcea/Zcee*
|100       |*C.NOT*     | |*Zcea*|	y|	y|	y|	C+*Zcea*
|100       |*C.NEG*     | |*Zcea*|	y|	y|	y|	C+*Zcea*

|101       |C.FSD     |3|Zcd|y|y| |C+D
|101       |C.SQ      |3|Zcq| | |y|D
|101       |*C.SB*    |3|*Zceb*|y|y| |C+*Zceb*
|101       |*C.SH*    |3|*Zceb*|y|y| |C+*Zceb*

|110       |C.SW      | |Zci|y|y|y|C

|111       |C.FSW     |4|Zcf|y| | |C+F
|111       |C.SD      |4|Zc64/Zc128| |y|y|C
|===============================================================================

[#zce_quad1]
.C-extension quadrant 1
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.NOP	| |Zci	|y	|y	|y	|C
|000       |C.ADDI	| |Zci	|y	|y	|y	|C


|001       |C.JAL	        |5|Zc32	        |y	|	|	|C
|001       |C.ADDIW (rd=0:RSV)  |5|Zc64/Zc128	|	|y	|y	|C

|010       |C.LI (rd=0:HINT) | |Zci	|y	|y	|y	|C


|011       |C.ADDI16SP (nzimm=0:RSV)	| | Zci	|y	|y	|y	|C
|011       |C.LUI (nzimm=0: RSV; rd=0:HINT)	| |Zci	|y	|y	|y	|C


|100       |C.SRLI (RV32:NSE, nzuimm[5]=1)        |6|Zc32/Zc64	|y	|y	|	|C
|100       |C.SRLI64 (RV32:HINT)                  |6|Zc128	|	|	|y	|C
|100       |C.SRAI (RV32:NSE, nzuimm[5]=1)        |7|Zc32/Zc64	|y	|y	|	|C
|100       |C.SRAI64 (RV32/64:HINT)               |7|Zc128	|	|	|y       |C
|100       |C.ANDI                                | |Zci	|y	|y	|y	|C
|100       |C.SUB                                 | |Zci	|y	|y	|y	|C
|100       |C.XOR                                 | |Zci	|y	|y	|y	|C
|100       |C.OR                                  | |Zci	|y	|y	|y	|C
|100       |C.AND                                 | |Zci	|y	|y	|y	|C
|100       |C.SUBW (RV32:RSV)                     | |Zc64/Zc128	|	|y	|y	|C
|100       |C.ADDW (RV32:RSV)                     | |Zc64/Zc128	|	|y	|y	|C

|100       |C.MUL                                 | |Zcea/Zcee	|y |y	|y	|M+C+*Zcea/Zcee*
|100       |C.MVA01S07                            | |Zcea	|y |y	|y	|C+*Zcea*
|100       |C.MVS07A01                            | |Zcea	|y |y	|y	|C+*Zcea*


|101       |C.J	       | |Zci	|y	|y	|y	|C


|110       |C.BEQZ	| |Zci	|y	|y	|y	|C


|111       |C.BNEZ	| |Zci	|y	|y	|y	|C
|===============================================================================

[#zce_quad2]
.C-extension quadrant 2
[width="100%",options=header]
|======================================================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.SLLI (rd=0:HINT; RV32 && nzuimm[5]=1:NSE)| 8|Zc32/Zc64	|y	|y	|	|C
|000       |C.SLLI64 (RV32/64 or rd=0:HINT)	       | 8|Zc128	        |	|	|y	|C
|001       |C.FLDSP	                               | 9|Zcd	        |y	|y	|	|C+D
|001       |C.LQSP (rd=0:RSV)	                     | 9|Zc128	        |	|	|y	|C
|001       |*C.LB*                                 | 9|N/A 	|y	|y	| 	|C+*Zceb*
|001       |*C.LH*                                 | 9|N/A 	|y	|y	| 	|C+*Zceb*
|010       |C.LWSP (rd=0:RSV)	                     |  |Zci	        |y	|y	|y	|C
|011       |C.FLWSP	                               |10|Zcf	        |y	|	|	|C+F
|011       |C.LDSP (rd=0:HINT)	                   |10|Zc64/Zc128	|	|y	|y	|C
|100       |C.JR     (rd=0:RSV)	                   |  |Zci   	|y	|y	|y	|C
|100       |C.MV   (rd=0:HINT)	                   |  |Zci   	|y	|y	|y	|C
|100       |C.EBREAK	                             |  |Zci   	|y	|y	|y	|C
|100       |C.JALR	                               |  |Zci   	|y	|y	|y	|C
|100       |C.ADD (rd=0:HINT)	                     |  |Zci   	|y	|y	|y	|C
|101       |C.FSDSP	                               |11|Zcd	        |y	|y	|	|C+D
|101       |C.SQSP	                               |11|Zc128		|       | 	|y	|C
|101       |*C.DECBNEZ*	                           |11|*Zceb*	|y	|y	| 	|C+*Zceb*
|110       |C.SWSP	                               |  |Zci	        |y	|y	|y	|C
|111       |C.FSWSP	                               |12|Zcf	        |y	|	|	|C+F
|111       |C.SDSP	                               |12|Zc128	        |	|y	|y	|C
|======================================================================================================

== Allocation of new 16-bit encodings

This section gives a short-hand lookup of exactly where the new encodings are allocated to make it easier to review the encoding space. The first column is the group number from <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>>.

|======================================
|Group|[15:13]|[12:10]|[1:0]|Instruction

| |100    |000    |00   |C.SEXT.B, C.SEXT.H, C.ZEXT.B, C.ZEXT.H, C.ZEXT.W, C.NOT, C.NEG
| |100    |010    |00   |C.TBLJ, C.TBLJAL, C.TBLJALM
| |100    |011    |00   |C.POP, C.POPRET, C.PUSH, C.POP.E, C.POPRET.E, C.PUSH.E

|1|001    |0xx    |00   |C.LBU
|1|001    |1xx    |00   |C.LHU

|3|101    |0xx    |00   |C.SB
|3|101    |1xx    |00   |C.SH

| |100    |111    |01   |C.MUL
| |100    |111    |01   |C.MVA01S07
| |100    |111    |01   |C.MVS07A01

|9|001    |0xx    |10   |C.LB
|9|001    |1xx    |10   |C.LH

|11|101   |xxx    |10   |C.DECBNEZ
|======================================


=== 16-bit encoding code-points

All previously reserved 16-bit encodings are in the tables below, showing how many are allocated to `Zce`.

[#spare16encodings]
.spare 16-bit encodings for RV32/RV64
[width="100%",options=header]
|================================================================================================
| 15:13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1:0 |code points| sub-extension
|  100  3+|000        8+|xxxx                            | 00    |56/256  | `Zcea` (40 `Zcee`)
|  100  3+|001        8+|xxxx                            | 00    |0/256   | *reserved*
|  100  3+|010        8+|xxxx                            | 00    |120/256 | `Zcea`
|  100  3+|011        8+|xxxx                            | 00    |256/256 | `Zcea`
|  100  3+|1xx        8+|xxxx                            | 00    |0/1024  | *reserved*
|  011    | 0 5+|xxxxx             5+|11111              | 01    |0/32    | *reserved*
|  100  3+|111  3+|xxx   |1  4+|xxx                      | 01    |64/128  | `Zcea` (56 `Zcee`)
|  100  6+|000000                  5+|non-zero           | 10    |0/31    | *reserved*
|================================================================================================

[#spare encodings RV32]
.spare 16-bit encodings for RV32 only (mainly out of range shifts)
[width="100%",options=header]
|================================================================================================
| 15:13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1:0 |code points| sub-extension
|  100     2+|10  9+|xxx                                 | 01  |0/512  | *reserved*
|  100     3+|111  3+|xxx   |0  4+|xxx                   | 01  |0/128  | *reserved*
|  000       | 1   5+| non-zero            5+|xxx        | 10  |0/992  | *reserved*  
|================================================================================================

[#spare encodings RV64]
.spare 16-bit encodings for RV64 only (ADDIW with zero destination)
[width="100%",options=header]
|================================================================================================
| 15:13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1:0 |code points| sub-extension
| 001        | x 5+|00000             5+| xxxxx          |01   |0/64 | *reserved*
|================================================================================================

[#spare encodings D]
.spare 16-bit encodings reused from the D-extension
[width="100%",options=header]
|================================================================================================
| 15:13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1:0 |code points| sub-extension
| 001        11+|xxx                                     |00     |2048/2048| `Zceb`
| 101        11+|xxx                                     |00     |2048/2048| `Zceb`
| 001        11+|xxx                                     |10     |2048/2048| `Zceb`
| 101        11+|xxx                                     |10     |2047/2048| `Zceb`
|================================================================================================

In total in the existing RVC (16-bit) encoding space:

. RV32C has 3871 code points available, 496 are used (12.8%)
. RV64C has 2303 code points available, 496 are used (21.5%)
. RV32CD (i.e. the C.FSD,C.FLD, C.FSDSP, C.FLDSP encodings) has 8192 code points available, 8191 are used (99.9%)

The `Zcee` subset uses 106 code points (2.7% RV32C, 4.6% RV64C).

== `Zcee` definition

=== C.SEXT.B, C.SEXT.H, C.ZEXT.B, C.ZEXT.H, C.ZEXT.W, C.MUL

These instructions have no conflicts with other extensions, they use previously reserved encodings.

These instructions are 16-bit versions of existing 32-bit instructions, from either `I/E` or the `Zba/Zbb`-extension.

`C.NOT/C.NEG` are _not_ part of `Zcee` but are included in <<monadic-16encodings>> to show the entire allocation of this encoding group. They are specified in <<c_not_c_neg>>.

[#monadic-16encodings]
.monadic simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10 | 9:7  | 6:5  | 4:2 | 1:0 |instruction         
7+|monadic with single source/dest, room for 3 more encodings
| 100   | 000   | rd'   | 00  | 000 | 00  | C.ZEXT.B
| 100   | 000   | rd'   | 00  | 001 | 00  | C.SEXT.B
| 100   | 000   | rd'   | 00  | 010 | 00  | C.ZEXT.H
| 100   | 000   | rd'   | 00  | 011 | 00  | C.SEXT.H
| 100   | 000   | rd'   | 00  | 100 | 00  | C.ZEXT.W
| 100   | 000   | xxx   | 00  | 101 | 00  | *reserved*
| 100   | 000   | rd'   | 00  | 110 | 00  | C.NEG (see Zcea)
| 100   | 000   | rd'   | 00  | 111 | 00  | C.NOT (see Zcea)
| 100   | 000   | xxx   | 01  | xxx | 00  | *reserved*
| 100   | 000   | xxx   | 1x  | xxx | 00  | *reserved*
|=============================================================================================

[#dyadic-16encodings]
.dyadic simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10 | 9:7  | 6:5  | 4:2 | 1:0 |instruction         
|  100  | 111   | rd'  | 10   | rs2'| 01  | C.MUL
|=============================================================================================

[#monsemantics_zcee]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.MUL         | rd' = rd' * rs2'
2+| RV64/RV128 only
| C.ZEXT.W      | rd' = zero_ext(rd'[31:0])
|=======================================================================

[NOTE]

  The expansion of `c.neg` puts `rd` onto `rs2`, unlike the other expansions which put `rd` onto `rs1`, and so requires additional muxing during the expansion

[#mon-32bit-zcee]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | example assembler syntax | requirements for 16-bit encoding   | 32-bit extension
|C.ZEXT.B    | zext.b rd, rs1        | all regs x8-x15, rd=rs1            | I or E
|C.ZEXT.H    | zext.h rd, rs1        | all regs x8-x15, rd=rs1            | Zbb
|C.SEXT.B    | sext.b rd, rs1        | all regs x8-x15, rd=rs1            | Zbb
|C.SEXT.H    | sext.h rd, rs1        | all regs x8-x15, rd=rs1            | Zbb
|C.MUL       | mul    rd, rs1, rs2   | all regs x8-x15, rd=rs1            | I or E
4+|RV64/RV128 only
|C.ZEXT.W    | zext.w rd, rs1        | all regs x8-x15, rd=rs1            | Zba
|======================================================================================================

[NOTE]

  Other assembler syntaxes are possible such as including the c. prefix and only including one operand to cover rs1 and rd

[NOTE]

  Implementing `Zba` and `Zbb` to get the 32-bit encodings from <<mon-32bit-zcee>> is not required by this specification.

Assembly Examples

[source,sourceCode,text]
----
zext.b a5, a5;  # a5 = zero_ext(a5[7:0])
zext.h a5, a5;  # a5 = zero_ext(a5[15:0])
sext.b a5, a5;  # a5 = sign_ext(a5[7:0])
sext.h a5, a5;  # a5 = sign_ext(a5[15:0])

mul a5, a5, a6; # a5 = a5 * a6

//RV64/RV128 only

zext.w a5, a5;  # a5 = zero_ext(a5[31:0])
sext.w a5, a5;  # a5 = sign_ext(a5[31:0])
----

=== C.SEXT.W

`C.SEXT.W` is added as a pseudo-instruction for `C.ADDIW rd, 0`.

== `Zcea` definition

`Zcea` includes all of the `Zcee` instructions above.

[#c_not_c_neg]
=== C.NOT, C.NEG

These instructions have no conflicts with other extensions, they use previously reserved encodings.

These instructions are 16-bit versions of existing 32-bit instructions, from the `I/E`-extension.

[#monadic-16encodings_not_neg]
.monadic simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10 | 9:7  | 6:5  | 4:2 | 1:0 |instruction         
|  100  | 000   | rd'  | 00   | 110 | 00  | C.NEG
|  100  | 000   | rd'  | 00   | 111 | 00  | C.NOT
|=============================================================================================

[#monsemantics_not_neg]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.NEG         | rd' = -rd' / rd' = 0 - rd'
| C.NOT         | rd' = ~rd' / rd' = rd' XOR -1
|=======================================================================

[NOTE]

  The expansion of `c.neg` puts `rd` onto `rs2`, unlike the other expansions which put `rd` onto `rs1`, and so requires additional muxing during the expansion

[#mon-32bit_not_neg]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | example assembler syntax | requirements for 16-bit encoding   | 32-bit extension
|C.NEG       | neg    rd, rs1        | all regs x8-x15, rd=rs1            | I or E
|C.NOT       | not    rd, rs1        | all regs x8-x15, rd=rs1            | I or E
|======================================================================================================

[NOTE]

  Other assembler syntaxes are possible such as including the c. prefix and only including one operand to cover rs1 and rd

Assembly Examples

[source,sourceCode,text]
----
not a5, a5      # a5 = ~a5 bitwise inversion
neg a5, a5      # a5 = -a5 two's complement inversion
----

=== C.MVA01S07, C.MVS07A01

Register moves are the most common in GCC output in both the benchmark suite and the Debian distro. These instructions combine very common pairs of moves into a single 16-bit encoding:

* move from two `s[0-7]` registers into `a0` and `a1`.
* move from `a0` and `a1` into two `s[0-7]` registers.

Similar to `PUSH/POP` this instruction uses ABI names for the registers. The mapping from `s` to `x` number is simple. For `RV32_Zdinx` a paired register write port is required already. For other configurations the microarchitecture can:

* split the instructions into an uninterruptable sequence of two `mv` instructions to avoid the second write port
* allow two write ports into `a0-a1,s0-s7` only to avoid an addiitonal write port to any X register

[source,sourceCode,text]
----
#RV64 debian/libm-2 example
    ab08:       86a2                    mv      a3,s0
    ab0a:       8652                    mv      a2,s4
    ab0c:       85de                    mv      a1,s7 # c.mva01s07 s1, s7
    ab0e:       8526                    mv      a0,s1 #
    ab10:       0f73e0ef                jal     ra,49406 <__exp2f_finite@@GLIBC_2.27+0x1e58>
    ab14:       55010993                addi    s3,sp,1360
    ab18:       86a2                    mv      a3,s0
    ab1a:       864e                    mv      a2,s3
    ab1c:       85de                    mv      a1,s7 # c.mva01s07 s1, s7
    ab1e:       8526                    mv      a0,s1 #
    ab20:       1bb3e0ef                jal     ra,494da <__exp2f_finite@@GLIBC_2.27+0x1f2c>
    ab24:       8622                    mv      a2,s0
    ab26:       85da                    mv      a1,s6 # c.mva01s07 s4, s6
    ab28:       8552                    mv      a0,s4 #
    ab2a:       49a3e0ef                jal     ra,48fc4 <__exp2f_finite@@GLIBC_2.27+0x1a16>
    ab2e:       8622                    mv      a2,s0
    ab30:       85d6                    mv      a1,s5 # c.mva01s07 s3, s5
    ab32:       854e                    mv      a0,s3 #
    ab34:       4903e0ef                jal     ra,48fc4 <__exp2f_finite@@GLIBC_2.27+0x1a16>

----

[NOTE]

  Combining a2 and a3 into a double move in either direction isn't beneficial enough in general to include in the ISA

[NOTE]

  We may need EABI versions of these instructions. TBD.

[NOTE]

  There are no 32-bit instructions, because 32-bit forms would add no value.

Mapping from the `s` register number to the `x` register index is simple for the UABI:

[source,sourceCode,text]
----

//000 (s0) -> 01000 (x8)
//001 (s1) -> 01001 (x9)
//010 (s2) -> 10010 (x18)
//011 (s3) -> 10011 (x19)
// ...         ...
//111 (s7) -> 10111 (x23)

//verilog syntax for concatenation of bits
xreg[4:0] = {sreg[2:1]>0,sreg[2:1]==0,sreg[2:0]};
----

The EABI mapping may not be so simple, TBD.

[#mva-16encodings]
.`C.MVA01S07, C.MVS07A01` 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10 | 9:7   | 6:5 | 4:2   | 1:0   |instruction         
|  100  | 111   | sreg1 | 11  | sreg2 | 01    | C.MVA01S07
|  100  | 111   | sreg1*| 10  | sreg2*| 01    | C.MVS07S01
|=============================================================================================

* Illegal instruction if `sreg1==sreg2`, so 56 code-points not 64

[#mva_semantics]
.`C.MVA01S07, C.MVS07A01` semantics
[width="100%",options=header]
|=======================================================================
|instruction  | definition
| C.MVA01S07  | mv a0, s[sreg1];  mv a1, s[sreg2]
| C.MVS07S01  | mv s[sreg1], a0;  mv s[sreg2], a1
|=======================================================================

[#mva_syntax]
.`C.MVA01S07, C.MVS07A01` assembler syntax
[width="100%",options=header]
|======================================================================================================
|instruction | example assembler syntax | requirements for 16-bit encoding   | 32-bit extension
|C.MVA01S07  | c.mva01s07 sreg1, sreg2  | none                               | N/A
|C.MVS07A01  | c.mvs07s01 sreg1, sreg2  | none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva01s07: sreg1 = 0; sreg2 = 0;
c.mva01s07 s0, s0; # mv a0, s0; mv a1, s0
# c.mvs07a01: sreg1 = 0; sreg2 = 1;
c.mvs07a01 s0, s1; # mv s0, a0; mv s1, a1
----

=== MULI

[NOTE]

  This encoding is in `custom-0`, a real encoding must be found possibly with a shorter immediate

[muli-encodings]
.`MULI` 32-bit encoding
[width="100%",options=header]
|=========================================================================================================================
| 31:20    |19:15 | 14:12   | 11:7      | 6 : 0 | instruction
|imm[11:0] |rs1   | 001     |rd         |0001011| MULI
|=========================================================================================================================

[#muli_syntax]
.`MULI` assembler syntax
[width="100%",options=header]
|=====================================
|instruction | assembler syntax       
|MULI        | mul rd, rs1, imm           
|=====================================

[#muli_semantics]
.`MULI` semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULI           |rd' = rs1' * sign_ext(imm)
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
muli     a0, a1, 2     # a0 = a1 * 2
----



[#cmpimmbr]
=== BEQI, BNEI

[NOTE]

  These encodings match the format for BEQ as much as possible

[NOTE]

  The encoding is not valid if `nzuimm=0` as `BEQ/BNE rs1, zero, offset` can be used instead.

The encodings allow a comparison of a register and an immediate value. `BEQI` in particular is very useful for _switch_ statements. 

[compare-immediate-branch_encodings]
.proposed 32-bit encodings for `BEQI/BNEI`
[width="100%",options=header]
|=========================================================================================================================
|  31:25             |24:20 |19:15       | 14:12   | 11:7              | 6 : 0 | instruction
| offset[12,10:5]    | rs2  |nzuimm[4:0] | 010     | offset[4:1,11]    |1100011| BEQI
| offset[12,10:5]    | rs2  |nzuimm[4:0] | 011     | offset[4:1,11]    |1100011| BNEI
|=========================================================================================================================

[#compare-immediate branch_semantics]
.Compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BEQI          | if (rs2==zero_ext(nzuimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI          | if (rs2!=zero_ext(nzuimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
beqi  a5, 1,offset # if(a5==zero_ext(1)) branch_to(PC+offset) 
bnei  a5, 2,offset # if(a5!=zero_ext(2)) branch_to(PC+offset) 
----

=== Table Jump

The specification is in <<tablejump>>.

[[tablejump16]]
==== C.TBLJ, C.TBLJAL, C.TBLJALM

The encodings are in <<tbljal16bitencoding>>.

[#pushpoppopret_heading]
=== PUSH and POP

See <<pushpoppopret>> for the specification.

[[pushpop32]]
==== PUSH, POP, POPRET, PUSH.E, POP.E, POPRET.E

See <<pushpoppopret32bitencodings>> for the encodings.

[[pushpop16]]
==== C.PUSH, C.POP, C.POPRET, C.PUSH.E, C.POP.E, C.POPRET.E

See <<proposed-16bit-encodingsI-1>> for the encodings.


=== B-extension recommended subsets for code-size reduction

The 32-bit encodings for `C.SEXT.*` and `C.ZEXT.*` from `Zcee` (see <<mon-32bit_not_neg>>) are in `Zba` and `Zbb`.

It is recommended to implement both `Zba` and `Zbb` for code-size reduction, but not required by `Zce`. They contain useful instructions for example:

. `Zba` includes `sh[123]add` which are used for address calculations.

. `Zbb` includes rotate (`rori, ror, rol`), byte reverse (`rev8`) and count-leading-zeroes (`clz`).

== `Zceb` definition

`Zceb` and the `D`-extension use the same encodings, therefore the two cannot co-exist and would be an illegal RISC-V configuration.

`Zceb` is compatible with `Zdinx`.

[Zceb-32bit-formats]
.proposed 32-bit formats
[width="100%",options=header]
|=========================================================================================================================
| 31:29    |28:25                  |24:20            |19:18|17:15       |14:12   | 11:7             | 6 : 0 | instruction
9+|These formats are designed for maximum overlap immediate with I-type and S-type
|funct3a 2+|imm[8:2,10:9]                          2+|imm[15:11]  | funct3 | rd               |opcode | LW16-type
|funct3a   |imm[8:5]               | rs2           2+|imm[15:11]  | funct3 | imm[4:2, 10:9]   |opcode | SW16-type
|funct3a 2+|imm[8:3,16,10:9]                       2+|imm[15:11]  | funct3 | rd               |opcode | LD16-type
|funct3a   |imm[8:5]               | rs2           2+|imm[15:11]  | funct3 | imm[4:3,16,10:9] |opcode | SD16-type
|=========================================================================================================================

=== Decrement and branch

[[decbr16]]
==== C.DECBNEZ

This instruction conflicts with the `D`-extension. If `D` is implemented, this instruction will not be available. It is compatible with `ZDinx`.

This instruction is a combined decrement and branch, used for inferring loops with an optionally scaled loop counter.

[NOTE]

  The 16 and 32-bit forms of this instruction need a new relocation type in the toolchain.

[NOTE]

  The 32-bit encoding has a signed offset. The 16-bit encoding has an unsigned offset, but it can only represent a backwards jump. 
  Therefore to be legal syntax for the 16-bit encoding the offset is specified as a negative number but encoded as a positive offset.
 
[NOTE]

  The encoding is reserved if the offset is zero.

[#proposed-16bit-encodings-dec_br]
.proposed 16-bit encodings for dec-and-branch
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10      | 9:7 | 6:4        | 3:2  | 1:0 |instruction         
|  101  |nzuimm[6:4] | rd' |nzuimm[3:1] |scale | 10 | C.DECBNEZ
|  101  |000         | rd' |000         |scale | 10 | *reserved*
|=============================================================================================

[#deccmpbrsemantics]
.decrement, compare and branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.DECBNEZ     | rd' = rd' - (1<<scale); bnez rd', -zero_ext(nzuimm);
|=======================================================================

[#v1.0-32bit]
.32-bit equivalent instructions for decrement, compare and branch semantics
[width="100%",options=header]
|======================================================================================================
|instruction | example assembler syntax  | requirements for 16-bit encoding   | 32-bit extension
|C.DECBNEZ   | decbnez rd, scale, -nzuimm | rd is x8-x15, scale is [1248], nzuimm is in range   | Zceb
|======================================================================================================

[NOTE]

  Other assembler syntaxes are possible such as including the c. prefix 


Assembly Example
[source,sourceCode,text]
----
decbnez s2, 1, -4 ;# s2-=1;if(s2!=0) branch_to(PC-4) encoded as scale=0, nzuimm=4
----

==== DECBNEZ (limited value?)

This instruction conflicts with the `D`-extension. If `D` is implemented, this instruction will not be available. It is compatible with `ZDinx`. 

The 16-bit encoding and specification is in <<decbr16>>.

[NOTE]

  This instruction appears to have limited value, and so it may well be removed.

[NOTE]

  The 16 and 32-bit forms of this instruction need a new relocation type in the toolchain.

[DECBNEZ-32bit-encodings]
.proposed 32-bit encoding `DECBNEZ`
[width="100%",options=header]
|=========================================================================================================================
| 31:29    |28:25                  |24:20            |19:18|17:15       |14:12   | 11:7             | 6 : 0 | instruction
|100     2+|imm[8:2,10:9]                            |scale|imm[1,12:11]  | 011 | rd                |0000111 | DECBNEZ
|=========================================================================================================================

[#DECBNEZsemantics32]
.decrement, compare and branch 32-bit semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| DECBNEZ       | rd = rd - (1<<scale); bnez rd, sign_ext(imm);
|=======================================================================

Assembly Example
[source,sourceCode,text]
----
decbnez s2, 1, offset ;# s2-=1;if(s2!=0) branch_to(PC+offset)
----


=== LWGP, SWGP, LDGP, SDGP

These instructions conflict with the `D`-extension. If `D` is implemented, these instruction will not be available. They are compatible with `Zdinx`.

These instructions reuse the encodings for `FLD/FSD`.

`LWGP,SWGP` give a larger offset range than the standard `LW, SW` instructions by making the base register explicitly `gp`, allowing a 16-bit/64KB range of word aligned offsets, instead of a 12-bit/4KB range of byte aligned offsets.

`LDGP,SDGP` require double word alignment, and so have an increased range of 17-bit/128KB offsets relative to `gp`.

[NOTE]

   Restrictions in the GCC toolchain mean that the full range of `gp` cannot be used for the standard `LW/SW` instructions, in case linker relaxation means that the `gp` relative addresses moves out of range. This will still be the case with `LWGP, SWGP` but the range is so much larger that the impact will be minimal. https://github.com/riscv/riscv-gnu-toolchain/issues/497[See this github issue]. This issue means that with the current RISC-V ISA the full 4KB range cannot be accessed using `gp` using GCC so the benefit is lower than might be expected.

[Zceb-32bit-encodings]
.proposed 32-bit encodings for `LWGP/SWGP` and `LDGP/SDGP`
[width="100%",options=header]
|=========================================================================================================================
| 31:29|28:25   |24:20      |19:15 | 14:12   | 11:7  | 6 : 0 | instruction
|000 2+|imm[8:2,10:9]                                |imm[15:11]  | 011   | rd                |0000111| LWGP
|000   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:2, 10:9]    |0100111| SWGP
8+|RV64/RV128 only
|010 2+|imm[8:3,16,10:9]                             |imm[15:11]  | 011   | rd                |0000111| LDGP
|010   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:3,16,10:9]  |0100111| SDGP
|=========================================================================================================================

[NOTE]

  In <<lwgp_semantics>> DataMemory is a data memory array of elements with XLEN width.

[#lwgp_semantics]
.Load/store word/double GP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| LWGP          | rd=sign_ext(DataMemory[gp+sign_ext(imm)][31:0]);
| SWGP          | DataMemory[gp+sign_ext(imm)][31:0])=rs2[31:0];
2+|RV64/RV128 only
| LDGP          | rd=sign_ext(DataMemory[gp+sign_ext(imm)][63:0]);
| SDGP          | DataMemory[gp+sign_ext(imm)][63:0])=rs2[63:0];
|=======================================================================

Assembly Examples
[source,sourceCode,text]
----
lw s0, 20(gp)
sw s0, 20(gp)

//RV64/RV128 only
ld s0, 20(gp)
sd s0, 20(gp)
----

=== C.LBU, C.LHU, C.LB, C.LH, C.SB, C.SH

These instructions conflict with the `D`-extension. If `D` is implemented, these instruction will not be available. They are compatible with `Zdinx`.

[#ldstbh]
.proposed 16-bit encodings for load/store byte/half
[width="100%",options=header]
|=============================================================================================
| 15:13  | 12 | 11:10    | 9:7  | 6:5      |4:2   | 1:0|instruction         
|  001   |0   |uimm[0,3] | rs1' |uimm[2:1] |rd'   | 00 | C.LBU
|  001   |1   |uimm[4:3] | rs1' |uimm[2:1] |rd'   | 00 | C.LHU
|  001   |0   |uimm[0,3] | rs1' |uimm[2:1] |rd'   | 10 | C.LB
|  001   |1   |uimm[4:3] | rs1' |uimm[2:1] |rd'   | 10 | C.LH
|  101   |0   |uimm[0,3] | rs1' |uimm[2:1] |rs2'  | 00 | C.SB
|  101   |1   |uimm[4:3] | rs1' |uimm[2:1] |rs2'  | 00 | C.SH
|=============================================================================================

[NOTE]

  Because of the short offsets available in the 16-bit encodings, if programmers place byte/short values near the base of their structures then it's more likely that they will be accessible with a 16-bit encoding and therefore save code-size.

[NOTE]

  In <<ldstbhsemantics>> DataMemory is a data memory array of elements with XLEN width

[#ldstbhsemantics]
.Load/store byte/half semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBU         | rd' = zero_ext(DataMemory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(DataMemory[rs1'+zero_ext(uimm)][15:0])
| C.LB          | rd' = sign_ext(DataMemory[rs1'+zero_ext(uimm)][ 7:0])
| C.LH          | rd' = sign_ext(DataMemory[rs1'+zero_ext(uimm)][15:0])
| C.SB          | rd' = DataMemory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = DataMemory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh-32bit]
.Load/store byte-half 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | example assembler syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBU       | lbu    rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|C.LHU       | lhu    rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|C.LB        | lb     rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|C.LH        | lh     rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|C.SB        | sb     rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|C.SH        | sh     rd, imm(rs1)            | all regs x8-x15, imm in range      | I-extension
|======================================================================================================

[NOTE]

  Other assembler syntaxes are possible such as including the c. prefix 

Assembly Examples
[source,sourceCode,text]
----
lbu a5,10(a4)   # a5 = zero_ext(DataMemory(a4+10)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(DataMemory(a4+20)[15:0])
lb  a5,10(a4)   # a5 = sign_ext(DataMemory(a4+10)[ 7:0])
lh  a5,20(a4)   # a5 = sign_ext(DataMemory(a4+20)[15:0])
sb  a5,10(a4)   # DataMemory(a4+10)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # DataMemory(a4+20)[15:0] = a5[15:0]
----

[#tablejump]
== Table Jump 

Table jumps are used to reduce the code size of `JAL` / `AUIPC+JALR` / `JR` / `AUIPC+JR` instructions.

=== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  #64-bit AUIPC/JALR sequence
  e084be:	001f8317            auipc t1,0x1f8
  e084c2:	18a302e7            jalr  t0,394(t1) # 1000648 <__riscv_save_0>
  
  e084c6:	86b2                mv    a3,a2
  e084c8:	862e                mv    a2,a1
  e084ca:	800005b7            lui	  a1,0x80000
  e084ce:	fff5c593            not	  a1,a1
  
  #32-bit JAL
  e084d2:	f61ff0ef            jal	  ra,e08432 <vsnprintf> # vsnprintf
  
  #64-bit AUIPC/JALR sequence
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	  406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJ*` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	<16-bit>            tbljalm x ;#<mapped to __riscv_save_0>, saving 6-bytes
  
  e084c6:	86b2                mv     a3,a2
  e084c8:	862e                mv     a2,a1
  e084ca:	800005b7            lui	   a1,0x80000
  e084ce:	fff5c593            not	   a1,a1
  
  e084d2:	<16-bit>            tbljal y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  
  e084da:	<16-bit>            tblj   z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJALENTRIES` addresses for `C.TBLJ*`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. 

`TBLJALENTRIES` is set by the maximum size of the table, which is 256 as the encoding has an 8-bit index.

Table jump allows the linker to:

* replace 32-bit `J` calls with `C.TBLJ`
* replace 32-bit `JAL ra` calls with `C.TBLJAL`
* replace 32-bit `JAL t0` calls with `C.TBLJALM` (`M` for Millicode)
* replace 64-bit `AUIPC/JR` calls to fixed locations with `C.TBLJ`
* replace 64-bit `AUIPC/JALR ra` calls to fixed locations with `C.TBLJAL`
* replace 64-bit `AUIPC/JALR t0` calls to fixed locations with `C.TBLJALM`
** The `AUIPC+JR/JALR` sequence is used because the offset from the PC is out of the Â±1MB range.

=== Encoding

These instructions use a previously reserved encoding.

[#tbljal16bitencoding]
.C.TBLJAL 16-bit encoding
[width="100%",options=header]
|=============================================================================================
| 15:13 | 12:10  | 9:2                   | 1:0   |instruction         
|  100  | 010    |index8<8               | 00    | C.TBLJALM
|  100  | 010    |index8>=8 && index8<64 | 00    | C.TBLJ
|  100  | 010    |index8>=64             | 00    | C.TBLJAL
|=============================================================================================

[#tbljal16bitassemblersyntax]
.C.TBLJAL assembler syntax
[width="100%",options=header]
|==================================================================================================================
|instruction | example assembler syntax   | requirements for 16-bit encoding         | 32-bit extension
|C.TBLJALM   | tbljalm n                  | n is in the range 0 to 7   (index8=n)    | N/A
|C.TBLJ      | tblj    n                  | n is in the range 0 to 55  (index8=n+8)  | N/A
|C.TBLJAL    | tbljal  n                  | n is in the range 0 to 191 (index8=n+64) | N/A
|==================================================================================================================

[NOTE]

  Other assembler syntaxes are possible such as including the c. prefix 

Therefore there is a single jump table in memory. The table entry number is from the `index8` field in the encoding, which controls the link register.

* `C.TBLJALM`: entries 0-7,    link to `t0`
* `C.TBLJ`   : entries 8-63,   link to `zero`
* `C.TBLJAL` : entries 64-255, link to `ra`

Note that the LSB of every jump table entry is _ignored_ which matches standard `JALR` behaviour.

[#configuringthejumptable]
=== Recommended algorithm for allocating entries in the jump table

Calls to each function are categorised as shown in <<tbljalsavings>>.

[#tbljalsavings]
.C.TBLJAL/TBJAL code size saving per function
[width="100%",options=header]
|=======================================================================================================================
| original sequence | `C.TBLJ*` saving  
| `J`               | A*2-(XLEN/8) bytes 
| `AUIPC+JR`        | B*6-(XLEN/8) bytes 
| `JAL ra`          | C*2-(XLEN/8) bytes 
| `AUIPC+JALR ra`   | D*6-(XLEN/8) bytes 
| `JAL t0`          | E*2-(XLEN/8) bytes 
| `AUIPC+JALR t0`   | F*6-(XLEN/8) bytes 
|=======================================================================================================================

[NOTE]

  `C.JAL` is not included as there's no code-size saving for RV32 and it's not available for RV64

Each function is called by using one of the three link registers. The total saving per function is calculated by counting the number of calls and adding up the total saving from each replacement of the existing sequence with `C.TBLJ*`, as follows:
[source,sourceCode,text]
----
saving_per_function_c_tblj    = A * 2 + B * 6 - 2*(XLEN-8)
saving_per_function_c_tbljal  = C * 2 + D * 6 - 2*(XLEN-8)
saving_per_function_c_tbljalm = E * 2 + F * 6 - 2*(XLEN-8)
----

The functions are sorted so that the one with the highest saving is in table entry 0, the second highest in entry 1 etc. for that encoding.

[NOTE]

  This algorithm assumes that each function is only called with one link register. If the same funciton is called with more than one link register, then it must have two entries in the table.

This allows the core to cache the most frequent targets by caching the lowest numbered entries of each section of the jump table. Only caching a few entries will greatly improve the performance.

=== CSRs

The CSR is required to control the jump table, and it forms part of the current context. The jump table and `TBLJALVEC` must be configured before the first `C.TBLJ*` instruction is executed.

[NOTE]

  The address is for a custom CSR, a correct CSR address need to be specified.

[#TBLJALVEC-table]
.`TBLJALVEC` definition
[width="100%",options=header]
|============================================================================================================
|Address |XLEN-1:6       |5:0   | CSR        | Permissions | Status
|  0x800 |base[XLEN-1:6] |config| TBLJALVEC  | URW         | Required
|============================================================================================================

`TBLJALVEC.base` is a virtual address, whenever virtual memory is enabled.

Using `TBLJALVEC.base` in the pseudo code below implicitly assumes that `TBLJALVEC.base[5:0]=0`. This is consistent with the description of `xTVEC` in the Unprivileged ISA manual.

`TBLJALVEC.base` is naturally aligned for all legal values of `XLEN`.

The memory pointed to by `TBLJALVEC.base` only requires eXecute permission. Read/Write access is not required once the jump table/vector table has been configured.

[#TBLJALVEC-config-table]
.`TBLJALVEC.config` definition
[width="100%",options=header]
|=============================================================================================
| TBLJALVEC.config | Comment
| 000000 | Jump table mode
| others | *reserved for future standard use*
|=============================================================================================

`TBLJALVEC.config` is a WARL field, so can only be programmed to modes which are implemented. Therefore the discovery mechanism is to attempt to program different modes and read back the values to see which are available. Jump table mode _must_ be implemented.

=== Jump table mode

In jump table mode the behaviour is to load the target address from `TBLJALVEC.base` with an offset which is `XLEN/8` times the parameter passed to the instruction.

The actual functions are not moved in memory, the jump table lookup is only to give a reference to them using a 16-bit encoding.

Jump table mode is implemented in the linker and doesn't affect the compiler, as it is only a link time optimisation. 

==== Pseudo-code for jump table mode

[NOTE]

  InstMemory below is an instruction memory array of elements with XLEN width.

[source,sourceCode,text]
----
# target_address is temporary internal state, it doesn't represent a real register
# Mem is byte indexed
# index8 is the field from the encoding, not the index passed to the C.TBLJ* in the assembler

switch(XLEN) {
  32:  table_address[XLEN-1:0] = TBLJALVEC.base + index8<<2;
  64:  table_address[XLEN-1:0] = TBLJALVEC.base + index8<<3;
  128: table_address[XLEN-1:0] = TBLJALVEC.base + index8<<4;
}

//check for debug mode entry, trigger with timing=0 and action=1, haltreq or step
if ((debug_trigger(table_address) && MCONTROL.timing==0 && MCONTROL.action==1) || 
    external_debug_haltreq() || DCSR.step==1) {
  DPC        = current_PC;
  DCSR.cause = DCSR.step==1 ? 4 : external_debug_haltreq() ? 3 : 2;
  enter_debug_mode();
//check for breakpoint trigger which takes an exception with timing=0
} else if ((debug_trigger(table_address) && MCONTROL.timing==0) || 
            !can_access_instruction_memory(table_address)) {
  MEPC   = current_PC;
  MTVAL  = table_address;
  MCAUSE = debug_trigger(table_address) ? BREAKPOINT : INSTRUCTION_ACCESS_FAULT;
  take_exception();
} else {
  //access the jump table
  switch(XLEN) {
    32:  LW target_address, InstMemory[table_address][XLEN-1:0];
    64:  LD target_address, InstMemory[table_address][XLEN-1:0];
    128: LQ target_address, InstMemory[table_address][XLEN-1:0];
  }
  
  //don't use haltreq or step here, only check the addresses
  //check for table_address after reading if timing=1
  if (debug_trigger(table_address) && MCONTROL.timing==1 && MCONTROL.action==1) {
    DPC        = current_PC;
    DCSR.cause = 2;
    enter_debug_mode();
  } else if (debug_trigger(table_address) && MCONTROL.timing==1) {
    MEPC       = current_PC;
    MTVAL      = table_address;
    MCAUSE     = BREAKPOINT;
    take_exception();
  } else if ((debug_trigger(target_address) && MCONTROL.timing==0 && MCONTROL.action==1) {
    DPC        = target_address;
    DCSR.cause = 2;
    enter_debug_mode();
  } else if (((debug_trigger(target_address) && MCONTROL.timing==0) || 
               !can_access_instruction_memory(target_address)) {
    MEPC       = target_address;
    MTVAL      = target_address;
    MCAUSE     = debug_trigger(target_address) ? BREAKPOINT : INSTRUCTION_ACCESS_FAULT;
    take_exception();
  } else {
    //jump to the target address
    switch(opcode) {
      C.TBLJALM: JALR t0,   target_address[XLEN-1:0]&~0x1;
      C.TBLJ:    JALR zero, target_address[XLEN-1:0]&~0x1;
      C.TBLJAL:  JALR ra,   target_address[XLEN-1:0]&~0x1;
    }
  }
}

//check the target_address afterwards if timing=1
if (((debug_trigger(target_address) && MCONTROL.timing==1 && MCONTROL.action==1)) {
  DPC        = target_address;
  DCSR.cause = 2;
  enter_debug_mode();
} else if ((debug_trigger(target_address) && MCONTROL.timing==1) {
  MEPC       = target_address;
  MTVAL      = target_address;
  MCAUSE     = BREAKPOINT;
  take_exception();
}
----

For the `vsprintf` example above, the jump table contains the following for `RV32`:

[source,sourceCode,text]
----
TBLJALVEC.base+ 32(index  0) = # 100064a <__riscv_save_0>    # called with C.TBLJALM #0 (index8=0  in the encoding)
TBLJALVEC.base+  0(index  8) = # 100066c <__riscv_restore_0> # called with C.TBLJ    #0 (index8=8  in the encoding)
TBLJALVEC.base+256(index 64) = #  e08433 <vsnprintf>         # called with C.TBLJAL  #0 (index8=64 in the encoding)
----

==== Exceptions for jump table mode

Two instruction memory accesses are required. 

- The first memory access is to the jump table.
- The second memory access is from dereferencing the jump table entry and fetching the address of the destination function.

A fault from accessing the destination function address can only be taken if the read from the jump table completed successfully.

The address of the table jump entry is considered to be an instruction address, and so is checked against all possible sources of address faults such as page faults and instruction address breakpoints. When a fault occurs on the jump table address, the saved PC is the PC of the `C.TBLJ*` instruction, which is stored in `MEPC` or `DPC` as required.

_Example 1: the jump table entry itself caused a fault_

- `MEPC`  = the PC of the `C.TBLJ*` instruction
- `MTVAL` = the address of the jump table entry

_Example 2: the destination function caused a fault_

- `MEPC`  = the PC of the destination function
- `MTVAL` = the PC of the destination function

==== Single stepping

When single stepping across a `C.TBLJ*` instruction, execution stops before the `C.TBLJ*`, and then stops before the first instruction of the destination function. The fetch from the jump table only becomes visible if it causes a fault, as shown above.

==== Context Switching for jump table mode

The `TBLJALVEC` CSR forms part of the current context, and so will need to be saved and restored.

==== Caching for jump table mode

For improved performance, the implementation may cache the contents of the jump table. To maintain coherency between stores to the jump table and the instruction fetch, then a `FENCE.I` is required, or other standard coherency mechanism as defined by RISC-V. More generally, any jump table cache should be flushed whenever the instruction cache is flushed.

[#vector-table-mode]
=== Future Mode: Vector table mode (not for RVM22/RVA22)

Vector table mode is very similar to vectored interrupt handling. The target address is a scaled offset from the base vector. Therefore in vector table mode, execution passes directly to the scaled offset from the base register, not via a jump table.

Vector table mode is similar to the mechanism for the interrupt handler vector. The jump is direct to the destination. However the compiler would have to be aware as it will have to try to fit functions into the table, as each entry is a fixed size so it's not so obviously implementable in the toolchain. We may find other reasons for having this mode. TBD.

`TBLJALVEC.scale` controls the scale. It is a read/write field instead of WARL.

[width="40%",options=header]
|==================================================================
|`TBLJALVEC.scale`| `tablescale` 
| 0                | 8-bytes
| 1                | 16-bytes
| 2                | 32-bytes
2+| .....
| 9                | 4096-bytes to match minimum TLB page size
| 10+              | *reserved*
|==================================================================

Note that `tablescale = 1<<(TBLJALVEC.scale+3)`

==== Pseudo-code for vector table mode

[NOTE]

  InstMemory below is an instruction memory array of elements with XLEN width.

[source,sourceCode,text]
----
# Mem is byte indexed
# n is the immediate operand passed to c.tblj*
switch(opcode) {
  C.TBLJ:    JALR zero, InstMemory[TBLJALVEC.base + n*tablescale][XLEN-1:0]&~0x1;
  C.TBLJAL:  JALR ra,   InstMemory[TBLJALVEC.base + n*tablescale][XLEN-1:0]&~0x1;
  C.TBLJALM: JALR t0,   InstMemory[TBLJALVEC.base + n*tablescale][XLEN-1:0]&~0x1;
}
----

==== vector table code

Because this method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `TBLJALVEC.scale` to specific values does not set a requirement on the alignment of `TBLJALVEC.base`. For example if `tablescale=4096`, `TBLJALVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `TBLJALVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a `C.TBLJALM` instruction to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `TBLJALVEC.scale=1` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is 136 bytes, but will shrink to 128-bytes or smaller by use of `c.tbljal` so I have allocated 4 entries to it.

[source,sourceCode,text]
----

# index 0 (JAL t0 called by C.TBLJALM #0 (index8=0 in the encoding))
TBLJALVEC.base+32  <__riscv_save_0>:
 	1141                	addi	sp,sp,-16
 	c04a                	sw	s2,0(sp)
 	c226                	sw	s1,4(sp)
 	c422                	sw	s0,8(sp)
 	c606                	sw	ra,12(sp)
 	8282                	jr	t0

#index 8 (JAL zero called by C.TBLJ #0 (index8=8 in the encoding))
TBLJALVEC.base+0 <__riscv_restore_0>:
 	4902                	lw	s2,0(sp)
 	4492                	lw	s1,4(sp)
 	4422                	lw	s0,8(sp)
 	40b2                	lw	ra,12(sp)
 	0141                	addi	sp,sp,16
 	8082                	ret

# index 64-67 (JAL ra called by C.TBLJAL #0 (index8=64 in the encoding))
TBLJALVEC.base+48: <vsnprintf>
  	xxxx                	tbljalm #0 ;# call to <__riscv_save_0>
  ...  up to 128-byte function body ...
  	xxxx                	tblj #0 ;# call to <__riscv_restore_0>
----

[NOTE]

  This mode may waste memory as the target functions are very unlikely to all be multiples of `tablescale`.

==== Vector Mode Security (future ideas)

The vector mode mechanism could be reused for security in the future. It is possible to define that the memory allocated to to the table can only have entry points on the specific vectors, and also only from `C.TBLJ*` instructions. In this way sensitive code can be placed in the table which cannot be reused for ROP/JOP gadgets, because the code cannot be targetted by `JALR` instructions.

These ideas will not be pursued as part of the code size work.

[[emulation-mode]]
=== Future Mode: Emulation Mode (not for RVM22/RVA22)

Emulation mode is the simplest. It doesn't have a jump table or vector table, so allow a minimal hardware implementation.
It relies on the values in temporary registers not being maintained across function calls.

_There are concerns about overwriting the temporary registers so this may be rejected_

==== Pseudo-code for emulation mode

[source,sourceCode,text]
----
t4 = TBLJALVEC.base;
t5 = n;       #table index
JALR t4, t4;  # t4 gets PC+2 for c.tbljal, PC+4 for tbljal
----

=== Diagram for all table jump modes

.all three modes
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump4.PNG[all three modes]

[#pushpoppopret]
== PUSH and POP

`PUSH, POP, POPRET` and `PUSH.E, POP.E, POPRET.E` along with the 16-bit forms are used to reduce the size of function prologues and epilogues.

=== A brief example from Zephyr

This example gives a nice illustration of what `PUSH, POP, POPRET` are trying to achieve.

[source,sourceCode,text]
----
from subsys/bluetooth/controller/crypto/crypto.c
int bt_rand(void *buf, size_t len)
{
        return lll_csrand_get(buf, len);
}
----

compiles with GCC10 to:

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	1141                	addi	sp,sp,-16	;#PUSH(1)
2040545a:	c04a                	sw	s2,0(sp)	;#PUSH(2)
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
20405464:	c422                	sw	s0,8(sp)	;#PUSH(3)
20405466:	c226                	sw	s1,4(sp)	;#PUSH(4)
20405468:	c606                	sw	ra,12(sp)	;#PUSH(5)
2040546a:	842a                	mv	s0,a0		;#PUSH(6)
2040546c:	84ae                	mv	s1,a1		;#PUSH(7)
<function body>
20405494:	4501                	li	a0,0		;#POPRET(1)
20405496:	40b2                	lw	ra,12(sp)	;#POPRET(2)
20405498:	4422                	lw	s0,8(sp)	;#POPRET(3)
2040549a:	4492                	lw	s1,4(sp)	;#POPRET(4)
2040549c:	4902                	lw	s2,0(sp)	;#POPRET(5)
2040549e:	0141                	addi	sp,sp,16	;#POPRET(6)
204054a0:	8082                	ret			;#POPRET(7)
----

with the GCC option `-msave-restore` the output is the following:

[source,sourceCode,text]
----
204089ac <bt_rand>:
204089ac:       f97f72ef                jal     t0,20400942 <__riscv_save_0>	;#PUSH(1)
204089b0:       70001937                lui     s2,0x70001
204089b4:       ac090613                addi    a2,s2,-1344 # 70000ac0 <prng>
204089b8:       842a                    mv      s0,a0	;#PUSH(2)
204089ba:       84ae                    mv      s1,a1	;#PUSH(3)
<function_body>
204089e2:       4501                    li      a0,0	;#POPRET(1)
204089e4:       f83f706f                j       20400966 <__riscv_restore_0>	;#POPRET(2)
----

with `PUSH/POPRET` this reduces to

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	<16-bit>                push	 {ra,s0-s2},{a0-a2},-16
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
<function body>
20405496:	<16-bit>                popret	 {ra,s0-s2},{0}, 16

----

The prologue / epilogue reduce from 28-bytes in the original code, to 14-bytes with `-msave-restore`, and to to 8-bytes with `PUSH, POP, POPRET`, which will also improve the performance.
  
[NOTE]

  The calls to `<riscv_save_0>/<riscv_restore_0>` become 64-bit when the target functions are out of the Â±1MB range, increasing the prologue/epilogue size to 22-bytes.

[NOTE]

  The `C.PUSH` has an additional register move included `mv s2, a2` which wasn't in the original prologue. This is included to simplify the encoding and definition of `C.PUSH/PUSH` and will cost some performance.

[#uabiandeabisupport]
=== UABI and EABI support

The UABI is available on all RVI cores. The EABI is optional on RV32I and required on RV32E.

The UABI supports saved registers `s0-s11`, the EABI supports saved registers `s0-s4` only but `s2-s4` are mapped to _different_ `X` registers.

Therefore encodings which support register lists which include up to `s1` can be used for both ABIs. As soon as the list includes `s2` then a different encoding is required.

This specification for the EABI is taken from https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[this document].

The `PUSH/POP/POPRET/C.PUSH/C.POP/C.POPRET` instructions support the UABI. The `PUSH.E/POP.E/POPRET.E/C.PUSH.E/C.POP.E/C.POPRET.E` instructions support the EABI.

Where the `X` register list is the same for both ABIs the EABI version is a pseudo-instruction, where the `X` register list is different it has a different encoding, for example: 

* `c.pop.e {ra, s0}, 32` is a pseudo-instruction for `c.pop {ra, s0}, 32`
* `c.pop.e {ra, s0-s2}, 32` has a different encoding to `c.pop {ra, s0-s2}, 32`

It is recommended that:

* when compiling/disassembling for the UABI, the pseudo-instructions with the `.E` suffix _should not_ be used.
* when compiling/disassembling for the EABI, the pseudo-instructions with the `.E` suffix _should_ be used.

The `.E` forms are not available on RV64I or RV128I. Any encodings with a `.E` suffix are reserved on those base architectures.

[#ABI-on-base-arch]
.ABIs on different base architectures
[width="100%",options=header]
|=========================================================================================================================
| Base architecture | UABI | EABI | Notes
| RV32I             | y    | y   | Full support of both ABIs required
| RV32E             |       | y   | Binary can execute on RV32I
| RV64I/RV128I      | y    |      | No EABI support on RV64I/RV128I
|=========================================================================================================================

Code compiled for RV32I may be compiled for the UABI or EABI. Code compiled for RV32E may be executed on an RV32I core. 

[NOTE]

  An RV32I core running the EABI has many saved registers. The `PUSH/POP` encodings only support up to `s4`. There are no encodings which support saving higher numbered `s` registers in this case, and so the optimal solution would be for a reduced version of `-msave-restore` which is used for longer register lists. A future version of `Zce` may include new cases in the 32-bit encodings to save the higher `s` registers. At the timing of writing the EABI specification is not frozen and there is no toolchain publicly available so the distribution of higher numbered saved registers for RV32I EABI cannot be assessed.

=== Assembler Syntax

. The `PUSH` instruction 
** pushes(stores)  the registers specified in `reg_list` to the stack
** adjusts the stack pointer by the `stack_adjustment` 

. The `POP` instruction 
** pops(loads) the registers in `reg_list` from the stack
** adjusts the stack pointer by the `stack_adjustment`.

. The `POPRET` instruction
** pops(loads) the registers in `reg_list` from the stack
** if `ret_val` is included, moves the specified constant value into `a0` as the return value
** adjusts the stack pointer by the `stack_adjustment`.

32-bit and 16-bit forms of all instructions are available, the assembler should choose the 16-bit form if the parameters permit.

The registers in `reg_list` is a comma separated list and must not be empty.

The assembler/disassembler can choose whether to include the `c.` prefix for 16-bit encodings. The recommendation is to exclude it.

[#pushpop32bitsyntax]
==== 32-bit encoding assembler syntax

There are different definitions for the register lists in use (`reg_list_32u/reg_list_16u/reg_list_e`). 

The stack adjustment range varies between encodings. The syntax `stack_adjustment_0_N` is used. The stack adjustment value must be the total memory required for the registers in `reg_list_*` rounded up to a multiple of 16-bytes, plus an additional 0 to `N` * 16-bytes. Also see <<spimm>>.

This syntax is for the 32-bit encodings, for the UABI

[source,sourceCode,text]
----
<ret_val_32>     ::= "" | 0 | 1 | -1
<sreg_list_32u>  ::=      <s0>  | <s0-sN>   (where N is in the range [1, 11])
<reg_list_32u>   ::= <ra> ["," <sreg_list_32u>]

//<reg_list_Lu> can also be expressed using X registers using the standard UABI mapping

if (<reg_list_Lu>=="ra")         <xreg_list_Lu>="x1"
if (<reg_list_Lu>=="ra, s0")     <xreg_list_Lu>="x1, x8"
if (<reg_list_Lu>=="ra, s0-s1")  <xreg_list_Lu>="x1, x8-x9"
if (<reg_list_Lu>=="ra, s0-s2")  <xreg_list_Lu>="x1, x8-x9, x18"
if (<reg_list_Lu>=="ra, s0-sN")  <xreg_list_Lu>="x1, x8-x9, x18-xM" (where M=N+16 and N is in the range [3, 11])

//legal syntax for 32-bit encodings. 
//and that both register lists must use either ABI names or `x` numbers.

push         {<reg_list_32u> | <xreg_list_32u>},              -stack_adjustment_0_31
popret       {<reg_list_32u> | <xreg_list_32u>}, {ret_val_32}, stack_adjustment_0_31
pop          {<reg_list_32u> | <xreg_list_32u>},               stack_adjustment_0_31

----

This syntax is for the 32-bit encodings, for the EABI, which has a shorter range of `s` registers. Note that if the highest register in `sreg_list_e` is `s2` or lower, then this instruction is a _pseudo-instruction_ for the non `.e` version. If `sreg_list_e` includes `s3` or `s4` then it is a separate encoding. Unlike the UABI encodings above, the `s` registers are not always listed sequentially as the `x` register order is the important one - the `x` register list is sequential.

[source,sourceCode,text]
----
<sreg_list_e>  ::= <s0>  | <s0-s1> | <s0-s2> | <s3,s0-s2> | <s3-s4,s0-s2>   
<reg_list_e>   ::= <ra> ["," <sreg_list_e>]
if (<reg_list_e>=="ra")               <xreg_list_e>="x1"
if (<reg_list_e>=="ra, s0")           <xreg_list_e>="x1, x8"
if (<reg_list_e>=="ra, s0-s1")        <xreg_list_e>="x1, x8-x9"
if (<reg_list_e>=="ra, s0-s2")        <xreg_list_e>="x1, x8-x9, x14"
if (<reg_list_e>=="ra, s3, s0-s2")    <xreg_list_e>="x1, x6, x8-x9, x14"
if (<reg_list_e>=="ra, s3-s4, s0-s2") <xreg_list_e>="x1, x6-x9, x14"

push.e         {<reg_list_e> | <xreg_list_e>},               -stack_adjustment_0_31
popret.e       {<reg_list_e> | <xreg_list_e>}, {ret_val_32},  stack_adjustment_0_31
pop.e          {<reg_list_e> | <xreg_list_e>},                stack_adjustment_0_31

----

[NOTE]

  An earlier version of the specification allowed `ra` to be excluded from the register list. This caused a lot of complexity in the specifications above and we found very few cases in the benchmark suite where it would have been beneficial. If `ra` is not required then `PUSH/C.PUSH` can still be used, which will waste `XLEN` bits of stack memory but `POP/POPRET` etc. _cannot_ as they would overwrite `ra`

==== 16-bit encoding assembler syntax

This syntax is for the 16-bit encodings, for the UABI. The rules stated above for the 32-bit encodings also apply.

[source,sourceCode,text]
----
<sreg_list_16u>  ::= <s0>  | <s0-sN>   (where N is 1,2,3,5,7,11)
<reg_list_16u>   ::= <ra> ["," <sreg_list_16u>]

c.push       {<reg_list_16u>},  -stack_adjustment_0_5
c.push       {<xreg_list_16u>}, -stack_adjustment_0_5

c.popret     {<reg_list_16u> | <xreg_list_16u>}, {"" | 0}, stack_adjustment_0_5
c.pop        {<reg_list_16u> | <xreg_list_16u>},           stack_adjustment_0_1

----

This syntax is for the 16-bit encodings, for the EABI. All variables have been previously defined.

[source,sourceCode,text]
----

c.push.e     {<reg_list_e>},  -stack_adjustment_0_5
c.push.e     {<xreg_list_e>}, -stack_adjustment_0_5

c.popret.e   {<reg_list_e> | <xreg_list_e>}, {"" | 0},       stack_adjustment_0_5
c.pop.e      {<reg_list_e> | <xreg_list_e>},                 stack_adjustment_0_1

----

Examples of valid 16-bit encodings for RV32I or RV64I using the UABI:

[source,sourceCode,text]
----

c.push   {ra},                  -16; //store ra;        decrement sp by 16
c.push   {ra,s0},               -32; //store ra,s0;     decrement sp by 32
c.push   {ra,s0-s1},            -96; //store ra,s0-s1;  decrement sp by 96
c.push   {x1, x8-x9, x18-x13}, -128; //store ra,s0-s11; decrement sp by 128

c.pop    {ra},        16;  //load  ra;        increment sp by 16
c.popret {x1}, {},    16;  //load  ra;        increment sp by 16; jump to ra

c.pop    {ra,s0},         32;  //load  ra,s0;     increment sp by 32
c.popret {x1, x8},   {0}, 32;  //load  ra,s0;     increment sp by 32; li a0, 0; jump to ra
c.popret {ra,s0-s3}, {},  96;  //load  ra,s0-s3;  increment sp by 96;           jump to ra
c.popret {ra,s0-s11},{}, 128;  //load  ra,s0-s11; increment sp by 128;          jump to ra

----

For example

. `c.push   {ra,s0-s2},   -64` can use a 16-bit encoding
. `push     {ra,s0-s2},  -256` can use a 32-bit encoding as the `stack_adjustment` is out of range for `c.push`
.. a `c.addi16sp; c.push` sequence achieves the same code-size
. `c.popret {ra,s0-s2}, {0},       32` can use a 16-bit encoding
. `popret   {ra,s0-s2}, {1},       32` must use a 32-bit encoding as `c.popret` only supports `0` as the `ret_val` value

=== Determining XLEN to decode and execute the instructions

The execution of the instructions depends upon `XLEN`, as the width of the loads and stores change. From the ELF file header, the dissembler can determine `XLEN` by the following flags:

* ELFCLASS64 for RV64
* ELFCLASS32 for RV32 

[NOTE]

  I don't think there's an ELFCLASS128 for RV128

If using a debugger then `misa.MXL` can be read, if XLEN is not known for the core.

Follow this link for details of the https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#file-header[ELF file header]

=== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

==== PUSH/PUSH.E/C.PUSH/C.PUSH.E Pseudo-code

The `PUSH/PUSH.E/C.PUSH/C.PUSH.E` instructions store the set of registers from `xreg_list` to consecutive memory locations, and decrement the stack pointer.
The pseudo-code uses assembly inserts so that it can use `sw/sd` etc. The registers are always accessed in `x` register order.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//RV64/RV128 must have a 16-byte aligned sp
if (misa.MXL>=2 && sp[3:0]) {take_illegal_instruction_exception();}
//RV32I might be using the EABI (8-byte alignment) or UABI (16-byte alignment, so in hardware we can only check for 8)
if (misa.MXL==1 && sp[2:0]) {take_illegal_instruction_exception();}

if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp-bytes;
switch(bytes) {
  4:  asm("sw ra, 0(addr)");
  8:  asm("sd ra, 0(addr)");
  16: asm("sq ra, 0(addr)");
}
for(i=31;i>=0;i--)  {
  //if register i is in xreg_list
  if (xreg_list[i]) {
    addr-=bytes;
    switch(bytes) {
      4:  asm("sw s[i], 0(addr)");
      8:  asm("sd s[i], 0(addr)");
      16: asm("sq s[i], 0(addr)");
    }
  }
}
//The sequence must be uninterruptible from this point
sp+=stack_adjustment; //decrement
----

==== POP/POP.E/POPRET/POPRET.E/C.POP/C.POP.E/C.POPRET/C.POPRET.E Pseudo-code

A `POP/POP.E/POPRET/POPRET.E/C.POP/C.POP.E/C.POPRET/C.POPRET.E` instruction loads the set of registers from `reg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `lw/ld/ret` etc.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//RV64/RV128 must have a 16-byte aligned sp
if (misa.MXL>=2 && sp[3:0]) {take_illegal_instruction_exception();}
//RV32I might be using the EABI (8-byte alignment) or UABI (16-byte alignment, so in hardware we can only check for 8)
if (misa.MXL==1 && sp[2:0]) {take_illegal_instruction_exception();}

if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment-bytes;
switch(bytes) {
  4:  asm("lw ra, 0(addr)");
  8:  asm("ld ra, 0(addr)");
  16: asm("lq ra, 0(addr)");
}
for(i=31;i>=0;i--)  {
  //if register i is in xreg_list
  if (xreg_list[i]) {
    addr-=bytes;
    switch(bytes) {
      4:  asm("lw s[i], 0(addr)");
      8:  asm("ld s[i], 0(addr)");
      16: asm("lq s[i], 0(addr)");
    }
  }
}
if (opcode == "POPRET"   or 
    opcode == "POPRET.E" or 
    opcode == "C.POPRET" or 
    opcode == "C.POPRET.E") { 
  if (ret_val) {
     switch(ret_val) {
        "0":  asm("li a0, 0");
        "1":  asm("li a0, 1");
        "-1": asm("li a0, -1");
     }
  }
}
//The sequence must be uninterruptible from this point
sp+=stack_adjustment; //increment
if (opcode == "POPRET"   or 
    opcode == "POPRET.E" or 
    opcode == "C.POPRET" or 
    opcode == "C.POPRET.E") { 
   asm("ret");
}
----

[#pushpoppopret32bitencodings]
=== 32-bit Encodings

[NOTE]

  These encodings are in _custom-1_, correct encodings need to be allocated.

.push/pop/popret 32-bit format PPP-type
[options="header",width="100%"]
|================================================================================================
| 31:22 |21:20   |19:16  |15     | 14:12   | 11: 7      | 6 : 0 | type
|funct10|field4  |field3 |field2 | funct3  | field1     |opcode | ZCE-type
|================================================================================================

.push/pop/popret 32-bit encodings
[options="header",width="100%"]
|================================================================================================
| 31:22          |21|20    |19:16        |15 | 14:12   | 11: 7      | 6 : 0 | instruction
|0000000000     2+|00      |rlist (0-12) |0  | 100     | spimm[8:4] |0101011| PUSH
|0000000000     2+|00      |rlist (13-15)|0  | 100     | spimm[8:4] |0101011| PUSH.E
|0000000000     2+|00      |rlist (0-12) |0  | 101     | spimm[8:4] |0101011| POP
|0000000000     2+|00      |rlist (13-15)|0  | 101     | spimm[8:4] |0101011| POP.E
|0000000000     2+|ret_val |rlist (0-12) |0  | 110     | spimm[8:4] |0101011| POPRET
|0000000000     2+|ret_val |rlist (13-15)|0  | 110     | spimm[8:4] |0101011| POPRET.E
|================================================================================================
  
[NOTE]

  `rlist>12` gives register lists which only map to the EABI because the `X` register mapping is different for `s2-s4`, hence the `.E` suffix

[#32bit-ret_val]
.`ret_val` values for the 32-bit encodings for `POPRET, POPRET.E`
[options="header"]
|=========================================
|return value      |ABI names  
| 0      |none (don't set a0)        
| 1      |a0=0
| 2      |a0=1
| 3      |a0=-1
|=========================================

[#32bit-rlist]
.`rlist` field values for the 32-bit encodings
[options="header"]
|==========================
|rlist  | reg_list_32u/reg_list_e | ABI                
3+|`s0-s1` are the same for the UABI or EABI so the encoding is the same
| 0      |ra               | both           
| 1      |ra, s0           | both  
| 2      |ra, s0-s1        | both     
3+| These values are for `reg_list_32u` for the UABI only
| 3      |ra, s0-s2        | UABI     
| 4      |ra, s0-s3        | UABI      
| 5      |ra, s0-s4        | UABI      
| 6      |ra, s0-s5        | UABI      
| 7      |ra, s0-s6        | UABI      
| 8      |ra, s0-s7        | UABI      
| 9      |ra, s0-s8        | UABI      
| 10     |ra, s0-s9        | UABI      
| 11     |ra, s0-s10       | UABI       
| 12     |ra, s0-s11       | UABI       
3+| These values are for `reg_list_e` for the EABI only
| 13     |ra, s0-s2        | EABI     
| 14     |ra, s3, s0-s2    | EABI     
| 15     |ra, s3-s4, s0-s2 | EABI      
|==========================

[#proposed-32bit-encodingsI-2]
.PUSH/POP/POPRET 32-bit encoding validity on RV32I/RV32E/RV64I/RV128I
[width="100%",options=header]
|=========================================================================================================================
|instruction                       | RV32I | RV32E | RV64I/RV128I
|POP          {ra}                 | y | y | y
|POP          {[ra,] s0}           | y | y | y
|POP          {[ra,] s0-s1}        | y | y | y
|POP          {[ra,] s0-s2}        | y |   | y
|POP.E        {[ra,] s0-s2}        | y | y | 
|POPRET       {ra}                 | y | y | y 
|POPRET       {[ra,] s0}           | y | y | y
|POPRET       {[ra,] s0-s1}        | y | y | y
|POPRET       {[ra,] s0- _sN_}     | y |   | y
|POPRET.E     {[ra,] s0-s2}        | y | y | 
|POPRET.E     {[ra,] s3, s0-s2}    | y | y | 
|POPRET.E     {[ra,] s3-s4, s0-s2} | y | y | 
|PUSH         {ra}                 | y | y | y 
|PUSH         {[ra,] s0}           | y | y | y 
|PUSH         {[ra,] s0-s1}        | y | y | y 
|PUSH         {[ra,] s0- _sN_}     | y |   | y 
|PUSH.E       {[ra,] s0-s2}        | y | y |   
|PUSH.E       {[ra,] s3, s0-s2}    | y | y |  
|PUSH.E       {[ra,] s3-s4, s0-s2} | y | y |   
|=========================================================================================================================

[NOTE]

  _sN_ = (s2,s3,..,s11) 

[NOTE]

  If there is no y in a cell then the encoding is *reserved* on that architecture

All the `.E` instructions and pseudo-instructions are valid for `RV32I/RV32E`, none are valid for `RV64I/RV128I`

==== Illegal instructions

The following cases cause illegal instruction exceptions:

* If `sp` is not 8-byte aligned and `XLEN=32`
* If `sp` is not 16-byte aligned and `XLEN>32`

[NOTE]

  RV32I may use either the UABI or EABI, so we can only check the EABI minimum alignment.

[NOTE]

  The alignment check is for future compatibility with `PUSH.F,PUSH.D, PUSH.Q` where `XLEN!=FLEN`.

[#pushpoppopret16bitIencodings]
=== 16-bit Encodings

These instructions have no conflicts with other extensions, they use previously reserved encodings.

[#proposed-16bit-encodingsI-1]
.PUSH/POP/POPRET 16-bit encodings 
[width="100%",options=header]
|=========================================================================================================================
|15 |14 |13 |12 |11 |10  |9 |8    |7|6   |5   |4 |3 |2           |1 |0 |instruction   

3+|100    3+|011       3+|spimm0_5[6:4]  |0   |ret0 3+|rlist3       2+| 00  |C.POPRET
3+|100    3+|011       2+|11|spimm[4] |0   |0    3+|rlist3       2+| 00  |C.POP
3+|100    3+|011       2+|11|spimm[4] |0   |1    |0 2+|rlist2    2+| 00  |C.POP.E (RV32 only)

3+|100    3+|011       3+|spimm0_5[6:4]  |1   |0    3+|rlist3       2+| 00  |C.PUSH
3+|100    3+|011       3+|spimm0_5[6:4]  |1   |1    |ret0 2+|rlist2 2+| 00  |C.POPRET.E (RV32 only)
3+|100    3+|011       2+|11|spimm0_5[4] |1   2+|spimm0_5[6:5] 2+|rlist2 2+| 00  |C.PUSH.E (RV32 only)

|=========================================================================================================================

  * `spimm0_5[6:4]` has legal values of 0 to 5, which maps to stack adjustments of 0 to 80 as bits [6:4] are specified.

[#ret0-table]
.`ret0` values for `C.POPRET, C.POPRET.E`
[options="header",width=100%]
|=========================================
|return value      |ABI names  
| 0      |none (don't set a0)        
| 1      |a0=0
|=========================================


[#proposed-16bit-encodingsI-2]
.PUSH/POP/POPRET 16-bit encoding validity on RV32I/RV32E/RV64I/RV128I
[width="100%",options=header]
|=========================================================================================================================
|instruction                      | RV32I | RV32E | RV64I/RV128I
|C.POP        {ra}                | y | y | y
|C.POP        {ra, s0}            | y | y | y
|C.POP        {ra, s0-s1}         | y | y | y
|C.POP        {ra, s0-s2}         | y |   | y
|C.POP.E      {ra, s0-s2}         | y | y | 
|C.POPRET     {ra}                | y | y | y 
|C.POPRET     {ra, s0}            | y | y | y
|C.POPRET     {ra, s0-s1}         | y | y | y
|C.POPRET     {ra, s0- _sN_}      | y |    | y
|C.POPRET.E   {ra, s0-s2}         | y | y | 
|C.POPRET.E   {ra, s3, s0-s2}     | y | y | 
|C.POPRET.E   {ra, s3-s4, s0-s2}  | y | y | 
|C.PUSH       {ra}                | y | y | y 
|C.PUSH       {ra, s0}            | y | y | y 
|C.PUSH       {ra, s0-s1}         | y | y | y 
|C.PUSH       {ra, s0- _sN_}      | y |   | y 
|C.PUSH.E     {ra, s0-s2}         | y | y |   
|C.PUSH.E     {ra, s3, s0-s2}     | y | y |  
|C.PUSH.E     {ra, s3-s4, s0-s2}  | y | y |   
|=========================================================================================================================

[NOTE]

  _sN_ = (s2,s3,s5,s7,s11) 

[NOTE]

  If there is no y in a cell then the encoding is *reserved* on that architecture

All the `.E` instructions and pseudo-instructions are valid for `RV32I/RV32E`, none are valid for `RV64I/RV128I`

[#spimm]
==== `spimm` encoding field

The `stack_adjustment` field in the assembler syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

[source,sourceCode,text]
----
function Align16(i): return (i+15)&~0xf; // make it 16-byte aligned
total_register_bytes = number_of_registers_in_reg_list * XLEN/8;
stack_adjustment = Align16(total_register_bytes) + spimm;
----

the allowable range of `spimm` varies for different encodings.
[NOTE]

  `spimm` always represents 16-byte blocks even on RV32E where the stack is 8-byte aligned. This is for simplicity.

[NOTE]

  `spimm` is an _unsigned_ immediate, it is subtracted for all `PUSH` instructions and added for all `POP/POPRET` instructions.

[NOTE]

  if `spimm` is out of range for the compiler, `PUSH/POP/POPRET` can still be inferred, and the compiler can infer an additional stack adjustment instruction

In many cases the 16-bit encoding is sufficient. The 32-bit encoding offers a larger `spimm` range, but this can also be achieved with a separate `c.addi sp, sp, #offset` instruction giving the same overall code-size.

Additional benefits of the 32-bit encoding are:

* more accurate register lists improving performance and memory usage (so that superfluous `s` registers aren't saved/restored)
* better control over the return value (`POP/POPRET`) improving code-size.

[#total-stack-rv32]
==== Total stack adjustment ranges for RV32

These tables are provided as a handy reference, they are all calculated from the formulae in this specification. They should be in an appendix.

[NOTE]

  Cells which say `see PUSH/POP/POPRET` etc. are because the `.E` instruction is a pseudo-instruction. See <<uabiandeabisupport>>.

[#spimmrange_16]
.C.PUSH/C.POP/C.POPRET valid values of stack adjustment for RV32
[width="100%",options=header]
|==========================================================================================
| rlist       | C.PUSH      | C.PUSH.E    | C.POPRET  | C.POPRET.E   | C.POP       | C.POP.E
| {ra}        | -16 to -96  | see C.PUSH  | 16 to 96  | see C.POPRET | 16 to 32    | see C.POP
| {ra, s0}    | -16 to -96  | see C.PUSH  | 16 to 96  | see C.POPRET | 16 to 32    | see C.POP
| {ra, s0-s1} | -16 to -96  | see C.PUSH  | 16 to 96  | see C.POPRET | 16 to 32    | see C.POP
| {ra, s0-s2} | -16 to -96  | -16 to -96  | 16 to 96  | 16 to 96     | 16 to 32    | 16 to 32
| {ra, s0-s3}*| -32 to -112 | -32 to -112 | 32 to 112 | 32 to 112    | N/A         | 32 to 48
| {ra, s0-s4}*| N/A         | -32 to -112 | N/A       | 32 to 112    | N/A         | N/A
| {ra, s0-s5} | -32 to -112 | N/A         | 32 to 112 | N/A          | 32 to 48    | 32 to 48
| {ra, s0-s7} | -48 to -128 | N/A         | 48 to 128 | N/A          | 48 to 64    | 48 to 64
| {ra, s0-s11}| -64 to -144 | N/A         | 64 to 144 | N/A          | 64 to 80    | 64 to 80
|==========================================================================================

*the register list order varies for .E versions

[NOTE]

  The ranges in <<spimmrange_16>> and <<spimmrange_32_ra>> show the total stack adjustment range, starting from `spimm=0` up to the maximum value of `spimm` for each encoding.

For example:

`c.push {ra,s0-s2}` requires 16-bytes to cover the registers, and the range shown is `-16 to -96`. The range of `spimm0_5[6:4]=0 to 5` which maps to the values `0 to 80`. 
The stack adjustment is negative for `c.push` so the total possible stack adjustment is `-(16+(0*16) to -(16+(5*16)) = -16 to -80`.

[#spimmrange_32_ra]
.PUSH/POP/POPRET valid values of total stack adjustment for RV32
[width="100%",options=header]
|==========================================================================================
| rlist       |   PUSH      |   PUSH.E    | POP/POPRET|POP.E/POPRET.E 
| {ra}        | -16 to -512 | see PUSH    | 16 to 512 | see POP/POPRET 
| {ra, s0}    | -16 to -512 | see PUSH    | 16 to 512 | see POP/POPRET 
| {ra, s0-s1} | -16 to -512 | see PUSH    | 16 to 512 | see POP/POPRET 
| {ra, s0-s2} | -16 to -512 | -16 to -512 | 16 to 512 | 16 to 512  
| {ra, s0-s3}*| -32 to -528 | -32 to -528 | 32 to 528 | 32 to 528  
| {ra, s0-s4}*| -32 to -528 | -32 to -528 | 32 to 528 | 32 to 528  
| {ra, s0-s5} | -32 to -528 | N/A         | 32 to 528 | N/A        
| {ra, s0-s6} | -32 to -528 | N/A         | 32 to 528 | N/A        
| {ra, s0-s7} | -48 to -544 | N/A         | 48 to 544 | N/A        
| {ra, s0-s8} | -48 to -544 | N/A         | 48 to 544 | N/A        
| {ra, s0-s9} | -48 to -544 | N/A         | 48 to 544 | N/A        
| {ra, s0-s10}| -48 to -544 | N/A         | 48 to 544 | N/A        
| {ra, s0-s11}| -64 to -560 | N/A         | 64 to 560 | N/A        
|==========================================================================================

*the register list order varies for .E versions

[#total-stack-rv64]
==== Total stack adjustment ranges for RV64

These tables are provided as a handy reference, they are all calculated from the formulae in this specification.

[#spimmrange_16_rv64]
.C.PUSH/C.POP/C.POPRET valid values of stack adjustment for RV64
[width="100%",options=header]
|=====================================================
| rlist       | C.PUSH      | C.POPRET  | C.POP       
| {ra}        | -16 to -96  | 16 to 96  |  16 to 32     
| {ra, s0}    | -16 to -96  | 16 to 96  |  16 to 32     
| {ra, s0-s1} | -32 to -112 | 32 to 112 |  32 to 48    
| {ra, s0-s2} | -32 to -112 | 32 to 112 |  32 to 48    
| {ra, s0-s3} | -48 to -128 | 48 to 128 |  48 to 64   
| {ra, s0-s4} | N/A         | N/A       |  N/A        
| {ra, s0-s5} | -64 to -144 | 64 to 144 |  64 to 80   
| {ra, s0-s7} | -80 to -160 | 80 to 160 |  80 to 96   
| {ra, s0-s11}| -112 to -192|112 to 192 | 112 to 128  
|=====================================================

[#spimmrange_32_ra_rv64]
.PUSH/POP/POPRET valid values of total stack adjustment for RV64
[width="100%",options=header]
|=======================================
| rlist       |   PUSH      | POP/POPRET
| {ra}        | -16 to -512 | 16 to 512 
| {ra, s0}    | -16 to -512 | 16 to 512 
| {ra, s0-s1} | -32 to -528 | 32 to 528 
| {ra, s0-s2} | -32 to -528 | 32 to 528 
| {ra, s0-s3} | -48 to -544 | 48 to 544 
| {ra, s0-s4} | -48 to -544 | 48 to 544 
| {ra, s0-s5} | -64 to -560 | 64 to 560 
| {ra, s0-s6} | -64 to -560 | 64 to 560 
| {ra, s0-s7} | -80 to -576 | 80 to 576 
| {ra, s0-s8} | -80 to -576 | 80 to 576 
| {ra, s0-s9} | -96 to -592 | 96 to 592 
| {ra, s0-s10}| -96 to -592 | 96 to 592 
| {ra, s0-s11}|-112 to -608 |112 to 608 
|=======================================

[#fault-handling]
=== Fault handling

The sequence required to execute the instruction may be interrupted, or may not be able to start execution for several reasons.

* virtual memory page fault or PMP fault
** these can be detected before execution, or during execution if the memory addresses cross a page/PMP boundary
** `MTVAL` is set to any address which causes the fault
* watchpoint trigger
** these can be detected before execution, or during execution depending on the trigger type (load data triggers require the sequence to have started executing, for example)
** `MTVAL` is set to any address which causes the fault
* external debug halt
** the halt can treat the whole sequence atomically, or interrupt mid sequence (implementation defined)
* debug halt caused by a trigger
** same comment as watchpoint trigger above
* load access fault
** these are detected while the sequence is executing
** `MTVAL` is set to the fault address.
* store access fault (precise or imprecise)
** these may be detected while the sequence is executing, or afterwards if imprecise
** `MTVAL` is set to the fault address.
* interrupts
** these may arrive at any time. An implementation can choose whether to interrupt the sequence or not.

In all case `MEPC` contain the `PC` of the `PUSH/POP` instruction, and `MCAUSE` is set as expected for the type of fault.

For debug halts `DPC` is set to the `PC` of the `PUSH/POP` instruction.

Because some faults can only be detected during the sequence the core implementation is able to recover from the fault and re-execute the sequence. This may involve executing some or all of the loads and stores from the sequence multiple times before the sequence completes (as multiple faults or multiple interrupts are possible).

Therefore correct execution requires that `sp` refers to idempotent memory (see <<non-idem-mem>> for non-idempotent handling)

[#software-view]
=== Software view of execution

==== Software view of `PUSH` sequence

From a software perspective the `PUSH` sequence appears as:

* A sequence of stores writing a contiguous block of memory. Any of the bytes may be written multiple times.
* A stack pointer adjustment

Because the memory is idempotent and the stores are non-overlapping, they may be reordered, grouped into larger accesses, split into smaller access or any combination of these.

If an implementation allows interrupts during the sequence, and the interrupt handler uses `sp` to allocate stack memory, then any stores which were executed before the interrupt maybe be overwritten by the handler. This is safe because the memory is idempotent and the stores will be re-executed once the handler completes.

The stack pointer adjustment must only be committed once it is certain that all of the stores will complete within triggerring any precise faults (stores may return imprecise bus errors which are received after the instruction has completed execution).

For example:

[source,sourceCode,text]
----
c.push  {ra, s0-s5},{a0-a3}, -64
----

Appears to software as:

[source,sourceCode,text]
----
# any bytes from SP-1 to SP-28 may be written multiple times before the instruction completes
sw  s5, -4(sp);   
sw  s4, -8(sp);   
sw  s3,-12(sp);   
sw  s2,-16(sp);  
sw  s1,-20(sp);   
sw  s0,-24(sp);   
sw  ra,-28(sp);   

# these must only execute once, and will only execute after all stores complete sucessfully
mv s0, a0;
mv s1, a1;
mv s2, a2;
mv s3, a3;
addi sp, sp, -64; 
----

==== Software view of `POP/POPRET` sequence

From a software perspective the `POP/POPRET` sequence appears as:

* A sequence of loads, any of which may be executed multiple times
* A stack pointer adjustment
* An optional `RET`

If an implementation allows interrupts during the sequence, then any loads which were executed before the interrupt may update architectural state. The loads will be re-executed once the handler completes, so the values will be overwritten. Therefore it is permitted for an implementation to update some of the destination registers before taking the interrupt or other fault.

The register moves and stack pointer adjustment must only be committed once it is certain that all of the loads will complete successfully.

For `POPRET` once the stack pointer adjustment has been committed the `RET` must execute.

For example:

[source,sourceCode,text]
----
popret   {ra, s0-s3}, {1}, 32 ; 
----

Appears to software as:

[source,sourceCode,text]
----
# any or all of these load instructions may execute multiple times
lw   s3, 28(sp);
lw   s2, 24(sp);
lw   s1, 20(sp);
lw   s0, 16(sp);
lw   ra, 12(sp);

# must only execute once, will only execute after all loads complete successfully
# all instructions must execute atomically
li a0, 1
addi sp, sp, 32;
ret;
----
[[non-idem-mem]]
==== Non-idempotent memory

An implementation may have a requirement to issue `PUSH/POP/POPRET` to non-idempotent memory. 

==== Error detection

If the core implementation does not have a requirement to support `PUSH/POP/POPRET` to non-idempotent memories, and the core can use a PMA to detect that the memory is non-idempotent, then take a load(`POP/POPRET`) or store (`PUSH`) access fault exception.

==== Non-idempotent support

It is possible to support non-idempotent memory. One reason is to re-use `PUSH/POP` as a restricted form of a load/store multiple instruction to a peripheral (see <<ldstm>>), as there is no generic load/store multiple instruction currently in the RISC-V ISA. If load/store multiple is supported in the future then it should support non-idempotent memory.

If accessing non-idempotent memory then it is _recommended_ to:

. Not allow interrupts during execution
. Not allow external debug halt during execution
. Detect any virtual memory page faults or PMP faults for the whole instruction before starting execution (instead of during the sequence)
. Not split / merge / reorder the generated memory accesses

It is possible that one of the following will still occur during execution:

. Watchpoint trigger
. Load/store access fault

In these cases the core will jump to the debug or exception handler. If execution is required to continue afterwards (so the event is not fatal to the code execution), then the handler is required to do so in software. 

By following these rules memory accesses will only ever be issued once, and in the order listed in the pseudo-code.

It is possible for implementations to follow these restricted rules and to safely access both types of memory. It is also possible for an implementation to use PMAs to detect the memory type and apply different rules, such as only allowing interrupts if accessing cacheable memory, for example.

=== Toolchain implementation

`PUSH/POP/POPRET` can be generated by the compiler, but can also be added as an optimisation in the linker. If they are inferred at link time then they can also be used to optimise precompiled library code. This means that the libraries can be shipped without these instructions, but platforms which implement them can still benefit from the code-size saving.

[NOTE]

  The linker may have to reallocate registers as the register moves included in `PUSH/C.PUSH` target specific `s` registers which may not agree with the compiler output, example.

==== Compiling for size or performance

There are cases where it is not clear whether to use the 16-bit or 32-bit encoding.

If compiling with -Os/-Oz the compiler should generate the smallest possible code output, which may include performance reduction due to:

1. too many `s` registers in the register list
.. for example `push {ra, s0-s6}` is required but not available in the 16-bit encoding so `c.push {ra,s0-s7}` must be used instead for the smallest code-size
2. too many included register moves (for `C.PUSH` only)
.. for example `push {ra,s0-s1}, {a0}` is required, but the 16-bit encoding will include an extra register move `c.push {ra,s0-s1}, {a0-a1}`

Another consideration is whether the total stack adjustment can be encoded by the 16-bit version, the 32-bit encoding gives a larger range but still will not cover all cases.

The default choice is always to use the 16-bit encoding. The rules below are for when to choose the 32-bit encoding instead.

For `C.PUSH/PUSH`, use `PUSH` if:

1. The total stack adjustment (see <<#total-stack-rv32>>, <<total-stack-rv64>>) is out of range for `C.PUSH`, but in range for `PUSH`.
2. `C.PUSH` includes too many `s` registers and not compiling with -Os/-Oz.
3. `C.PUSH` includes too many register moves and not compiling with -Os/-Oz.

For `C.POPRET/POPRET`, use `POPRET` if:

1. The total stack adjustment (see <<#total-stack-rv32>>, <<total-stack-rv64>>) is out of range for `C.POPRET`, but in range for `POPRET`.
2. `C.POPRET` includes too many `s` registers and not compiling with -Os/-Oz.
3. The return value is `1` or `-1`, (`C.POPRET` only allows the option of returning `0`).

For `C.POP/POP`, use `POP` if

1. The total stack adjustment (see <<#total-stack-rv32>>, <<total-stack-rv64>>) is out of range for `C.POP`, but in range for `POP`.

_Example 1_ The 16-bit encoding includes too many register moves.

[source,sourceCode,text]
----
#From debian / re compiled with GCC (RV64), reordered to put the registers in order
    53be:       7135                    addi    sp,sp,-160
    53c6:       ed06                    sd      ra,152(sp)
    53c8:       e922                    sd      s0,144(sp)
...s1-s10...
    53d8:       fc6e                    sd      s11,56(sp)
    53da:       84aa                    mv      s1,a0
    53e0:       892e                    mv      s2,a1
#-Os/-Oz: compile to C.PUSH, but includes redundant register moves of a2, a3 
#note that the moves are "mv s0, a0; mv a1, s1; mv a2, s2; mv a3, s3"  so the s registers need to be reallocated
    53be:       <16-bit>                c.push  {ra,s0-s11}, {a0-a3}, -160
#-O1/-O2/-O3: compile to PUSH to avoid the redundant register moves of a2, a3 even though the code is larger
    53be:       <32-bit>                push    {ra,s0-s11}, -160
    53da:       84aa                    mv      s1,a0
    53e0:       892e                    mv      s2,a1
----

_Example 2_ The stack adjustment is out of range for the 32-bit encoding, and the register list matches the 16-bit encoding.

[source,sourceCode,text]
----
#From Huawei IoT code compiled with GCC (RV32)
  e0c744:       2bc12083                lw      ra,700(sp)
  e0c748:       2b812403                lw      s0,696(sp)
...s1-s7...
  e0c768:       29812c03                lw      s7,668(sp)
  e0c76c:       2c010113                addi    sp,sp,704 #out of range, limit is 544 for 32-bit encoding
  e0c770:       8082                    ret
#-Os/-Oz/-O1/-O2/-O3: always compile to 2 16-bit encodings, the 32-bit encoding doesn't improve performance
  e0c744:       <16-bit>                c.addi16sp sp,sp,640
  e0c748:       <16-bit>                c.popret   {ra,s0-s7}, 64
----

_Example 3_ The register list doesn't match the 16-bit encoding, and the 32-bit encoding allows inclusion of the return value.

In this case the 16-bit encoding is inferior in the epilogue - because it includes `s7` and cannot include the `mv, a0, s0`. Therefore the 32-bit encoding uses the correct register list and has the same code size.

[source,sourceCode,text]
----
#From Huawei IoT code compiled with GCC (RV32), reordered to put the registers in order
#prologue
  e0073e:       7179                    addi    sp,sp,-48
  e0074c:       d606                    sw      ra,44(sp)
  e00740:       d422                    sw      s0,40(sp)
...s1-s6...
  e0074a:       c65e                    sw      s6,16(sp)
  e00752:       892a                    mv      s2,a0
...a1-a3...
  e0075a:       8a3a                    mv      s4,a4
....
#epilogue
  e0079a:       8522                    mv      a0,s0
  e0079c:       5422                    lw      s0,40(sp)
...s1-s6...
  e007aa:       4bb2                    lw      s6,16(sp)
  e007ac:       6145                    addi    sp,sp,48
  e007ae:       8082                    ret

#optimised prologue
#-Os/-Oz: the smallest is with the 16-bit encoding which also stores s7 (so wastes performance)
  e0073e:       <16-bit>                push {ra,s0-s7}, {a0-a2}
  e0075a:       8a3a                    mv      s4,a4

#-O1/-O2/-O3: the 32-bit encoding is larger but doesn't store s7 (so doesn't waste performance)
  e0073e:       <32-bit>                push {ra,s0-s6}, {a0-a2}
  e0075a:       8a3a                    mv      s4,a4

#optimised epilogue
#-Os/-Oz the smallest is with the 16-bit encoding which also stores s7 (so wastes performance)
  e0079c:       <16-bit>                popret {ra,s0-s7}, 48

#-O1/-O2/-O3: the 32-bit encoding is larger but doesn't store s7 (so doesn't waste performance)
  e0079c:       <32-bit>                popret {ra,s0-s6}, 48
----

=== Assembly examples

[#push-example-1]
==== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rlist=5, spimm=32

Equivalent sequence:

[source,sourceCode,text]
----
sw  s5, -4(sp);
sw  s4, -8(sp); 
sw  s3, -12(sp);
sw  s2, -16(sp); 
sw  s1, -20(sp);
sw  s0, -24(sp); 
sw  ra, -28(sp);
addi sp, sp, -64;
----

==== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rlist=2, spimm=16

Equivalent sequence:

[source,sourceCode,text]
----
sw  s1, -4(sp);
sw  s0, -8(sp); 
sw  ra, -12(sp);
addi sp, sp, -32;
----

==== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7}, 160
----

Encoding: rlist=6, spimm=112 

Equivalent sequence:

[source,sourceCode,text]
----
lw   s7, 156(sp);
lw   s6, 152(sp);  
lw   s5, 148(sp);  
lw   s4, 144(sp);  
lw   s3, 140(sp);  
lw   s2, 136(sp);  
lw   s1, 132(sp);  
lw   s0, 128(sp);  
lw   ra, 124(sp);  
addi sp, sp, 160
----

[#popret-example-1]
==== C.POPRET RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.popret   {ra, s0-s7}, {0}, 160
----

Encoding: rlist=6, spimm=112 

Equivalent sequence:

[source,sourceCode,text]
----
lw   s7, 156(sp);
lw   s6, 152(sp);  
lw   s5, 148(sp);  
lw   s4, 144(sp);  
lw   s3, 140(sp);  
lw   s2, 136(sp);  
lw   s1, 132(sp);  
lw   s0, 128(sp);  
lw   ra, 124(sp);  
li   a0, 0;
addi sp, sp, 160;
ret
----

==== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {ra, s0-s9}, {1}, 256
----

Encoding: ra=1, rlist=10, frlist=0, spimm=128 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   s9, 252(sp);
lw   s8, 248(sp);
lw   s7, 244(sp);  
lw   s6, 240(sp)
lw   s5, 236(sp);  
lw   s4, 232(sp);
lw   s3, 228(sp);  
lw   s2, 224(sp)
lw   s1, 220(sp);  
lw   s0, 216(sp);
lw   ra, 212(sp); 
li   a0, 1
addi sp, sp, 256
----

[[ldstm]]
=== Appendix: Usage as load/store-multiple

`PUSH/POP` encodings can be reused as generic load/store multiple instructions. For example:

[source,sourceCode,text]
----

lui t0, 0xffff
sw  s5, 0x4c(t0)
sw  s4, 0x50(t0)
sw  s3, 0x54(t0)
sw  s2, 0x58(t0)
sw  s1, 0x5c(t0)
sw  s0, 0x60(t0)

----

Can be replaced by

[source,sourceCode,text]
----

lui t0, 0xffff
addi sp, t0, 64
push {s0-s5}, -64

----

This requires that `sp` is saved before and restored after the sequence.  It may also require that interrupts are disbled if the interrupt handler allocates space using `sp`, as the `sp` will not point to the stack during the sequence.

Also `POP` can be used to replace the equivalent series of loads. 

Even though there is not much code-size saving once the `sp` save/restore code has been included, and the restricted memory layout targetted by the instructions, there may be a performance benefit to doing this for small embedded cores. A load/store-multiple sequence may be issued to the peripheral bus as a single burst instead of multiple single accesses which individually require arbitration. In some cases this can save one or more cycles per access as the arbiter remains locked to the core until the sequence has completed.

If the target memory is non-idempotent then see <<non-idem-mem>> for additional constraints.

[[benchmarkingpushpop]]
=== Appendix: Benchmarking PUSH/POP against -msave-restore

`PUSH/POP` are benchmarked relative to `-msave-restore`, which is available in GCC and more recently also available in LLVM 13. To give more realistic benchmarking results, the save routines have embedded moves added (see below), and are otherwise unchanged from GCC10.

[source,sourceCode,text]
----

<__riscv_save_12>:
  addi	sp,sp,-64
  li	t1,0
  sw	s11,12(sp)
  j <__riscv_save_10_j>

<__riscv_save_10>:
  addi	sp,sp,-64
  li	t1,-16
<__riscv_save_10_j>:
  sw	s10,16(sp)
  sw	s9,20(sp)
  sw	s8,24(sp)
  sw	s7,28(sp)
  j <__riscv_save_4_j>

<__riscv_save_4>:
  addi	sp,sp,-64
  li	t1,-32
<__riscv_save_4_j>:
  sw	s6,32(sp)
  sw	s5,36(sp)
  sw	s4,40(sp)
  sw	s3,44(sp)
  sw	s2,48(sp)
  sw	s1,52(sp)
  sw	s0,56(sp)
  sw	ra,60(sp)
  mv  s3, a3           ;# embedded move
  mv  s2, a2           ;# embedded move
  mv  s1, a1           ;# embedded move
  mv  s0, a0           ;# embedded move
  sub	sp,sp,t1
  jr	t0

<__riscv_save_0>:
  addi	sp,sp,-16
  sw	s2,0(sp)
  sw	s1,4(sp)
  sw	s0,8(sp)
  sw	ra,12(sp)
  mv  s2, a2           ;# embedded move
  mv  s1, a1           ;# embedded move
  mv  s0, a0           ;# embedded move
  jr	t0

----

The restore routines are unchanged, and always include `ret` at the end. This means that tail call optimisation is disabled when using `msave-restore`, which can have a large performance impact (which is solved by using `C.POP`). Realistically, a second set of routines without `RET` are needed to allow tail call optimisation.

[source,sourceCode,text]
----
<__riscv_restore_12>:
  lw	s11,12(sp)
  addi	sp,sp,16

<__riscv_restore_10>:
  lw	s10,0(sp)
  lw	s9,4(sp)
  lw	s8,8(sp)
  lw	s7,12(sp)
  addi	sp,sp,16

<__riscv_restore_4>:
  lw	s6,0(sp)
  lw	s5,4(sp)
  lw	s4,8(sp)
  lw	s3,12(sp)
  addi	sp,sp,16

<__riscv_restore_0>:
  lw	s2,0(sp)
  lw	s1,4(sp)
  lw	s0,8(sp)
  lw	ra,12(sp)
  addi	sp,sp,16
  ret
----

The cost of each call to the save/restore routines varies. If `C.TBLJALM/C.TBLJ` are used then it is _always_ 16-bits. If not, then the call to save will be 32 or 64-bit (`C.JAL` can't link to `t0`). The call to the restore routine can be 16-bit (`C.J`), 32-bit (`J`) or 64-bit (`AUIPC; JR`).

Clearly the code-size will be considerably smaller if all calls use `C.TBLJALM/CLTBLJ`.

==== Benchmarking configuration 1

Configuration 1 uses the save/restore code above, and does not use `C.TBLJALM/C.TBLJ`.
It will *not* call a save/restore routine if only `ra` is saved/restored.

==== Benchmarking configuration 2

Configuration 2 uses the save/restore code above, and uses `C.TBLJALM/C.TBLJ`, so every call is 16-bits.
It will *not* call a save/restore routine if only `ra` is saved/restored.

==== Performance analysis

Performance is expected to be significantly higher using PUSH/POP than the software routines. Unnecessary jumps are eliminated, and redundant loads/stores are minimised. Additionally `C.POP` allows tail call optimisation to be enabled.

[NOTE]

  We should do some performance analysis to show the benefit vs `-msave-restore`. Details TBD.

== Compiler switches

If `Zcea/Zceb/Zcee` are specified, then the compiler will include all the instructions from the relevant subsets.
It is also useful to be able to select instructions in a more fine-grained way to help with benchmarking and analysis work, especially when analysing the results of the prototype compiler.
Therefore the compiler switches in <<compilerswitches>> are available, each one is used to enable a specific list of instructions.
Some of the switches are needed for the linker (e.g. `LWGP` and `TBLJ*`).

[#compilerswitches]
.Compiler switches for Zce
[options="header",width=100%]
|==============================================================================
| Switch             | Enabled instructions
| -mzce-push-pop     | C.PUSH, C.POP, C.POPRET, PUSH, POP, POPRET
| -mzce-pushe-pope   | C.PUSH.E, C.POP.E, C.POPRET.E, PUSH.E, POP.E, POPRET.E
| -mzce-tbljal       | C.TBLJ, C.TBLJAL, C.TBLJALM
| -mzce-clbhu        | C.LBU, C.LHU
| -mzce-clbh         | C.LB, C.LH
| -mzce-csbh         | C.SB, C.SH
| -mzce-lsgp         | LWGP, SWGP, LDGP (RV64), SDGP (RV64)
| -mzce-muli         | MULI
| -mzce-cmul         | C.MUL
| -mzce-sext         | C.SEXT.B, C.SEXT.H, (C.SEXT.W RV64 pseudo-instruction)
| -mzce-zext         | C.ZEXT.B, C.ZEXT.H, C.ZEXT.W (RV64)
| -mzce-beqi         | BEQI
| -mzce-bnei         | BNEI
| -mzce-cnot         | C.NOT
| -mzce-cneg         | C.NEG
| -mzce-cmva01s07    | C.MVA01S07
| -mzce-cmvs07a01    | C.MVS07A01
| -mzce-cdecbnez     | C.DECBNEZ
| -mzce-decbnez      | DECBNEZ
|==============================================================================


== Verification notes

=== Existing functionality

Many of the instructions are 16-bit encodings of existing 32-bit instructions, therefore the verification should be a simple extension to existing tests and coverage. Additionally, the instructions are all very simple.
. C.SEXT.B, C.SEXT.H, (C.SEXT.W is a pseudo-instruction)
. C.ZEXT.B, C.ZEXT.H, C.ZEXT.W
. C.MUL, C.NOT, C.NEG
. C.LBU, C.LHU, C.LB, C.LH, C.SB, C.SH

=== Simple extensions to existing functionality

These instructions are extremely similar to existing instructions, so the verification tests and coverage should be a simple extension from existing tests and coverage:

. BEQI, BNEI
.. these are immediate forms of BEQ and BNE, they compare a register value against an immediate instead of two register values
. LWGP
.. this have the same functionality as LW, but the base register is explicitly GP and the immediate offset range is larger
. SWGP
.. this have the same functionality as SW, but the base register is explicitly GP and the immediate offset range is larger
. MULI
.. same as MUL with a signed immediate operand

=== New branch functionality

`DECBNEZ` and `C.DECBNEZ` are also fused versions of two instructions:

[source,sourceCode,text]
----
decbnez  s2, 1, -48
----

is equivalent to:

[source,sourceCode,text]
----
addi s2, s2, -1
bnez s2, -48
----

Therefore the coverage is the same as for `ADDI/BGEZ` combined, noting the limited range of subtraction values (1,2,4,8) and the range of the branch offset (especially for `C.DECBNEZ`).

=== Sequenced functionality

`PUSH/POP/POPRET` execute a sequence of micro-ops to execute the whole instruction. As a result they are considerably more complex to verify than the other instructions.

==== Cover all possible sets of operands

`mv, rlist, ra, spimm` are all fields in the encoding.

[#32pushpopsourcecoverage]
.Coverage for PUSH/POP/POPRET source operands
[options="header",width=100%]
|==============================================================================
|Instruction|Variables                                        | Coverage bins
| PUSH          | `rlist`(0 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 416
| POP           | `rlist`(0 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 416
| POPRET        | `rlist`(0 to 12) x `ret_val` (0 to 3) x `spimm` (0 to 15) | 834
|==============================================================================

The 16-bit encodings have ffar ewer coverage bins:

[#16pushpopsourcecoverage]
.Coverage for C.PUSH/C.POP/C.POPRET source operands
[options="header",width=100%]
|==============================================================================
|Instruction|Variables                                        | Coverage bins
| C.PUSH      | `rlist`(0 to 7) x `spimm` (0 to 7) | 64
| C.POP       | `rlist`(0 to 3) x `spimm` (0 to 1) | 8
| C.POPRET    | `rlist`(0 to 7) x `ret_val` (0 to 1) x `spimm` (0 to 7) | 128
|==============================================================================

==== Test the functionality

Execution of every PUSH/POP/POPRET instruction must result in the same architectural state updates as executing the sequence that it expands into. For example:

[source,sourceCode,text]
----
popret   {ra, s0-s3}, {1}, 32; 
----

causes identical architectural state updates to the expanded sequence:

[source,sourceCode,text]
----
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);
lw   s2, 16(sp);
lw   s3, 12(sp);
li   a0, 1
addi sp, sp, 32;
ret
----

Therefore a suggestion is to generate pairs of tests, one with the expanded sequences and one with `PUSH/POP/POPRET`. Each test must give identical results, including having the same contents in the memory.

It is also possible to introduce

. interrupts
. debug triggers on the loads/stores in the sequence
. external debug halts
. load/store access faults due to bus errors or PMP faults
. load/store page faults

on the loads and stores in the sequence. `mepc` will be different between the two tests but `mcause` and `mtval` must match. Note that interrupts and external debug halts are asynchronous events, so to make the results from the two tests match then the handler must not (for example) count the number of interrupts taken.

Implementations may choose for the sequences to be uninterruptible, or to be interruptible and to restart after the `mret`. The overall result is the same - the sequence will eventually complete and correctly update the architectural state, providing any debug triggers are disabled in the handler before resuming execution (so they don't trigger again)

==== Table jump, jump table mode only

Table jump is quite simple architecturally. 

`c.tblj* n;` references memory address `m = InstMemory[TBLJALVEC + n * XLEN/8]`

The core jumps to address `m`, and links to the relevant link register.

For verification we must show that the different link registers work and that the core jumps to the correct location each time.

==== Table jump and overlays

The overlap task group has a proposal which can fit nicely with a table jump implementation. https://github.com/riscv/riscv-overlay/blob/master/docs/overlay-hld.adoc[Click here for the proposal].
They use `t6` as the semi-fixed address for the overlap table engine. This could be replaced by a `c.tbljal` to the overlay engine. 
If the address of the engine needs to be changed then it can be changed in the jump table, so allowing table jump to call the engine removes teh need to allocate `t6`.

A future version of this spec may not allocate CSRs (as CSRs are a finite resource), and use a temporary register for the jump table base address. If this is the case then using `t6` would fit nicely with overlap proposal, 
but the concern is that precompiled libraries which use `t6` will no longer work, and additionally the EABI only has two temporary registers so allocating one of them for the jump table base is unlikely to be acceptable.

== Rejected and postponed instructions

=== Not benchmarked: PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]

Please read <<pushpoppopret>> before reading this section.

These instructions are variants of `PUSH/POP/POPRET` which also allow `F` registers to be saved/restored.

==== Assembler Syntax

These instructions require a register list including `fs` registers.

[source,sourceCode,text]
----
<fsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range> | <sreg_range> "," <freg_range> | <freg_range>
<rfsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range>
<freg_range> ::= <fs0> | <fs0-fsM> (valid values of M are 1,2,3,5,8,11)

//legal syntax

push.[fdq]   {<fsreg_list>},     -stack_adjustment
pop.[fdq]    {<fsreg_list>},      stack_adjustment
popret.[fdq] {<rfsreg_list>},     stack_adjustment //popret must include ra

----

To be a legal encoding:

1.  The total stack adjustment must be negative for `PUSH.[FDQ]` and positive for `POP.[FDQ]/POPRET.[FDQ]`
2.  The total stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register lists must be valid (see above)
4.  For `POPRET.[FDQ]`, `rfsreg_list` must include `ra`

Additionally:

. If `sp` is not 16-byte aligned then take a load (`PUSH.[FDQ]`) or store (`POP.[FDQ]/POPRET.[FDQ]`) address misaligned exception, and do not issue any loads or stores.

[NOTE]
  When moving from loading or storing `x` registers to `f` registers there may be a gap as the registers may be different widths, and all registers must be aligned in memory

===== Rationale: why include the .[fdq] suffix

It is required to hard-code the length of the `f` registers in the opcode, and not just save/restore the whole register. We must allow code compiled for the F-extension
to run on a  core which supports D and possibly Q. We must also allow code compiled for the D-extension to run on a core which supports Q.

If we don't explicitly state the `f` register width and always store the whole register, then the registers will be stored at different addresses to the ones expected 
by the compiler. 

An alternative would be to use `misa.[FDQ]`
to directly control the behaviour and so set `misa.[DQ]=0` when running F code. Nothing else in the architecture requires this, so it seems unreasonable to 
add this requirement here. This approach also wouldn't work for `Z[FDQ]inx` cores as `misa.[FDQ]` are all hardwired to zero.

==== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

===== PUSH.[FDQ] Pseudo-code

The `PUSH.FDQ` instruction stores the set of registers from `fsreg_list` to consecutive memory locations, and decrements the stack pointer.
The pseudo-code uses assembly inserts so that it can use `fsw/fsd` etc.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])           {take_illegal_instruction_exception();}
if (rlist>12)          {take_illegal_instruction_exception();}
if (rlist>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw ra, 0(addr)");
    8:  asm("sd ra, 0(addr)");
    16: asm("sq ra, 0(addr)");
  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw s[i], 0(addr)");
    8:  asm("sd s[i], 0(addr)");
    16: asm("sq s[i], 0(addr)");
  }
}
switch (opcode) {
  //if FLEN > XLEN, then get the address back into alignment before saving the F registers
  "PUSH.D": while(addr% 8) {addr-=bytes;}
  "PUSH.Q": while(addr%16) {addr-=bytes;}
}
for(i in freg_list)  {
  switch (opcode) {
    "PUSH.F": {addr-= 4;asm("fsw fs[i], 0(addr)");}
    "PUSH.D": {addr-= 8;asm("fsd fs[i], 0(addr)");}
    "PUSH.Q": {addr-=16;asm("fsq fs[i], 0(addr)");}
  }
}
sp+=stack_adjustment; //decrement
----

===== POP.[FDQ]/POPRET/[FDQ] Pseudo-code

A `POP/POPRET` instruction loads the set of registers from `fsreg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `flw/fld/ret`.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])           {take_illegal_instruction_exception();}
if (rlist>12)          {take_illegal_instruction_exception();}
if (rlist>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw ra, 0(addr)");
    8:  asm("ld ra, 0(addr)");
    16: asm("lq ra, 0(addr)");

  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw s[i], 0(addr)");
    8:  asm("ld s[i], 0(addr)");
    16: asm("lq s[i], 0(addr)");
  }
}
switch (opcode) {
  //if FLEN > XLEN, then get the address back into alignment before saving the F registers
  "POP.D", "POPRET.D": while(addr% 8) {addr-=bytes;}
  "POP.Q", "POPRET.Q": while(addr%16) {addr-=bytes;}
}
for(i in freg_list)  {
  switch (opcode) {
    "POP.F", "POPRET.F": {addr-= 4;asm("flw fs[i], 0(addr)");}
    "POP.D", "POPRET.D": {addr-= 8;asm("fld fs[i], 0(addr)");}
    "POP.Q", "POPRET.Q": {addr-=16;asm("flq fs[i], 0(addr)");}
  }
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET") { 
   asm("ret");
}
----

[#pushfdqpoppopret32bitencodings]
==== 32-bit Encodings

[NOTE]

  These encodings are provisional.


.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31:27              |26|25     |24 |23|22|21:20         |19:18|17:16|15 | 14:12   | 11:10 |9: 7      | 6 : 0 | instruction
15+|`PUSH.[FDQ]` encodings
2+|0000000         2+|00         2+|01   |frlist     2+|rlist     |ra | 001   2+| spimm[8:4]        |1000011| PUSH.F
2+|0000000         2+|00         2+|10   |frlist     2+|rlist     |ra | 001   2+| spimm[8:4]        |1000011| PUSH.D
2+|0000000         2+|00         2+|11   |frlist     2+|rlist     |ra | 001   2+| spimm[8:4]        |1000011| PUSH.Q
15+|`POP.[FDQ]` encodings
2+|0000000         2+|01         2+|01   |frlist     2+|rlist     |ra | 010   2+| spimm[8:4]        |1000011| POP.F
2+|0000000         2+|01         2+|10   |frlist     2+|rlist     |ra | 010   2+| spimm[8:4]        |1000011| POP.D
2+|0000000         2+|01         2+|11   |frlist     2+|rlist     |ra | 010   2+| spimm[8:4]        |1000011| POP.Q
15+|`POPRET.[FDQ]` encodings
2+|0000000         2+|10         2+|01   |frlist     2+|rlist     |1  | 011   2+| spimm[8:4]        |1000011| POPRET.F
2+|0000000         2+|10         2+|10   |frlist     2+|rlist     |1  | 011   2+| spimm[8:4]        |1000011| POPRET.D
2+|0000000         2+|10         2+|11   |frlist     2+|rlist     |1  | 011   2+| spimm[8:4]        |1000011| POPRET.Q
|=========================================================================================================================

[NOTE]
  bits [23:22] are the `fdq` field
  
[NOTE]
  `ra=1` for all `popret` encodings, it is not specified in the encoding


===== Illegal instructions 

The encoding takes the same behaviour as any floating point instruction if executed when disabled:

* if `frlist>0` and `misa.F==0`
* if `frlist>0` and `fdq==1` and `misa.D==0`
* if `frlist>0` and `fdq==2` and `misa.Q==0`

The following cases do not decode as `PUSH*/POP*/POPRET*`

* No registers are specified (`rlist, frlist` are both zero)
* `rlist>14`
* `fdq=3`
* `rlist==13` and `frlist>0` and the opcode doesn't have an `[fdq]` suffix

===== Rational: `rlist=13, frlist=0` saving all saved registers

The debian distro does save all `s` and `fs` registers on a few occasions, so there is a special encoding for this case. I saw no justification for saving all `fs` registers *without* saving all `s` registers. It seems useful to have a form which saves all saved registers.

The programmable range for `frlist` doesn't save many `fs` registers as `FPMark` only saves one or two and Debian rarely saves more than that.

==== Encoding Fields

See <<spimm>>.

[source,sourceCode,text]
----
//the padding calculation requires SP to be 16-byte aligned before executing the instruction
if (FLEN>XLEN && 
    number_of_registers_in_freg_list>0 && 
    number_of_registers_in_reg_list % (FLEN/XLEN)>0) {
  //need padding to ensure FLEN registers are aligned
  padding = (FLEN/XLEN - number_of_registers_in_reg_list % (FLEN/XLEN)) * XLEN/8;
} else {
  padding = 0
}
total_register_bytes = number_of_registers_in_reg_list * XLEN/8 + padding + number_of_registers_in_freg_list * FLEN/8;
stack_adjustment = Align16(total_register_bytes) + spimm;
----

The bytes required for padding is simple - if FLEN==XLEN it's always zero. If FLEN=2*XLEN it is 0 or 4. RV32Q is more complex (see below) but this is an unlikely configuration.
`n` is an integer in the tables so `2n` is always even, `2n+1` is always odd.

[#padding-examples-RV32D]
.RV32D padding examples, XLEN=32, FLEN=64
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1   |4-bytes
|====================================

[#padding-examples-RV64Q]
.RV64Q padding examples, XLEN=64, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1  |4-bytes
|====================================

[#padding-examples-RV32Q]
.RV32Q padding examples, XLEN=32, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 4n     |none                     
| 4n+1   |4-bytes
| 4n+2   |8-bytes                     
| 4n+3   |12-bytes
|====================================

===== `mv, ret_val, ra, frlist, rlist` for the 32-bit encodings

The registers in the `reg_list` are controlled by these fields

Note that `frlist`, `mv` and `ret_val` are in the same location in the encoding.

[#32bit-frlistfdq]
.`frlist` values for the 32-bit encodings for `PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]`
[options="header"]
|=====================
|frlist | ABI names  
| 0      |none or `fs0-fs11` (see `rlist=13`)
| 1      |fs0         
| 2      |fs0-fs1
| 3      |fs0-fs5
|=====================

See <<32bit-mv>> for `mv`.

See <<32bit-ra>> for `ra`.

[#32bit-rlistfdq]
.`rlist` field values for PUSH.[FDQ]/POP.[FDQ]/POPRET.[FDQ]
[options="header"]
|==========================
|rlist  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
2+|  `rlist=13` is valid if `frlist=0` for `[.fdq]` opcodes
| 13     |s0-s11,fs0-fs11
2+|these values could be used for interrupt save/restore
| 14-15  | *reserved*
|==========================

==== Assembly examples

===== PUSH.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rlist=5, frlist=1, fdq=0, spimm=16 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sw  ra,   -4(sp);
sw  s0,   -8(sp); 
sw  s1,  -12(sp); 
sw  s2,  -16(sp); 
sw  s3,  -20(sp); 
sw  s4,  -24(sp); 
fsw fs0, -28(sp)
addi sp, sp, -64;
----

===== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rlist=5, frlist=1, fdq=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sd  ra,  -8(sp);
sd  s0,  -16(sp); 
sd  s1,  -24(sp);
sd  s2,  -32(sp); 
sd  s3,  -40(sp);
sd  s4,  -48(sp); 
fsd fs0, -56(sp)
addi sp, sp, -64;
----

===== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {fs0-fs7}, -128
----

Encoding: rlist=0, frlist=12, fdq=2, spimm=32 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsd  fs0,  -8(sp);
fsd  fs1, -16(sp); 
fsd  fs2, -24(sp);
fsd  fs3, -32(sp); 
fsd  fs5, -40(sp); 
fsd  fs4, -48(sp);
fsd  fs6, -56(sp);
fsd  fs7, -64(sp); 
fsd  fs8, -72(sp); 
fsd  fs9, -80(sp); 
fsd  fs10,-88(sp); 
fsd  fs11,-96(sp); 
addi sp, sp, -128; 
----

=== Benchmarking results too low

==== TBLJAL (32-bit encoding)

`TBLJAL` offers minimal additional benefit over `C.TBLJAL`

[NOTE]

  The 32-bit encoding is in _custom-0_, correct encodings need to be allocated.

[#tbljal32bitencoding]
.TBLJAL 32-bit encoding, ZCE-type encoding
[width="100%",options=header]
|=========================================================================================================================
| 31:23   |22:15         | 14:12   | 11:7         | 6 : 0 | instruction
|00000000 |index13[12:5] | 000   2+| index13[4:0] |0101011| TBLJAL
|=========================================================================================================================


==== LWTP, SWTP, LDTP, SDTP

TP relative load/store (similar to LWGP etc.) adding TP as a second global pointer.

The benefit from LWGP etc. so far is very low so there is no justification to add an extended range to TP.

==== MULIADD, ADDIADD, MULIW, MULIADDW, ADDIADDW

These instructions have low benefit. `MULIADD` and `ADDIADD` are unpopular due to requiring 3 operands. `MULI` is useful (and is included in the proposal) and takes much of the benefit of `MULIADD`

See https://github.com/clairexen/riscv-fanfic/blob/master/riscv-cfmt/riscv-cfmt.md[Clare's proposal from the B-extension].
Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[this document], which is implemented on silicon.

[#arithmetic_semantics]
.Arithmetic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULIADD        |rd' = rs1' + rs2' * sign_ext(imm)
|ADDIADD        |rd' = rs1' + rs2' + sign_ext(imm)
2+|RV64/RV128 only
|MULIW          |rd' = sign_ext((rs1'[31:0] * sign_ext(imm))[31:0])
|MULIADDW       |rd' = sign_ext((rs1'[31:0] + rs2'[31:0] * sign_ext(imm))[31:0])
|ADDIADDW       |rd' = sign_ext((rs1'[31:0] + rs2'[31:0] + sign_ext(imm))[31:0])
)
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
muliadd  a0, a1, a2, 2 # a0 = a1 + a2 * 2
addiadd  a0, a1, a2, 2 # a0 = a1 + a2 + 2
muliw    a0, a1, 2     # a0 = sign_ext(a1 * 2)
muliaddw a0, a1, 2     # a0 = sign_ext(a1 + a2 * 2)
addiaddw a0, a1, 2     # a0 = sign_ext(a1 + a2 + 2)
----
==== BGEUI, BLTUI

These allocate reserved encodings, and are similar to <<cmpimmbr>> but have lower value. It's possible that future use of these instructions will be found in later versions of `Zce`.

[rejected-cmpimmbr-32bit-encodings]
.Rejected 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26:25  |24   |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 010   2+| offset[5:1]       |1000011| BGEUI
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 011   2+| offset[5:1]       |1000011| BLTUI
|=========================================================================================================================

[#rejected-cmpimmbr-branch_semantics]
.Rejected compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BGEUI         | if (rs1>=~u~ zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BLTUI         | if (rs1<~u~  zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
bgeu a5, 1,offset # if(a5>= 1) branch_to(PC+offset) # unsigned comparison
bltu a5, 1,offset # if(a5<  1) branch_to(PC+offset) # unsigned comparison
----

==== C.LBUSP, C.LHUSP, C.SBSP, C.SHSP

These encodings require too much space for the benefit.

[#ldstbhsprel-16encodings]
.Rejected load/store half/byte SP relative 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:1ï¼4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:1ï¼4] 2+|11 2+|00 | C.SHSP
|================================================================================================

[#ldstbhsprel-semantics]
.Rejected load/store byte/half SP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBUSP       | rd' = zero_ext(DataMemory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(DataMemory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | DataMemory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | DataMemory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh_sprel_32bit]
.load/store byte/half SP relative assembler syntax and 32-bit equivalent instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembler syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBUSP     | lbu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SBSP      | sb     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SHSP      | sh     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   
----

==== C.LSBNOT / C.LSBSET

The encodings are cheap, but the benefit is low.

[#dyadic-16encodings-lsbnot-lsbset]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 110     2+| 00  | C.LSBNOT
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 111     2+| 00  | C.LSBSET
|=============================================================================================

[#monsemantics_lsbnot_lsbset]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LSBNOT      | rd' = rd' XOR 1
| C.LSBSET      | rd' = rd' OR 1
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembler syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LSBNOT    | lsbnot rd             | all registers x8-x15, rd==rs1      | I-extension
|C.LSBKEEP   | lsbset rd             | all registers x8-x15, rd==rs1      | I-extension
|======================================================================================================


Assembly Examples

[source,sourceCode,text]
----
lsbnot a5;      # a5 = a5 XOR 1
----


== Future ideas

=== Multiple move instructions

These instructions have some problems: 

. They either two register file write ports, or to be issued in a sequence.
. C.MVA* use ABI names when specifying source registers, which is efficient but non-standard
. There is no 32-bit encoding which makes sense, because each does the work of 2 x 16-bit encodings

Therefore ratification is delayed, and some more thought is needed.

==== C.MVP

The generic move uses standard x register numbers, and so it more standard than `C.MVA*S07`, however it takes a lot more encoding space. Both register pairs must be even/odd pairs (`rdp[0]=0, rsp[0]=0`) to reduce the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.

[#mvp-encoding]
.generic double move 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     3+|101    4+| rdp[4:1] 4+|  rsp[4:1]       2+| 00    | C.MVP
|================================================================================================

[#mvp-semantics]
.generic double move semantics
[width="100%",options=header]
|=======================================================================
|instruction            | definition
| C.MVP rdp, rsp        | mv rdp, rsp;  mv rdp+1, rsp+1
|=======================================================================

[#mvp-syntax]
.`C.MVP` assembler syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembler syntax          | requirements for 16-bit encoding   | 32-bit extension
|C.MVP       | mv(rdp,rsp),(rdp+1,rsp+1)| none                               | N/A
|======================================================================================================

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

Assembly examples.
[source,sourceCode,text]
----
# c.mvp: sreg1 = 0; sreg2 = 0;
mv (x2, x3), (x18, x19) ; # mv x2, x2; mv x18, x19
----

==== C.MVA23S07

Similar to C.MVA01S07 but the benefit is much lower.

[#proposed-16bit-encodings-4]
.`C.MVA23S07` 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     2+|10     3+| 001      3+|sreg1      3+|sreg2    2+| 00    | C.MVA23S07
|================================================================================================

[#mvs07_semantics]
.`C.MVA23S07` semantics
[width="100%",options=header]
|=======================================================================
|instruction                | definition
| C.MVA23S07 sreg1, sreg2   | mv a2, s[sreg1];  mv a3, s[sreg2]
|=======================================================================

[#mvs07_syntax]
.`C.MVA23S07` assembler syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembler syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.MVAS23S07 | mv(a2,a3),(sreg1,sreg2)| none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva23s: sreg1 = 1; sreg2 = 3;
mv (a2, a3), (s1, s3) ; # mv a2, s1; mv a3, s3
----

