= RISC-V Zce code-size reduction extension proposal v0.27
Version 0.27
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes the `Zce` extension to reduce code-size.

== Spec update history

|===================================================================
| version | change
| 0.27    | add tentative versions of C.PUSH/POP/POPRET.E, need to review them
| 0.26    | simplify and rename subsets. Re-encode LWGP/SWGP etc. Add LDWP/SDGP etc. Re-encode DECBGEZ. Re-encode C.SEXT.B, C.SEXT.H, C.NOT, C.NEG following Greg Favor's recommendation
| 0.25    | Add Zcee for inclusion in RVA22
| 0.24    | add illegal combinations of mv and rcount into PUSH spec
|         | added verification notes
| 0.23    | add C.ZEXT.W and Zba for the 32-bit version 
| 0.22    | group encodings closer together to hopefully allocate 16-bit encoding space to Zce. Put code points numbers into the tables
| 0.21    | remove SEXT.W as it's an existing pseudo-instruction, and also remove ZEXT.W as it requires Zbp (which is otherwise is *not* required). 
|         | Remove C.LSBKEEP as it's the same as C.ANDI, rs, 1. Postpone C.LSBSET. 
|         | Tidy up encodings of C.[SX]EXT.[BH] so we don't leave gaps
|         | Add code-point information
| 0.20    | Put MULI[W]/MULIADD[W] into Zcecm
|         | POSTPONE PUSH.[FDQ]/POP.[FDQ]/POPRET.[FDQ]. 
|         | Replace C.LSBNOT with C.LSBSET and also add C.LSBKEEP. 
|         | Remove BGEUI, BLTUI, C.LSBNOT, C.LBUSP, C.LHUSP, C.SBSP, C.SHSP as benchmarking results are low
|         | Put C.MVP/C.MVA*S07 into a "future work" category as they need more thought
|         | reduced C.TBLJAL immediate to 8-bits, the 9th bit didn't pay for itself
|         | Note EABI compatibility in PUSH/POP/POPRET
|         | Update C.NOT/C.NEG assembly syntax
| 0.18    | Separate C.MUL into Zcecm to avoid the dependancy on M, so Zcec has one subset (but is still the same ratification group)
| 0.17    | Add Zbb and possibly Zba (open issue)
| 0.16    | Add Zces[fdq] subsets
| 0.15    | add B-ext pseudo-ops and pack/packw into Zcec for 32-bit forms of new instructions
| 0.14    | BNEI/BEQI/MULI/MULIADD/ADDIADD moved from Zced to Zcec. Found encodings for B*I and DECBGEZ to allow Zced+ZDinx. Reduced cmpimm range for BNEI/BEQI to fit the encoding. Allocated provisional encodings for all 32-bit instructions. Fixed width of frcount, mv in PUSH/POP encodings.
| 0.13    | split LWGP/SWGP into LWGP/SWGP and LWTP/SWTP
| 0.12    | reduce ret_val to 2-bits for POP/POPRET
| 0.11    | Add C.SEXT.W, C.ZEXT.W, MULI, MULIADDW, ADDIADDW, and change the C.[SZ]EXT.* encodings. Rename flen PUSH/POP encoding field to fdq to avoid confusion with FLEN.
|===================================================================

== Issues

* need EABI versions of PUSH/POP/POPRET
* need 32-bit instruction formats for Zcea (I've only done Zceb)
* should the fault handling in `push/pop/popret` be profile defined, or is platform defined ok?
* is a hypervisor version of `xTBLJALVEC` required for `tbljal`?
* `xTBLJALVEC` need addresses to be allocated
* for `C.PUSH` confirm that the auto-included register moves are optimal (give the right balance between saving code-size and not wasting performance)

== `Zce` configurations

image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/Zce_subsets%20simplified2.png[Zce subsets]

`Zce` is split into two main subsets

* `Zcea` is required in RVM22, is compatible with all existing standard extensions
** `Zcee` is a subset of `Zcea` which required in RVA22
** `Zcea/Zcee` imply `Zba/Zba` to get the 32-bit versions of the sign/zero-extension encodings
* `Zceb` is optional for in RVM22 _because it conflicts with the D-extension_
** `Zceb` is fully compatible with `ZDinx`

[#zcea]
.Zcea extension
[width="100%",options=header]
|===============================================================================
|Instruction|RV32|RV64|RV128|Extension|Notes
6+|Zcee subset
|C.SEXT.B|✓|✓|✓|Zcea/Zcee|
|C.SEXT.H|✓|✓|✓|Zcea/Zcee|
|C.SEXT.W| |✓|✓|Zcea/Zcee|pseudo-instruction
|C.ZEXT.B|✓|✓|✓|Zcea/Zcee|
|C.ZEXT.H|✓|✓|✓|Zcea/Zcee|
|C.ZEXT.W| |✓|✓|Zcea/Zcee|
6+|Require M or Zmmul to be inferred
|C.MUL|✓|✓|✓|Zcea|requires M or Zmmul
|MULI|✓|✓|✓|Zcea|requires M or Zmmul
|MULIADD|✓|✓|✓|Zcea|requires M or Zmmul
|MULIW| |✓|✓|Zcea|requires M or Zmmul
|MULIADDW| |✓|✓|Zcea|requires M or Zmmul
6+|other 16-bit encodings
|C.NOT|✓|✓|✓|Zcea|
|C.NEG|✓|✓|✓|Zcea|
|C.TBLJAL|✓|✓|✓|Zcea|
|C.PUSH|✓|✓|✓|Zcea|
|C.POP|✓|✓|✓|Zcea|
|C.POPRET|✓|✓|✓|Zcea|
6+|other 32-bit encodings
|ADDIADD|✓|✓|✓|Zcea|
|ADDIADDW| |✓|✓|Zcea|
|TBLJAL|✓|✓|✓|Zcea|
|PUSH|✓|✓|✓|Zcea|
|POP|✓|✓|✓|Zcea|
|POPRET|✓|✓|✓|Zcea|
|===============================================================================

[#zceb]
.Zceb extension, incompatible with D, compatible with ZDinx
[width="100%",options=header]
|===============================================================================
|Instruction|RV32|RV64|RV128|Extension|Notes
6+| 16-bit encodings
|C.DECBGEZ|✓|✓|✓|Zceb|incompatible with D
|C.LBU|✓|✓|✓|Zceb|incompatible with D
|C.LHU|✓|✓|✓|Zceb|incompatible with D
|C.SB|✓|✓|✓|Zceb|incompatible with D
|C.SH|✓|✓|✓|Zceb|incompatible with D
6+| 32-bit encodings
|DECBGEZ|✓|✓|✓|Zceb|incompatible with D
|LWGP|✓|✓|✓|Zceb|incompatible with D
|LWTP|✓|✓|✓|Zceb|incompatible with D
|SWGP|✓|✓|✓|Zceb|incompatible with D
|SWTP|✓|✓|✓|Zceb|incompatible with D
|LDGP| |✓|✓|Zceb|incompatible with D
|LDTP| |✓|✓|Zceb|incompatible with D
|SDGP| |✓|✓|Zceb|incompatible with D
|SDTP| |✓|✓|Zceb|incompatible with D
|===============================================================================

`Zcea/Zceb` are compatible with both the `I` and `E` extensions. 

All systems which implement `Zcea/Zceb` must also implement the `C` extension. 

If `M` or `Zmmul` is specified then `Zcea` also includes the `C.MUL, MULI, MULIADD` instructions, and `MULIW, MULIADDW` for RV64/RV128.

`Zcea` implies the `B`-extension subsets `Zba` and `Zbb`. Therefore `RV32IC_Zcea` is equivalent to `RV32IC_Zcea_Zba_Zbb`.

== C-extension subsets

The C-extension already reuses encodings between different architectures. `Zce` extends this concept further. <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>> show how each encoding is allocated for different architectures or for different combinations of extensions.

For example:

* `C.FSD`, `C.SQ`, and `{C.LBU, C.SB}` share opcodes, so for different configurations the encodings represent:
** `C.FSD` for `RV32CD/RV64CD`
** `C.SQ`  for `RV128C`
** `{C.LBU, C.SB}` for `RV32C_Zce, RV64C_Zce， RV32C_Zce_ZDinx, RV64C_Zce_ZDinx`
** illegal encoding for `RV32C, RV64C`, as neither `D` nor `Zce` was specified

The shared encoding column in the tables assigns an arbitrary number to show which encodings are grouped together (I can't find a better way of highlighting groups of cells in the table in adoc format). `Zce` instructions are in *bold*.

[#zce_quad0]
.C-extension quadrant 0
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension
|000       |C.ADDI4SPN| |Zci |✓|✓ |✓  |C

|001       |C.FLD     |1|Zcd |✓|✓ |   |C+D
|001       |C.LQ      |1|Zcq |  |  |✓  |C
|001       |*C.DECBGEZ* |1|*Zceb*|✓|✓ |  |C+*Zceb*

|010       |C.LW      | |Zci |✓|✓ |✓  |C

|011       |C.FLW     |2|Zcf |✓|   |   |C+F
|011       |C.LD      |2|Zc64/Zc128| |✓|✓|C

|100       |*C.POP*     | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.POPRET*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.PUSH*    | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*

|100       |*C.TBLJAL*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.SEXT.B*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.SEXT.H*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.ZEXT.B*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.ZEXT.H*  | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.NOT*     | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.NEG*     | |*Zcea*|	✓|	✓|	✓|	C+*Zcea*
|100       |*C.MUL*     | |*Zcea*|	✓|	✓|	✓|	M+C+*Zcea*

|101       |C.FSD     |3|Zcd|✓|✓| |C+D
|101       |C.SQ      |3|Zcq| | |✓|D
|101       |*C.SB*      |3|*Zceb*|✓|✓| |C+*Zceb*
|101       |*C.LBU*     |3|*Zceb*|✓|✓ |  |C+*Zceb*

|110       |C.SW      | |Zci|✓|✓|✓|C

|111       |C.FSW     |4|Zcf|✓| | |C+F
|111       |C.SD      |4|Zc64/Zc128| |✓|✓|C
|===============================================================================

[#zce_quad1]
.C-extension quadrant 1
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.NOP	| |Zci	|✓	|✓	|✓	|C
|000       |C.ADDI	| |Zci	|✓	|✓	|✓	|C


|001       |C.JAL	        |5|Zc32	        |✓	|	|	|C
|001       |C.ADDIW (rd=0:RSV)  |5|Zc64/Zc128	|	|✓	|✓	|C

|010       |C.LI (rd=0:HINT) | |Zci	|✓	|✓	|✓	|C


|011       |C.ADDI16SP (nzimm=0:RSV)	| | Zci	|✓	|✓	|✓	|C
|011       |C.LUI (nzimm=0: RSV; rd=0:HINT)	| |Zci	|✓	|✓	|✓	|C


|100       |C.SRLI (RV32:NSE, nzuimm[5]=1)        |6|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRLI64 (RV32:HINT)                  |6|Zc128	|	|	|✓	|C
|100       |C.SRAI (RV32:NSE, nzuimm[5]=1)        |7|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRAI64 (RV32/64:HINT)               |7|Zc128	|	|	|✓       |C
|100       |C.ANDI                                | |Zci	|✓	|✓	|✓	|C
|100       |C.SUB                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.XOR                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.OR                                  | |Zci	|✓	|✓	|✓	|C
|100       |C.AND                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.SUBW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C
|100       |C.ADDW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C

|101       |C.J	       | |Zci	|✓	|✓	|✓	|C


|110       |C.BEQZ	| |Zci	|✓	|✓	|✓	|C


|111       |C.BNEZ	| |Zci	|✓	|✓	|✓	|C
|===============================================================================

[#zce_quad2]
.C-extension quadrant 2
[width="100%",options=header]
|======================================================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.SLLI (rd=0:HINT; RV32 && nzuimm[5]=1:NSE)| 8|Zc32/Zc64	|✓	|✓	|	|C
|000       |C.SLLI64 (RV32/64 or rd=0:HINT)	       | 8|Zc128	        |	|	|✓	|C
|001       |C.FLDSP	                               | 9|Zcd	        |✓	|✓	|	|C+D
|001       |C.LQSP (rd=0:RSV)	                     | 9|Zc128	        |	|	|✓	|C
|001       |*unallocated*	                         | 9|N/A 	|✓	|✓	| 	|C+*??*
|010       |C.LWSP (rd=0:RSV)	                     |  |Zci	        |✓	|✓	|✓	|C
|011       |C.FLWSP	                               |10|Zcf	        |✓	|	|	|C+F
|011       |C.LDSP (rd=0:HINT)	                   |10|Zc64/Zc128	|	|✓	|✓	|C
|100       |C.JR     (rd=0:RSV)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.MV   (rd=0:HINT)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.EBREAK	                             |  |Zci   	|✓	|✓	|✓	|C
|100       |C.JALR	                               |  |Zci   	|✓	|✓	|✓	|C
|100       |C.ADD (rd=0:HINT)	                     |  |Zci   	|✓	|✓	|✓	|C
|101       |C.FSDSP	                               |11|Zcd	        |✓	|✓	|	|C+D
|101       |C.SQSP	                               |11|Zc128		|       | 	|✓	|C
|101       |*C.SH*	                               |11|*Zceb*	|✓	|✓	| 	|C+*Zceb*
|101       |*C.LHU*	                               |11|*Zceb* 	|✓	|✓	| 	|C+*Zceb*
|110       |C.SWSP	                               |  |Zci	        |✓	|✓	|✓	|C
|111       |C.FSWSP	                               |12|Zcf	        |✓	|	|	|C+F
|111       |C.SDSP	                               |12|Zc128	        |	|✓	|✓	|C
|======================================================================================================

== Allocation of new 16-bit encodings

This section gives a short-hand lookup of exactly where the new encodings are allocated to make it easier to review the encoding space. The first column is the group number from <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>>.

|======================================
|Group|[15:13]|[12:10]|[1:0]|Instruction

| |100    |000    |00   |C.POP, C.POPRET, C.PUSH
| |100    |001    |00   |C.SEXT.B, C.SEXT.H, C.ZEXT.B, C.ZEXT.H, C.ZEXT.W, C.NOT, C.NEG, C.MUL
| |100    |110    |00   |C.TBLJAL

|1|001    |xxx    |00   |C.DECBGEZ

|3|101    |0xx    |00   |C.SB
|3|101    |1xx    |00   |C.LBU

|11|101   |0xx    |10   |C.SH
|11|101   |1xx    |10   |C.LHU
|======================================


=== 16-bit encoding code-points

All previously reserved 16-bit encodings are in the tables below, showing how many are allocated to `Zce`.

[#spare16encodings]
.spare 16-bit encodings for RV32/RV64
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |code points| sub-extension
3+|  100     3+|000        8+|xxxx                            2+| 00    |226/256 | `Zcea`
3+|  100     3+|001        8+|xxxx                            2+| 00    |120/256 | `Zcea`
3+|  100     3+|010        8+|xxxx                            2+| 00    |256/256 | `Zcea`
3+|  100     3+|011        8+|xxxx                            2+| 00    |0/256   | *reserved*
3+|  100     3+|1xx        8+|xxxx                            2+| 00    |0/1024  | *reserved*
3+|  011       | 0 5+|xxxxx             5+|11111              2+| 01    |0/32    | *reserved*
3+|  100     3+|111  3+|xxx   |1  4+|xxx                      2+| 01    |0/128   | *reserved*
3+|  100     6+|000000                  5+|non-zero           2+| 10    |0/31    | *reserved*
|================================================================================================

[#spare encodings RV32]
.spare 16-bit encodings for RV32 only (mainly out of range shifts)
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |code points| sub-extension         
3+|  100     2+|10  9+|xxx                                      2+| 01  |0/512  | *reserved*
3+|  100     3+|111  3+|xxx   |0  4+|xxx                        2+| 01  |0/128  | *reserved*
3+|  000       | 1   5+| non-zero            5+|xxx             2+| 10  |0/992  | *reserved*  
|================================================================================================

[#spare encodings RV64]
.spare 16-bit encodings for RV64 only (ADDIW with zero destination)
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |code points| sub-extension  
3+| 001        | x 5+|00000             5+| xxxxx             2+|01     |0/64 | *reserved*
|================================================================================================

[#spare encodings D]
.spare 16-bit encodings reused from the D-extension
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |code points|sub-extension  
3+| 001        11+|xxx                                        2+|00     |2047/2048| `Zceb`
3+| 101        11+|xxx                                        2+|00     |2048/2048| `Zceb`
3+| 001        11+|xxx                                        2+|10     |   0/2048| *reserved*       
3+| 101        11+|xxx                                        2+|10     |2048/2048| `Zceb`
|================================================================================================

In total in the existing RVC (16-bit) encoding space:

. RV32C has 3871 code points available, 576 are used (14.9%)
. RV64C has 2303 code points available, 576 are used (25.0%)
. RV32CD (i.e. the C.FSD,C.FLD, C.FSDSP, C.FLDSP encodings) has 8192 code points available, 6143 are used (75.0%)

. if the partially allocated encoding groups from <<spare16encodings>> are fully allocated to Zce the figures become
.. RV32C has 3871 code points available, 768 are used (19.8%)
.. RV64C has 2303 code points available, 768 are used (33.3%)

== `Zcea` definition

=== C.SEXT.B, C.SEXT.H, C.ZEXT.B, C.ZEXT.H, C.ZEXT.W, C.MUL, C.NOT, C.NEG

These instructions have no conflicts with other extensions, they use previously reserved encodings.

These instructions are 16-bit versions of existing 32-bit instructions, from either `I/E` or the `Zba/Zbb`-extension.

[#dyadic-16encodings]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|monadic with single source/dest, room for 1 more encoding 
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 010     2+| 00  | C.ZEXT.W
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 011     2+| 00  | *reserved*
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 100     2+| 00  | C.SEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 101     2+| 00  | C.SEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 110     2+| 00  | C.NOT
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 111     2+| 00  | C.NEG
17+|Dyadic with room for 2 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 1  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 0  | 0  | 1 3+| xxx      | 1  | x  3+| xxx     2+| 00  | *reserved*
|=============================================================================================

[#monsemantics]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.NOT         | rd' = ~rd' / rd' = rd' XOR -1
| C.NEG         | rd' = -rd'
| C.MUL         | rd' = rd' * rs2'
2+| RV64/RV128 only
| C.ZEXT.W      | rd' = zero_ext(rd'[31:0])
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.ZEXT.B    | zext.b rd             | rd x8-x15                          | I or E
|C.ZEXT.H    | zext.h rd             | rd x8-x15                          | Zbb
|C.SEXT.B    | sext.b rd             | rd x8-x15                          | Zbb
|C.SEXT.H    | sext.h rd             | rd x8-x15                          | Zbb
|C.NOT       | not    rd             | rd x8-x15                          | I or E
|C.NEG       | neg    rd             | rd x8-x15                          | I or E
|C.MUL       | mul    rd, rs1, rs2   | rd x8-x15                          | I or E
4+|RV64/RV128 only
|C.ZEXT.W    | zext.h rd             | rd x8-x15                          | Zba
|======================================================================================================


Assembly Examples

[source,sourceCode,text]
----
zext.b a5;  # a5 = zero_ext(a5[7:0])
zext.h a5;  # a5 = zero_ext(a5[15:0])
sext.b a5;  # a5 = sign_ext(a5[7:0])
sext.h a5;  # a5 = sign_ext(a5[15:0])

not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion

mul a5, a5, a6; # a5 = a5 * a6

----

=== C.SEXT.W

`C.SEXT.W` is added as a pseudo-instruction for `C.ADDIW rd, rd, 0`

=== MULI, MULIADD, ADDIADD, MULIW, MULIADDW, ADDIADDW

These instructions have no conflicts with other extensions, they use previously reserved encodings.

See https://github.com/clairexen/riscv-fanfic/blob/master/riscv-cfmt/riscv-cfmt.md[Clare's proposal from the B-extension].
Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[this document], which is implemented on silicon.

[zcec-32bit-encodings-arithmetic]
.arithmetic instructions 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26|25   |24  |23|22|21:20      |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
7+|imm[11:0]                                          |00 2+|rs1'   2+| 11100           | rd'       |0011011| MULI
7+|imm[11:0]                                          |10 2+|rs1'   2+| 11100           | rd'       |0011011| MULIW
5+|imm[8:0]                          2+|rs2'          |00 2+|rs1'   2+| 11100           | rd'       |0011111| MULIADD
5+|imm[8:0]                          2+|rs2'          |10 2+|rs1'   2+| 11100           | rd'       |0011111| MULIADDW
5+|imm[8:0]                          2+|rs2'          |00 2+|rs1'   2+| 11101           | rd'       |0011111| ADDIADD
5+|imm[8:0]                          2+|rs2'          |10 2+|rs1'   2+| 11101           | rd'       |0011111| ADDIADDW
|=========================================================================================================================

[#arithmetic_semantics]
.Arithmetic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULI           |rd' = rs1' * sign_ext(imm)
|MULIADD        |rd' = rs1' + rs2' * sign_ext(imm)
|ADDIADD        |rd' = rs1' + rs2' + sign_ext(imm)
2+|RV64/RV128 only
|MULIW          |rd' = sign_ext(rs1'[31:0] * sign_ext(imm))
|MULIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' * sign_ext(imm))
|ADDIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' + sign_ext(imm))
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
muli     a0, a1, 2     # a0 = a1 * 2
muliadd  a0, a1, a2, 2 # a0 = a1 + a2 * 2
addiadd  a0, a1, a2, 2 # a0 = a1 + a2 + 2
muliw    a0, a1, 2     # a0 = sign_ext(a1 * 2)
muliaddw a0, a1, 2     # a0 = sign_ext(a1 + a2 * 2)
addiaddw a0, a1, 2     # a0 = sign_ext(a1 + a2 + 2)
----


[#cmpimmbr]
=== BEQI, BNEI

These instructions have no conflicts with other extensions, they use previously reserved encodings.

The encodings allow a comparison of a register and an immediate value. `BEQI` in particular is very useful for _switch_ statements. 

[compare-immediate-branch_encodings]
.proposed 32-bit encodings for `BEQI/BNEI`
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26:25  |24   |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
| scmpimm[5:1]       |10      |scmpimm[0]  2+|  offset[9:6]  3+| rs1  | 000   2+| offset[5:1]       |1000011| BEQI
| scmpimm[5:1]       |10      |scmpimm[0]  2+|  offset[9:6]  3+| rs1  | 001   2+| offset[5:1]       |1000011| BNEI
|=========================================================================================================================

[#compare-immediate branch_semantics]
.Compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BEQI          | if (rs1==sign_ext(scmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI          | if (rs1!=sign_ext(scmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
beq  a5, 1,offset # if(a5== 1) branch_to(PC+offset) # signed comparison
bne  a5,-1,offset # if(a5!=-1) branch_to(PC+offset) # signed comparison
----

=== Table Jump

The specification is in <<tablejump>>.

[[tablejump16]]
==== C.TBLJAL

The 16-bit encoding is in <<tbljal16bitencoding>>.

[[tablejump32]]
==== TBLJAL

The 32-bit encoding is in <<tbljal32bitencoding>>.

[#pushpoppopret_heading]
=== PUSH/POP/POPRET

See <<pushpoppopret>> for the specification.

[[pushpop32]]
==== PUSH, POP, POPRET

See <<pushpoppopret32bitencodings>> for the encodings.

[[pushpop16]]
==== C.PUSH, C.POP, C.POPRET

See <<pushpoppopret16bitencodings>> for the encodings.


=== B-extension reuse

Some instructions will be reused from the B-extension and are implied by `Zce`. 

==== Zba, Zbb required

`Zba` is require for the 32-bit encoding for `c.zext.w`. The `sh[123]add` instructions are also useful for code-size reduction, as they are used for address calculations.

`Zbb` is required for 32-bit encodings for `c.sext.b, c.sext.h, c.zext.b, c.zext.h`. It is simpler to take the whole `Zbb` subset as it also contains useful instructions like rotate (`rori, ror, rol`), byte reverse (`rev8`) and count-leading-zeroes (`clz`).

[NOTE]

  `Zbp` is *not* implied by `Zce` as instructions like `grev[i]` and `shfl[i]` seem too heavyweight for small embedded cores. 


== `Zceb` definition

The D-extension takes priority over these encodings.

[Zceb-32bit-formats]
.proposed 32-bit formats
[width="100%",options=header]
|=========================================================================================================================
| 31:29    |28:25                  |24:20            |19:18|17:15       |14:12   | 11:7             | 6 : 0 | instruction
9+|These formats are designed for maximum overlap immediate with I-type and S-type
|funct3a 2+|imm[8:2,10:9]                          2+|imm[15:11]  | funct3 | rd               |opcode | LW16-type
|funct3a   |imm[8:5]               | rs2           2+|imm[15:11]  | funct3 | imm[4:2, 10:9]   |opcode | SW16-type
|funct3a 2+|imm[8:3,16,10:9]                       2+|imm[15:11]  | funct3 | rd               |opcode | LD16-type
|funct3a   |imm[8:5]               | rs2           2+|imm[15:11]  | funct3 | imm[4:3,16,10:9] |opcode | SD16-type
9+|This format is only for DECBGEZ, designed for maximum immediate overlap with B-type and LW16-type
|funct3a 2+|imm[8:2,10:9]                          |scale|imm[1,12:11]  | funct3 | rd         |opcode | DECB-type
|=========================================================================================================================

=== Decrement and branch

[[decbr16]]
==== C.DECBGEZ

This instruction conflicts with the `D`-extension. If `D` is implemented, this instruction will not be available. It is compatible with `ZDinx`.

This instruction is a combined decrement and branch, used for inferring loops with an optionally scaled loop counter.

[NOTE]

  The 32-bit encoding has a signed offset. The 16-bit encoding has an unsigned offset, but it can only represent a backwards jump. 
  Therefore to be legal syntax for the 16-bit encoding the offset is specified as a negative number but encoded as a positive offset.
 
[NOTE]

  The encoding is reserved if the offset is zero.

[#proposed-16bit-encodings-dec_br]
.proposed 16-bit encodings for dec-and-branch
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  001          3+|nzimm[6:4] 3+| rd'  3+|nzimm[3:1] 2+|scale 2+| 00 | C.DECBGEZ
3+|  001          3+|000       3+| rd'  3+|000       2+|scale 2+| 00 | *reserved*
|=============================================================================================

[#deccmpbrsemantics]
.decrement, compare and branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.DECBGEZ     | rd' = rd' - (1<<scale); bge rd', zero, -zero_ext(nzimm);
|=======================================================================

[#v1.0-32bit]
.32-bit equivalent instructions for decrement, compare and branch semantics
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.DECBGEZ   | decbgez, rd, imm, -offset | rd is x8-x15, imm is [1248], offset is in range   | Zcec
|======================================================================================================

Assembly Example
[source,sourceCode,text]
----
decbgez s2, 1, -4 ;# s2-=1;if(s2>=0) branch_to(PC-4) encoded as scale=0, uimm=4 (not uimm=-4)
----

==== DECBGEZ

This instruction conflicts with the `D`-extension. If `D` is implemented, this instruction will not be available. It is compatible with `ZDinx`. It uses a DECB-type encoding.

The 16-bit encoding and specification is in <<decbr16>>.

[decbgez-32bit-encodings]
.proposed 32-bit encoding `DECBGEZ`
[width="100%",options=header]
|=========================================================================================================================
| 31:29    |28:25                  |24:20            |19:18|17:15       |14:12   | 11:7             | 6 : 0 | instruction
|100     2+|imm[8:2,10:9]                            |scale|imm[1,12:11]  | 011 | rd                |0000111 | DECBGEZ
|=========================================================================================================================

[#decbgezsemantics32]
.decrement, compare and branch 32-bit semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| DECBGEZ       | rd = rd - (1<<scale); bge rd, zero, sign_ext(imm);
|=======================================================================

Assembly Example
[source,sourceCode,text]
----
decbgez s2, 1, offset ;# s2-=1;if(s2>=0) branch_to(PC+offset)
----


=== LWGP, SWGP, LWTP, SWTP

These instructions conflict with the `D`-extension. If `D` is implemented, these instruction will not be available. They are compatible with `ZDinx`.

These instructions reuse the encodings for `FLD/FSD`.

`LWGP,SWGP` give a larger offset range than the standard `LW, SW` instructions by making the base register explicitly `gp`, allowing a 16-bit/64KB range of word aligned offsets, instead of a 12-bit/4KB range of byte aligned offsets.

[NOTE]

   Restrictions in the GCC toolchain mean that the full range of `gp` cannot be used for the standard `LW/SW` instructions, in case linker relaxation means that the `gp` relative addresses moves out of range. This will still be the case with `LWGP, SWGP` but the range is so much larger that the impact will be minimal. https://github.com/riscv/riscv-gnu-toolchain/issues/497[See this github issue]. This issue means that with the current RISC-V ISA the full 4KB range cannot be accessed using `gp` using GCC so the benefit is lower than might be expected.

`LWTP,SWTP` give an 18-bit/256KB offset range, which is larger than the standard `LW, SW` instructions by making the base register explicitly `tp`.

[NOTE]

  The intention is to allow the toolchain to use `tp` as a second global pointer, for systems which do not need thread local storage, giving two 256KB address spaces within reach of a single 32-bit load/store word instruction. Any ABI or toolchain implications from allowing this are not covered by this document. `LWTP, SWTP` can also be used to allow a larger range of thread local storage to be accessed with a 32-bit instruction.

[Zceb-32bit-encodings]
.proposed 32-bit encodings for `LWGP/SWGP/LWTP/SWTP` and `LDGP/SDGP/LDTP/SDTP`
[width="100%",options=header]
|=========================================================================================================================
| 31:29|28:25   |24:20      |19:15 | 14:12   | 11:7  | 6 : 0 | instruction
|000 2+|imm[8:2,10:9]                                |imm[15:11]  | 011   | rd                |0000111| LWGP
|001 2+|imm[8:2,10:9]                                |imm[15:11]  | 011   | rd                |0000111| LWTP
|000   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:2, 10:9]    |0100111| SWGP
|001   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:2, 10:9]    |0100111| SWTP
8+|RV64/RV128 only
|000 2+|imm[8:3,16,10:9]                             |imm[15:11]  | 011   | rd                |0000111| LDGP
|001 2+|imm[8:3,16,10:9]                             |imm[15:11]  | 011   | rd                |0000111| LDTP
|000   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:3,16,10:9]  |0100111| SDGP
|001   |imm[8:5]                   | rs2             |imm[15:11]  | 011   | imm[4:3,16,10:9]  |0100111| SDTP
|=========================================================================================================================

[#lwgp_semantics]
.Load/store word/double GP/TP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| LWGP          | rd=sign_ext(Memory[gp+sign_ext(imm)][31:0]);
| SWGP          | Memory[gp+sign_ext(imm)][31:0])=rs2[31:0];
| LWTP          | rd=sign_ext(Memory[tp+sign_ext(imm)][31:0]);
| SWTP          | Memory[tp+sign_ext(imm)][31:0])=rs2[31:0];
2+|RV64/RV128 only
| LDGP          | rd=sign_ext(Memory[gp+sign_ext(imm)][63:0]);
| SDGP          | Memory[gp+sign_ext(imm)][63:0])=rs2[63:0];
| LDTP          | rd=sign_ext(Memory[tp+sign_ext(imm)][63:0]);
| SDTP          | Memory[tp+sign_ext(imm)][63:0])=rs2[63:0];
|=======================================================================

Assembly Examples
[source,sourceCode,text]
----
lw s0, 20(gp)
sw s0, 20(gp)
lw s0, 20(tp)
sw s0, 20(tp)

//RV64/RV128 only
ld s0, 20(gp)
sd s0, 20(gp)
ld s0, 20(tp)
sd s0, 20(tp)
----

=== C.LBU, C.LHU, C.SB, C.SH

These instructions conflict with the `D`-extension. If `D` is implemented, these instruction will not be available. They are compatible with `ZDinx`.

These instructions reuse the encodings for `FLD/FSD`.

[#ldstbh]
.proposed 16-bit encodings for load/store byte/half
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  101       |0 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.SB
3+|  101       |1 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.LBU
3+|  101       |0 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.SH
3+|  101       |1 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.LHU
|=============================================================================================

[#ldstbhsemantics]
.Load/store byte/half semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh-32bit]
.Load/store byte-half 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBU       | lbu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.LHU       | lhu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SB        | sb     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SH        | sh     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|======================================================================================================

Assembly Examples
[source,sourceCode,text]
----
lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0])
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0]
----

[#tablejump]
== Table Jump 

Table jumps are used to reduce the code size of `JAL` / `JALR` instructions.

=== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  #64-bit AUIPC/JALR sequence
  e084be:	001f8317            auipc t1,0x1f8
  e084c2:	18a302e7            jalr  t0,394(t1) # 1000648 <__riscv_save_0>
  
  e084c6:	86b2                mv    a3,a2
  e084c8:	862e                mv    a2,a1
  e084ca:	800005b7            lui	  a1,0x80000
  e084ce:	fff5c593            not	  a1,a1
  
  #32-bit JAL
  e084d2:	f61ff0ef            jal	  ra,e08432 <vsnprintf> # vsnprintf
  
  #64-bit AUIPC/JALR sequence
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	  406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJAL` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx                tbljal #x ;#<mapped to __riscv_save_0>, saving 6-bytes
  
  e084c6:	86b2                mv     a3,a2
  e084c8:	862e                mv     a2,a1
  e084ca:	800005b7            lui	   a1,0x80000
  e084ce:	fff5c593            not	   a1,a1
  
  e084d2:	xxxx                tbljal #y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  
  e084da:	xxxx                tbljal #z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJALENTRIES` addresses for `[C.]TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. 

`TBLJALENTRIES` is set by the maximum size of the table, which is currently 8192 as the 32-bit encoding has an 13-bit index.

Table jump allows the linker to:

* replace 32-bit `JAL` calls with 16-bit `C.TBLJAL`
* replace 64-bit `AUIPC/JALR` calls to fixed locations with either a 16-bit `C.TBLJAL` or a 32-bit `TBLJAL` 
** `[C.]TBLJAL` can be used replace `JALR` if it jumps to a fixed target, which is typically inferred as an `AUIPC/JALR` sequence because the offset from the PC is out of the ±1MB range.

[NOTE]

   RV64 does not have `C.JAL` so `C.TBLJAL` is even more valuable

[NOTE]

  The 32-bit encoding allows more functions to be called, but saves less code size, so the most common functions should be callable by the 16-bit encoding

The 32-bit instruction encoding will ensure that 64-bit sequences `AUIPC/JALR` are unlikely to ever be needed to call functions, unless the jump table is full.

=== Encoding

These instructions have no conflicts with other extensions, they use previously reserved encodings.

[#tbljal16bitencoding]
.C.TBLJAL 16-bit encoding
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10  | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  | 0 8+|index8                         2+| 00    | C.TBLJAL
|=============================================================================================

[#tbljal32bitencoding]
.TBLJAL 32-bit encoding
[width="100%",options=header]
|=========================================================================================================================
| 31:27|                      26|25   |24  |23|22|21:20      |19:18|17:16|15 | 14:12   | 11:10 |9:7 | 6 : 0 | instruction
5+|000000000                         5+|index13[12:5]                 | 000   2+| index13[4:0]      |1000011| TBLJAL
|=========================================================================================================================

=== CSRs

The following set of CSRs is required to control the jump table. 

[NOTE]

  The addresses are for custom CSRs, correct CSR addresses need to be specified.

[#xTBLJALVEC-table]
.`xTBLJALVEC` definition
[width="100%",options=header]
|============================================================================================================
|Address |XLEN-1:6       |5:2   | 1: 0  | CSR        | Permissions | Status
|  0x7c0 |base[XLEN-1:6] |scale | mode  | MTBLJALVEC | MRW         | Required if jump table mode is implemented
|  0xbc0 |base[XLEN-1:6] |scale | mode  | STBLJALVEC | MRW         | Required if S-mode is implemented
|  0x800 |base[XLEN-1:6] |scale | mode  | UTBLJALVEC | MRW         | Optional
|============================================================================================================

* M-mode always uses `MTBLJALVEC.base`
* S-mode always uses `STBLJALVEC.base`
* U-mode uses `UTBLJALVEC.base` if implemented, otherwise `STBLJALVEC.base` if implemented, otherwise `MTBLJALVEC.base`

`xTBLJALVEC.base` is a virtual address, whenever virtual memory is enabled (i.e. S and U-modes only if implemented and enabled).

Using `xTBLJALVEC.base` in the pseudo code below implicitly assumes that `xTBLJALVEC.base[5:0]=0`. This is consistent with the description of `xTVEC` in the Unprivileged ISA manual.

`xTBLJALVEC.base` is naturally aligned for all legal values of `XLEN`.

The memory pointed to by `xTBLJALVEC.base` only requires eXecute permission. Read/Write access is not required once the jump table/vector table has been configured.

[#xTBLJALVEC-mode-table]
.`xTBLJALVEC.mode` definition
[width="100%",options=header]
|=============================================================================================
| Mode | Comment
| 00   | Jump table mode
| 01   | *reserved for <<vector-table-mode>>*
| 10   | *reserved for <<emulation-mode>>*
| 11   | *reserved*
|=============================================================================================

`xTBLJALVEC.mode` is a WARL field, so can only be programmed to modes which are implemented. Therefore the discovery mechanism is to attempt to program different modes and read back the values to see which are available. Jump table mode _must_ be implemented.

`xTBLJALVEC.scale` is also WARL, and reads as zero. It is reserved for Vector Table Mode, see <<vector-table-mode>>.

=== Jump table mode

In jump table mode the behaviour is to load the target address from `xTBLJALVEC.base` with an offset which is `XLEN/8` times the parameter passed to the instruction. Bits [1:0] of the data at the target address represent which link register is in use, and whether the entry is legal. Therefore the target functions must be word aligned in memory.

The actual functions are not moved in memory, the jump table lookup is only to give a reference to them using a 16-bit encoding whenever possible.

Jump table mode is easy to implement in the linker and doesn't affect the compiler at all as it is only a link time optimisation. It may complicate instruction fetch due to the indirection, and so may cost performance. The instruction fetch unit can choose to cache the table.

[#entry-lsbs]
.bits [1:0] of each jump table entry
[width="100%",options=header]
|=============================================================================================
| Value| Link Register
| 00   | link to x0
| 01   | link to x1
| 10   | link to x5
| 11   | *reserved / table entry is illegal*
|=============================================================================================

==== Pseudo-code for jump table mode

[source,sourceCode,text]
----
# tmp is temporary internal state, it doesn't represent a real register
# Mem is byte indexed
# n is the immediate operand passed to [c.]tbljal
switch(XLEN) {
  32:  LW tmp, Mem[xTBLJALVEC.base + n<<2][XLEN-1:0];
  64:  LD tmp, Mem[xTBLJALVEC.base + n<<3][XLEN-1:0];
  128: LQ tmp, Mem[xTBLJALVEC.base + n<<4][XLEN-1:0];
}
switch(tmp[1:0]) {
  0: JALR x0, tmp[XLEN-1:2]<<2;
  1: JALR x1, tmp[XLEN-1:2]<<2;
  2: JALR x5, tmp[XLEN-1:2]<<2;
  #MEPC is the PC of the [c.]tbljal, not tmp
  3: take_illegal_instruction_exception();
}
----

For the `vsprintf` example above, the jump table contains the following:

[source,sourceCode,text]
----
xTBLJALVEC.base+ 0(index 0) = # 100066c <__riscv_restore_0> # requires JAL x0 so [1:0]=00
xTBLJALVEC.base+ 8(index 1) = # 100064a <__riscv_save_0>    # requires JAL x5 so [1:0]=10
xTBLJALVEC.base+12(index 2) = #  e08433 <vsnprintf>         # requires JAL x1 so [1:0]=01
----

==== Exceptions for jump table mode

The only illegal instruction exception is if the jump table LSBs are set to `11`. If this happens `MEPC` is set to the PC of the `[c.]tbljal` instruction.

==== Context Switching for jump table mode

The `xTBLJALVEC` CSRs form part of the current context, and so will need to be saved and restored. It is also possible for the jump table to have a single configuration for all contexts, but in general `xTBLJALVEC` is considered part of the context.

==== Caching for jump table mode

For improved performance, the implementation may cache the contents of the jump table. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `xTBLJALVEC` has not been written to. 

Any write to `xTBLJALVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `xTBLJALVEC` is required to ensure that any cached contents are not stale. This is not expected to be the common case, because in the absence of dynamically linked libraries, the jump table is static for a given executable. Therefore the recommendation is that it is set with eXecute only privileges, the same as the rest of the code. This is better for security to prevent code in the jump table being scanned for gadgets.

==== Power/performance of jump table mode

The instruction fetch unit could cache the most frequently accessed table jump targets to improve performance. The management of this caching will cost some power (although the ~ 10% code size saving should save power overall by reducing the number of instruction fetches).

An alternative approach is to for the instruction fetch to cache a certain range of table jump indices, e.g. 0-31. The linker could be configured to place the most frequently used table jump indices into this range so that static caching can be used. For this to be successful the linker would need information about the dynamic call frequency of each function call.

[#vector-table-mode]
=== Future Mode: Vector table mode (not for RVM22/RVA22)

Vector table mode is very similar to vectored interrupt handling. The target address is a scaled offset from the base vector. Therefore in vector table mode, execution passes directly to the scaled offset from the base register, not via a jump table.

Vector table mode is simplest for the hardware, as it's just the same mechanism as for the interrupt handler vector. The jump is direct to the destination. However the compiler would have to be aware as it will have to try to fit functions into the table, as each entry is a fixed size so it's not so obviously implementable in the toolchain. We may find other reasons for having this mode. TBD.

`xTBLJALVEC.scale` controls the scale. It is a read/write field instead of WARL.

[width="40%",options=header]
|==================================================================
|`xTBLJALVEC.scale`| `tablescale` 
| 0                | 8-bytes
| 1                | 16-bytes
| 2                | 32-bytes
2+| .....
| 9                | 4096-bytes to match minimum TLB page size
| 10+              | *reserved*
|==================================================================

Note that `tablescale = 1<<(xTBLJALVEC.scale+3)`

`MTBLJALCFG` controls the valid entries in the table and the _watermarks_ which are used to control which link register is in use for each table entry.

[#MTBLJALCFG-table]
.`MTBLJALCFG` definition
[width="100%",options=header]
|================================================================================================================
| XLEN-1:30       | 29:20   | 19:10|  9: 0  | CSR         | Permissions | Status
| ROZ             |maxentry | wxm5 | wmx0   | MTBLJALCFG  | MRW         | Required if vector mode is implemented
| ROZ             |maxentry | wxm5 | wmx0   | STBLJALCFG  | SRW         | Required if S-mode is implemented
| ROZ             |maxentry | wxm5 | wmx0   | UTBLJALCFG  | URW         | Optional
|================================================================================================================

* M-mode always uses `MTBLJALCFG`
* S-mode always uses `STBLJALCFG`
* U-mode uses `UTBLJALCFG` if implemented, otherwise `STBLJALCFG` if implemented, otherwise `MTBLJALCFG`


[NOTE]
  The range of `MTBLJALCFG.maxentry` is from 0 to `TBLJALENTRIES-1`

[NOTE]
  All 3 fields are _unsigned_ integers

==== Watermarks

The two watermark fields are used to control which tables entries link to

*  `x0` (i.e. `J` not `JAL`)
*  `x1` (`ra`, standard link register)
*  `x5` (alternate link register for millicode routines)

Depending upon the programming, table entries can all be allocated to 1, 2 or all 3 link registers.

In the table MAX is `TBLJALENTRIES-1`.

[#MTBLJALCFG-table-watermark-end-conditions]
.`MTBLJALCFG` watermarks
[width="100%",options=header]
|==================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`| `JAL x0` range | `JAL x5` range | `JAL x1` range | Comment
6+| Normal programming model, use all 3 link registers
| X, X>0            | Y, Y>X          |*0 to X-1*      |*X to Y-1*      |*Y to MAX*      | Use all 3 link registers
6+| Restricted programming model, exclude 1 or 2 link registers
| 0                 |  MAX            |*0 to MAX*      |_none_          |_none_          | Only link to x0   
| MAX               |  MAX            |_none_          |*0 to MAX*      |_none_          | Only link to x5      
| 0                 | 0               |_none_          |_none_          |*0 to MAX*      | Only link to x1
| 0                 | Y, Y>0          |*0 to Y-1*      |_none_          |*Y to MAX*      | Only link to x0, x1
| X, X>0            | X               |_none_          |*0 to X-1*      |*X to MAX*      | Only link to x1, x5
6+| reserved for future use
| Z                 | <Z            3+|illegal instruction                               | *reserved*
|==================================================================================================================

Some of the modes may not be so useful, so we can consider restricting them, for example

- only link to x5 (only millicode routines)
- only link to x1, x5 (no J equivalent)
- _this needs review, but in general I'd like the specification to be flexible_

With the proposed encodings 

- the 16-bit encoding can access entry 0 to min(127, `MTBLJALCFG.maxentry`)
- the 32-bit encoding can access entry 0 to min(255, `MTBLJALCFG.maxentry`)

[#MTBLJALCFG-table-watermark-examples]
.`MTBLJALCFG` watermark examples
[width="100%",options=header]
|==========================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`|`JAL x0` range|`JAL x5` range| `JAL x1` range 
| 20                | 40              |*0 to 19*     |*20 to 39*    |*40 to 255*
| 0                 | 40              |*0 to 39*     |_none_        |*40 to 255*
| 40                | 40              |_none_        |*0 to 39*     |*40 to 255*
| 40                | 39            3+| *reserved*
| 0                 | 255             |*0 to 255*    |_none_        |_none_
| 255               | 255             |_none_        |*0 to 255*    |_none_
| 0                 | 0               |_none_        |_none_        |*0 to 255*               
|==========================================================================================================================

`JAL x1` is always highest in the range (if enabled), so that the 32-bit encoding typically adds more cases using `x1` to convert `AUIPC/JALR x1` sequences to `TBLJAL` to save code size.

.watermark example
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump2.PNG[watermark example]

==== Exceptions for vector table mode

Take an illegal instruction exception if `[C.]TBLJAL #n` is executed and one of more of these conditions are true:

- `n > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 < MTBLJALWM.wxm0` 
- `MTBLJALWM.wmx0 > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 > MTBLJALWM.maxentry`

All comparisons are _unsigned_.

==== Pseudo-code for vector table mode

[source,sourceCode,text]
----
# Mem is byte indexed
# LINK is x0, x1, x5 depending on the index number and the watermarks
if (n > MTBLJALCFG.maxentry OR MTBLJALWM.wmx5 < MTBLJALWM.wxm0) {
  take_illegal_instruction_exception();
  }
JALR LINK, Mem[xTBLJALVEC.base + n*tablescale][XLEN-1:0];
----

==== vector table code

Because this method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `xTBLJALVEC.scale` to specific values does not set a requirement on the alignment of `xTBLJALVEC.base`. For example if `tablescale=4096`, `xTBLJALVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `xTBLJALVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `xTBLJALVEC.scale=1` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is 136 bytes, but will shrink to 128-bytes or smaller by use of `c.tbljal` so I have allocated 4 entries to it.

[source,sourceCode,text]
----

MTBJALVECWM.wmx0 = 0 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 1 # c.tbljal #1+ map to JAL x1

#index 0 (JAL x0)
xTBLJALVEC.base+0 <__riscv_restore_0>:
 	4902                	lw	s2,0(sp)
 	4492                	lw	s1,4(sp)
 	4422                	lw	s0,8(sp)
 	40b2                	lw	ra,12(sp)
 	0141                	addi	sp,sp,16
 	8082                	ret

# index 2 (JAL x1)
xTBLJALVEC.base+32  <__riscv_save_0>:
 	1141                	addi	sp,sp,-16
 	c04a                	sw	s2,0(sp)
 	c226                	sw	s1,4(sp)
 	c422                	sw	s0,8(sp)
 	c606                	sw	ra,12(sp)
 	8282                	jr	t0

# index 3-6 (JAL x1)
xTBLJALVEC.base+48: <vsnprintf>
  	xxxx                	tbljal #5 ;# call to <__riscv_save_0>
  ...  up to 128-byte function body ...
  	xxxx                	tbljal #4 ;# call to <__riscv_restore_0>
----

[NOTE]

  This mode may waste memory as the target functions are very unlikely to all be multiples of `tablescale`.

==== Vector Mode Security (future ideas)

The vector mode mechanism could be reused for security in the future. It is possible to define that the memory allocated to to the table can only have entry points on the specific vectors, and also only from `[C.]TBLJAL` instructions. In this way sensitive code can be placed in the table which cannot be reused for ROP/JOP gadgets, because the code cannot be targetted by `JALR` instructions.

These ideas will not be pursued as part of the code size work.

[[emulation-mode]]
=== Future Mode: Emulation Mode (not for RVM22/RVA22)

Emulation mode is the simplest. It doesn't have a jump table or vector table, so allow a minimal hardware implementation.
It relies on the values in temporary registers not being maintained across function calls.

_There are concerns about overwriting the temporary registers so this may be rejected_

No illegal instruction exceptions are possible in emulation mode.

==== Pseudo-code for emulation mode

[source,sourceCode,text]
----
t4 = next_PC; #PC+2 for c.tbljal, PC+4 for tbljal
t5 = n;       #immediate operand
J xTBLJALVEC.base
----

=== Diagram for all table jump modes

.all three modes
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump4.PNG[all three modes]

[#pushpoppopret]
== PUSH/POP/POPRET

`PUSH/POP/POPRET` are used to reduce the size of function prologues and epilogues.

=== A brief example from Zephyr

This example gives a nice illustration of what `PUSH/POP/POPRET` are trying to achieve.

[source,sourceCode,text]
----
from subsys/bluetooth/controller/crypto/crypto.c
int bt_rand(void *buf, size_t len)
{
        return lll_csrand_get(buf, len);
}
----

compiles with GCC10 to:

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	1141                	addi	sp,sp,-16	;#PUSH(1)
2040545a:	c04a                	sw	s2,0(sp)	;#PUSH(2)
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
20405464:	c422                	sw	s0,8(sp)	;#PUSH(3)
20405466:	c226                	sw	s1,4(sp)	;#PUSH(4)
20405468:	c606                	sw	ra,12(sp)	;#PUSH(5)
2040546a:	842a                	mv	s0,a0		;#PUSH(6)
2040546c:	84ae                	mv	s1,a1		;#PUSH(7)
<function body>
20405494:	4501                	li	a0,0		;#POPRET(1)
20405496:	40b2                	lw	ra,12(sp)	;#POPRET(2)
20405498:	4422                	lw	s0,8(sp)	;#POPRET(3)
2040549a:	4492                	lw	s1,4(sp)	;#POPRET(4)
2040549c:	4902                	lw	s2,0(sp)	;#POPRET(5)
2040549e:	0141                	addi	sp,sp,16	;#POPRET(6)
204054a0:	8082                	ret			;#POPRET(7)
----

with the GCC option `-msave-restore` the output is the following:

[source,sourceCode,text]
----
204089ac <bt_rand>:
204089ac:       f97f72ef                jal     t0,20400942 <__riscv_save_0>	;#PUSH(1)
204089b0:       70001937                lui     s2,0x70001
204089b4:       ac090613                addi    a2,s2,-1344 # 70000ac0 <prng>
204089b8:       842a                    mv      s0,a0	;#PUSH(2)
204089ba:       84ae                    mv      s1,a1	;#PUSH(3)
<function_body>
204089e2:       4501                    li      a0,0	;#POPRET(1)
204089e4:       f83f706f                j       20400966 <__riscv_restore_0>	;#POPRET(2)
----

with `PUSH/POPRET` this reduces to

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	<16-bit>                push	 {ra,s0-s2},{a0-a1},-16
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
<function body>
20405496:	<16-bit>                popret	 {ra,s0-s2},{0} 16

----

The prologue / epilogue reduce from 28-bytes in the original code, to 14-bytes with `-msave-restore`, and to to 8-bytes with `PUSH/POP`, which will also improve the performance.
  
[NOTE]

  The calls to `<riscv_save_0>/<riscv_restore_0>` become 64-bit when the target functions are out of the ±1MB range, increasing the prologue/epilogue size to 22-bytes.

=== Assembler Syntax

. The `PUSH` instruction 
** pushes(stores)  the registers specified in `reg_list` to the stack
** if `areg_list` is included, moves the registers in the `areg_list` into `s` registers
** adjusts the stack pointer by the `stack_adjustment` 

. The `POP` instruction 
** pops(loads) the registers in `reg_list` from the stack
** if `ret_val` is included, moves the specified value into `a0` as the return value
** adjusts the stack pointer by the `stack_adjustment`.

. `POPRET` has the same behaviour as `POP`, followed by `RET`. It uses `rsreg_list` as the `ra` register must be included.

32-bit and 16-bit forms of all instructions are available, the assembler should choose the 16-bit form if the parameters permit.

The registers in `reg_list` and `areg_list` are comma separated lists and must not be empty.

[source,sourceCode,text]
----
<sreg_list>  ::= <ra> "," <sreg_range> | <ra> | <sreg_range>
<rsreg_list> ::= <ra> "," <sreg_range> | <ra>
<areg_list>  ::= <areg_range>
<ret_val>    ::= s0 | 0 | 1
<sreg_range> ::= <s0>  | <s0-sN>   (where N is in the range [1, 11])
<areg_range> ::= <a0>  | <a0-aP>   (where P is in the range [1, 2])
<reg_list>   ::= <sreg_list>  | <rsreg_list>

//legal syntax

push         {<sreg_list>},  [{<areg_list>}],-stack_adjustment
pop          {<sreg_list>},  [{ret_val},]    stack_adjustment
popret       {<rsreg_list>}, [{ret_val},]    stack_adjustment //popret must include ra

----

For the 16-bit encodings

. In `reg_list`
.. `ra` must be included
.. `s0-sN` may be included, valid values of `N` are 0,1,2,3,5,8,11
. for `pop, ret_val` must not be included 
. for `popret, ret_val` may be included - and can only be set to `0`
.. rationale: about 27% of functions which infer `popret` issue `li a0, 0` first
. for `push` only specific combinations of `areg_list` and `sreg_list` are permitted
.. `if sreg_list={ra}:       areg_list={}`
.. `if sreg_list={ra,s0}:    areg_list={a0}`
.. `if sreg_list={ra,s0-sN}: areg_list={a0-a1} where N=1,2,3`
.. `if sreg_list={ra,s0-sN}: areg_list={a0-a2} where N=5,8,11`
. The `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..7)*16-bytes.

Examples of valid 16-bit encodings for RV32 or RV64:

[source,sourceCode,text]
----

push   {ra},                 -16; //store ra;                                      decrement sp by 16
push   {ra,s0},    {a0},     -32; //store ra,s0;     mv s0,a0;                     decrement sp by 32
push   {ra,s0-s3}, {a0-a1},  -96; //store ra,s0-s3;  mv s0,a0; mv s1,a1;           decrement sp by 96
push   {ra,s0-s11},{a0-a2}, -128; //store ra,s0-s11; mv s0,a0; mv s1,a1; mv s2,a2; decrement sp by 128

pop    {ra},        16;  //load  ra;        increment sp by 16
popret {ra},        16;  //load  ra;        increment sp by 16; jump to ra

pop    {ra,s0},     32;  //load  ra,s0;     increment sp by 32
popret {ra,s0},{s0},32;  //load  ra,s0;     increment sp by 32; mv a0, s0; jump to ra

pop    {ra,s0-s3},  96;  //load  ra,s0-s3;  increment sp by 96
popret {ra,s0-s3},  96;  //load  ra,s0-s3;  increment sp by 96; jump to ra

pop    {ra,s0-s11}, 128; //load  ra,s0-s11; increment sp by 128
popret {ra,s0-s11}, 128; //load  ra,s0-s11; increment sp by 128; jump to ra

----
[NOTE]
  To save encoding space, for `c.push`, `areg_list` is automatically determined from the `reg_list` value based on analysing usage in the benchmark suite .


[NOTE]
  To save encoding space some opcodes do not allow the full range of `spimm` or `reg_list` which reduces the possible `stack adjustment` range further, see <<#pushpoppopret16bitencodings>>

For the 32-bit encodings

. The `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..15)*16-bytes.
. `areg_list` must not overwrite an `s` register which has not been saved. For example:
.. `push {ra,s0}, {a0}, -32` _is_ valid - it saves `ra`, saves `s0` and the moves `a0` into `s0`.
.. `push {ra,s0}, {a0-a1}, -32` _is not_ valid - it saves `ra`, saves `s0` and then moves `a0-a1` into `s0-s1`. Therefore it overwrites `s1` which has *not* been saved. This case will cause an illegal instruction exception.

For example

. `push   {ra,s0-s2}, {a0-a1}, -64` can use a 16-bit encoding
. `push   {s0-s2},    {a0-a1}, -64` must use a 32-bit encoding as `ra` is not in the register list
. `push   {ra,s0-s2}, {a0-a1}, -256` must use a 32-bit encoding as the `stack_adjustment` is out of range
. `push   {ra,s0-s2},          -32` must use a 32-bit encoding as `sreg_list` requires `areg_list={a0-a1}` for the 16-bit encoding
. `pop    {ra,s0-s2}, {s0},     32` must use a 32-bit encoding as `ret_val` is specified
. `popret {ra,s0-s2}, {s0},     32` must use a 32-bit encoding as `c.popret` only supports `0` as the `ret_val` value

To be a legal encoding:

1.  The stack adjustment must be negative for all `PUSH` variants and positive for all `POP/POPRET` variants
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register lists must be valid (see above)
4.  For `PUSH`, `areg_list` must not overwrite an `s` register which is not listed in `reg_list`
5.  For `POPRET`, `reg_list` must include `ra`
6.  For `POP` and `POPRET`, `areg_list` must not be included 


=== Determining XLEN to decode and execute the instructions

The width of `x` registers in the register list depends upon XLEN and so `misa.MXL`. From the ELF file header, XLEN is determined by the following flags:

* ELFCLASS64 for RV64
* ELFCLASS32 for RV32 

[NOTE]

  I don't think there's an ELFCLASS128 for RV128

If using a debugger then `misa.MXL` can be read, if XLEN is not known for the core.

Follow this link for details of the https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#file-header[ELF file header]

=== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

==== PUSH Pseudo-code

The `PUSH` instruction store the set of registers from `reg_list` to consecutive memory locations, and decrements the stack pointer.
The pseudo-code uses assembly inserts so that it can use `sw/sd` etc.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])            {take_illegal_instruction_exception();}
if (rcount>12)          {take_illegal_instruction_exception();}
if (rcount>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw ra, 0(addr)");
    8:  asm("sd ra, 0(addr)");
    16: asm("sq ra, 0(addr)");
  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw s[i], 0(addr)");
    8:  asm("sd s[i], 0(addr)");
    16: asm("sq s[i], 0(addr)");
  }
}
if (areg_list) {
  for (i in areg_list) {
    asm("mv s[i], a[i]");}
  }
}
sp+=stack_adjustment; //decrement
----

==== POP/POPRET Pseudo-code

A `POP/POPRET` instruction loads the set of registers from `reg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `lw/ld/ret` etc.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])            {take_illegal_instruction_exception();}
if (rcount>12)          {take_illegal_instruction_exception();}
if (rcount>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw ra, 0(addr)");
    8:  asm("ld ra, 0(addr)");
    16: asm("lq ra, 0(addr)");

  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw s[i], 0(addr)");
    8:  asm("ld s[i], 0(addr)");
    16: asm("lq s[i], 0(addr)");
  }
}
if (ret_val) {
   switch(ret_val) {
      "s0": asm("mv a0, s0");
      "0":  asm("li a0, 0");
      "1":  asm("li a0, 1");
   }
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET") { 
   asm("ret");
}
----

[#pushpoppopret32bitencodings]
=== 32-bit Encodings

[NOTE]

  These encodings are provisional.

These instructions have no conflicts with other extensions, they use previously reserved encodings.

.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31:27              |26|25     |24 |23|22|21:20         |19:18|17:16|15 | 14:12   | 11:10 |9: 7      | 6 : 0 | instruction
2+|0000000         2+|00         2+|00   |mv          2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH
2+|0000000         2+|01         2+|00   |ret_val     2+|rcount     |ra | 010   2+| spimm             |1000011| POP
2+|0000000         2+|10         2+|00   |ret_val     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET
|=========================================================================================================================
  
[NOTE]
  `ra=1` for all `popret` encodings, it is not specified in the encoding
  Not all cases of `mv` and `rcount` are legal for `PUSH`, see below.


==== Illegal instructions

The following cases cause an illegal instruction exception for `PUSH/POP/POPRET`.

* `rcount>12` for `I` cores
* `rcount>2` for `E` cores

If `sp` is not 16-byte aligned then take an illegal instruction exception for `PUSH/POP/POPRET`.

The following cases cause an illegal instruction exception for `PUSH`.

* `rcount<1 && mv>0`
* `rcount<2 && mv>1`
* `rcount<3 && mv>2`

[#pushpoppopret16bitIencodings]
=== 16-bit Encodings

These instructions have no conflicts with other extensions, they use previously reserved encodings.

This specification is currently assuming that:

* {ra, s0-s1} map to the same X-registers in the UABI and EABI
* s2 is the highest numbered saved register in the EABI

If either of these assumptions are wrong I'll update the specification (I'm looking at https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[this document]).

If compiling/disassembling for the UABI, the instructions _without_ the .E suffix should be used.

If compiling/disassembling for the EABI, the instructions _with_ the .E suffix should be used.

Sometimes the .E form is a pseudo-instruction for the non .E form, e.g. C.POP {ra}, C.POP.E {ra} share an encoding.

Where the register list maps to different X registers a different encoding is required, for example for C.POP.E {ra, s0-s2}

It is possible for the EABI versions to be used on an I (32-register) core.  The use of EABI would need to be denoted in the ELF header so the the dissasembler and dynamic ELF loaders know how the ELF was compiled.

It is not possible to use the UABI versions on an E (16-register) core. In this case, for example C.POP {ra, s0-s2} would decode as an illegal isntruction.


[#proposed-16bit-encodingsI-1]
.PUSH/POP 16-bit encodings for I
[width="100%",options=header]
|===============================================================================
|15 |14 |13 |12 |11 |10  |9 |8  |7 |6   |5 |4 |3 |2           |1 |0 |instruction and register list
17+|`C.POP` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0  |0 2+|00         |0 |0 2+|00 | spimm[0] 2+| 00  |C.POP[.E] {ra}      
3+|100  |0  |0  |0  |0 2+|01         |0 |0 2+|00 | spimm[0] 2+| 00  |C.POP[.E] {ra, s0}  
3+|100  |0  |0  |0  |0 2+|10         |0 |0 2+|00 | spimm[0] 2+| 00  |C.POP[.E] {ra, s0-s1}
3+|100  |0  |0  |0  |0 2+|11         |0 |0 2+|00 | spimm[0] 2+| 00  |C.POP     {ra, s0-s2}
3+|100  |0  |0  |0  |1 2+|00         |0 |0 2+|00 | spimm[0] 2+| 00  |C.POP.E   {ra, s0-s2}
3+|100  |0  |0  |0  |1 2+|>00        |0 |0 3+|xxx           2+| 00  |*reserved*
3+|100  |0  |0  |0 3+|xxx            |0 |0 2+|!=00| x       2+| 00  |*reserved*
17+|`C.POPRET` and `C.POPRET.E`
3+|100  |0  |0  |0 3+|000          |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET[.E] {ra}      
3+|100  |0  |0  |0 3+|001          |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET[.E] {ra, s0}  
3+|100  |0  |0  |0 3+|010          |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET[.E] {ra, s0-s1}
3+|100  |0  |0  |0 3+|011          |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET     {ra, s0-s2}
3+|100  |0  |0  |0 3+|100          |ret0|1 |0 2+|spimm[1:0] 2+| 00  |C.POPRET     {ra, s0-s3}
3+|100  |0  |0  |0 3+|101          |ret0|1 |0 2+|spimm[1:0] 2+| 00  |C.POPRET     {ra, s0-s5}
3+|100  |0  |0  |0 3+|110          |ret0|1 |0 2+|spimm[1:0] 2+| 00  |C.POPRET     {ra, s0-s8}
3+|100  |0  |0  |0 3+|111          |ret0|1 |0 2+|spimm[1:0] 2+| 00  |C.POPRET     {ra, s0-s11}
3+|100  |0  |0  |0 3+|100          |ret0|1 |1 2+|spimm[1:0] 2+| 00  |C.POPRET.E   {ra, s0-s2}
3+|100  |0  |0  |0 3+|101          |ret0|1 |1 2+|spimm[1:0] 2+| 00  |C.POPRET.E   {ra, s0-s3}
3+|100  |0  |0  |0 3+|110          |ret0|1 |1 2+|spimm[1:0] 2+| 00  |C.POPRET.E   {ra, s0-s4}
3+|100  |0  |0  |0 3+|111          |ret0|1 |1 2+|spimm[1:0] 2+| 00  |*reserved*
17+|`C.PUSH` and `C.PUSH.E`
3+|100  |0  |0  |0 3+|000          |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH[.E] {ra}   
3+|100  |0  |0  |0 3+|001          |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH[.E] {ra, s0}
3+|100  |0  |0  |0 3+|010          |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH[.E] {ra, s0-s1}
3+|100  |0  |0  |0 3+|011          |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH     {ra, s0-s2}
3+|100  |0  |0  |0 3+|100          |1 |0   |0 2+|spimm[1:0] 2+| 00  |C.PUSH     {ra, s0-s3}
3+|100  |0  |0  |0 3+|101          |1 |0   |0 2+|spimm[1:0] 2+| 00  |C.PUSH     {ra, s0-s5}
3+|100  |0  |0  |0 3+|110          |1 |0   |0 2+|spimm[1:0] 2+| 00  |C.PUSH     {ra, s0-s8}
3+|100  |0  |0  |0 3+|111          |1 |0   |0 2+|spimm[1:0] 2+| 00  |C.PUSH     {ra, s0-s11}
3+|100  |0  |0  |0 3+|100          |1 |0   |1 2+|spimm[1:0] 2+| 00  |C.PUSH.E   {ra, s0-s2}
3+|100  |0  |0  |0 3+|101          |1 |0   |1 2+|spimm[1:0] 2+| 00  |C.PUSH.E   {ra, s0-s3}
3+|100  |0  |0  |0 3+|110          |1 |0   |1 2+|spimm[1:0] 2+| 00  |C.PUSH.E   {ra, s0-s4}
3+|100  |0  |0  |0 3+|111          |1 |0   |1 2+|xx         2+| 00  |*reserved*
|===============================================================================

  * For `C.POPRET`, `ret_val[0]=ret0` as specified in the encoding, `ret_val[1]=0`. 
  * For `C.POP` `ret_val[1:0]=0`.

[dissassembleUABIEABI_POP]
.C.POP[.E] behaviour for different ABIs and cores
[width="100%",options=header]
|===============================================================================
| Instruction           | UABI dissasembly | EABI dissasembly      | RVI-core behaviour   | RVE-core behaviour
5+| These forms of `C.POP.E` are pseudo-instructions for `C.POP` as the `X` register lists match
| C.POP[.E] {ra}        | C.POP {ra}       | C.POP.E {ra}          | POP {x1}             | same as RVI
| C.POP[.E] {ra, s0}    | C.POP {ra, s0}   | C.POP.E {ra, s0}      | POP {x1, x8}         | same as RVI
| C.POP[.E] {ra, s0}    | C.POP {ra, s0}   | C.POP.E {ra, s0}      | POP {x1, x8}         | same as RVI
| C.POP[.E] {ra, s0-s1} | C.POP {ra, s0-s1}| C.POP.E {ra, s0-s1}   | POP {x1, x8-x9}      | same as RVI
5+| This encoding of `C.POP` has an out-of-range `X` register for RVE
| C.POP     {ra, s0-s2} | C.POP {ra, s0-s2}| *reserved*            | POP {x1, x8-x9, x18} | *illegal instruction*
5+| This encoding of `C.POP.E` has a different `S` to `X` register mapping from the UABI
| C.POP.E   {ra, s0-s2} | *reserved*       | C.POP.E {ra, s0-s2}   | POP {x1, x8-x9, x14} | same as RVI
|===============================================================================


[dissassembleUABIEABI_POPRET]
.C.POPRET[.E] behaviour for different ABIs and cores
[width="100%",options=header]
|===============================================================================
| Instruction           | UABI dissasembly | EABI dissasembly      | RVI-core behaviour   | RVE-core behaviour
5+| These forms of `C.POPRET.E` are pseudo-instructions for `C.POPRET` as the `X` register lists match
| C.POPRET[.E] {ra}        | C.POPRET {ra}       | C.POPRET.E {ra}          | POPRET {x1}| same as RVI
| C.POPRET[.E] {ra, s0}    | C.POPRET {ra, s0}   | C.POPRET.E {ra, s0}      | POPRET {x1, x8}| same as RVI
| C.POPRET[.E] {ra, s0-s1} | C.POPRET {ra, s0-s1}| C.POPRET.E {ra, s0-s1}   | POPRET {x1, x8-x9}| same as RVI
5+| These encodings of `C.POPRET` have out-of-range `X` registers for RVE
| C.POPRET     {ra, s0-s2} | C.POPRET {ra, s0-s2}| *reserved*               | POPRET {x1, x8-x9, x18} | *illegal instruction*
| C.POPRET     {ra, s0-s3} | C.POPRET {ra, s0-s3}| *reserved*               | POPRET {x1, x8-x9, x18-x19} | *illegal instruction*
| C.POPRET     {ra, s0-s5} | C.POPRET {ra, s0-s5}| *reserved*               | POPRET {x1, x8-x9, x18-x21} | *illegal instruction*
| C.POPRET     {ra, s0-s8} | C.POPRET {ra, s0-s8}| *reserved*               | POPRET {x1, x8-x9, x18-x24} | *illegal instruction*
| C.POPRET     {ra, s0-s11}| C.POPRET {ra, s0-s11}|*reserved*               | POPRET {x1, x8-x9, x18-x27} | *illegal instruction*
5+| These encodings of `C.POPRET.E` have different `S` to `X` register mappings from the UABI
| C.POPRET.E   {ra, s0-s2} | *reserved*          | C.POPRET.E {ra, s0-s2}   | POPRET {x1, x8-x9, x14} | same as RVI
| C.POPRET.E   {ra, s0-s3} | *reserved*          | C.POPRET.E {ra, s0-s3}   | POPRET {x1, x8-x9, x14, x6} | same as RVI
| C.POPRET.E   {ra, s0-s4} | *reserved*          | C.POPRET.E {ra, s0-s4}   | POPRET {x1, x8-x9, x14, x6-x7} | same as RVI
|===============================================================================

[dissassembleUABIEABI_PUSH]
.C.PUSH[.E] behaviour for different ABIs and cores
[width="100%",options=header]
|===============================================================================
| Instruction           | UABI dissasembly | EABI dissasembly      | RVI-core behaviour   | RVE-core behaviour
5+| These forms of `C.POPRET.E` are pseudo-instructions for `C.POPRET` as the `X` register lists match
| C.PUSH[.E] {ra}        | C.PUSH {ra}       | C.PUSH.E {ra}            | PUSH {x1}| same as RVI
| C.PUSH[.E] {ra, s0}    | C.PUSH {ra, s0}   | C.PUSH.E {ra, s0}        | PUSH {x1, x8}| same as RVI
| C.PUSH[.E] {ra, s0-s1} | C.PUSH {ra, s0-s1}| C.PUSH.E {ra, s0-s1}     | PUSH {x1, x8-x9}| same as RVI
5+| These encodings of `C.POPRET` have out-of-range `X` registers for RVE
| C.PUSH     {ra, s0-s2} | C.PUSH {ra, s0-s2}| *reserved*               | PUSH {x1, x8-x9, x18} | *illegal instruction*
| C.PUSH     {ra, s0-s3} | C.PUSH {ra, s0-s3}| *reserved*               | PUSH {x1, x8-x9, x18-x19} | *illegal instruction*
| C.PUSH     {ra, s0-s5} | C.PUSH {ra, s0-s5}| *reserved*               | PUSH {x1, x8-x9, x18-x21} | *illegal instruction*
| C.PUSH     {ra, s0-s8} | C.PUSH {ra, s0-s8}| *reserved*               | PUSH {x1, x8-x9, x18-x24} | *illegal instruction*
| C.PUSH     {ra, s0-s11}| C.PUSH {ra, s0-s11}|*reserved*               | PUSH {x1, x8-x9, x18-x27} | *illegal instruction*
5+| These encodings of `C.POPRET.E` have different `S` to `X` register mappings from the UABI
| C.PUSH.E   {ra, s0-s2} | *reserved*          | C.PUSH.E {ra, s0-s2}   | PUSH {x1, x8-x9, x14} | same as RVI
| C.PUSH.E   {ra, s0-s3} | *reserved*          | C.PUSH.E {ra, s0-s3}   | PUSH {x1, x8-x9, x14, x6} | same as RVI
| C.PUSH.E   {ra, s0-s4} | *reserved*          | C.PUSH.E {ra, s0-s4}   | PUSH {x1, x8-x9, x14, x6-x7} | same as RVI
|===============================================================================

[NOTE]

  RVI cores can support either ABI, so will execute all of the instructions. The RVI core does not know which ABI is in use. The intention is that when disassembling for the UABI `C.PUSH/C.POP/C.POPRET` will be used, and when disassembling for the EABI `C.PUSH.E/C.POP.E/C.POPRET.E` will be used.

=== Encoding Fields

[#spimm]
==== `spimm` encoding field

The `stack_adjustment` field in the assembly syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

total_register_bytes = number_of_registers_in_reg_list * XLEN/8 + padding + number_of_registers_in_freg_list * FLEN/8;
stack_adjustment = Align16(total_register_bytes) + 16*spimm;

The 16-bit encoding allows up to 7 additional 16-byte blocks (as `spimm` has up to 3-bits), and the 32-bit encoding allows up to 31.

==== mv, ret_val, ra, rcount for the 32-bit encodings

The registers in the `reg_list` are controlled by these fields

Note that `mv` and `ret_val` are in the same location in the encoding.

[#32bit-mv]
.`mv` values for the 32-bit encodings for `PUSH`
[options="header"]
|=========================================
|mv      |ABI names  
| 0      |none        
| 1      |a0
| 2      |a0-a1
| 3      |a0-a2
|=========================================

[#32bit-ret_val]
.`ret_val` values for the 32-bit encodings for `POP, POPRET`
[options="header"]
|=========================================
|return value      |ABI names  
| 0      |none (don't set a0)        
| 1      |a0=0
| 2      |a0=1
| 3      |a0=s0
|=========================================

[#32bit-ra]
.`ra` values for the 32-bit encodings 
[options="header"]
|=========================================
|ra      |ABI names  
| 0      |none        
| 1      |ra
|=========================================

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
2+|these values could be used for interrupt save/restore
| 13-15  | *reserved*
|==========================

==== `rcount`, `ret_val` for the 16-bit encodings

[#rcount-table]
.`rcount` values for the 16-bit encodings
[options="header",width=100%]
|============================
|rcount| ABI names
|0     |ra
|1     |ra, s0
|2     |ra, s0-s1
|3     |ra, s0-s2
2+|Following options for `C.PUSH/C.POPRET` only
|4     |ra, s0-s3
|5     |ra, s0-s5
|6     |ra, s0-s8
|7     |ra, s0-s11
|============================

`ret_val` is as specified in <<32bit-ret_val>>. Note that:

* `C.POPRET` allows bit 0 to vary, bit 1 is always 0
* `C.POP` always has `ret_val=0` to save encoding space

[#fault-handling]
=== Fault handling

The sequence required to execute the instruction may be interrupted, or may not be able to start execution for several reasons.

* virtual memory page fault or PMP fault
** these can be detected before execution, or during execution if the memory addresses cross a page/PMP boundary
* watchpoint trigger
** these can be detected before execution, or during execution depending on the trigger type (load data triggers require the sequence to have started executing, for example)
* external debug halt
** the halt can treat the whole sequence atomically, or interrupt mid sequence (implementation defined)
* debug halt caused by a trigger
** same comment as watchpoint trigger above
* load access fault
** these are detected while the sequence is executing
* store access fault (precise or imprecise)
** these may be detected while the sequence is executing, or afterwards if imprecise
* interrupts
** these may arrive at any time. An implementation can choose whether to interrupt the sequence or not.

Because some faults can only be detected during the sequence the core implementation is able to recover from the fault and re-execute the sequence. This may involve executing some or all of the loads and stores from the sequence multiple times before the sequence completes (as multiple faults or multiple interrupts are possible).

Therefore correct execution requires that `sp` refers to idempotent memory (see <<non-idem-mem>> for non-idempotent handling)

[#software-view]
=== Software view of execution

==== Software view of `PUSH` sequence

From a software perspective the `PUSH` sequence appears as:

* A sequence of stores writing a contiguous block of memory. Any of the bytes may be written multiple times.
* A stack pointer adjustment

Because the memory is idempotent and the stores are non-overlapping, they may be reordered, grouped into larger accesses, split into smaller access or any combination of these.

If an implementation allows interrupts during the sequence, and the interrupt handler uses `sp` to allocate stack memory, then any stores which were executed before the interrupt maybe be overwritten by the handler. This is safe because the memory is idempotent and the stores will be re-executed once the handler completes.

The stack pointer adjustment must only be committed once it is certain that all of the stores will complete within triggerring any precise faults (stores may return imprecise bus errors which are received after the instruction has completed execution).

For example:

[source,sourceCode,text]
----
c.push  {ra, s0-s5},{a0-a2}, -64
----

Appears to software as:

[source,sourceCode,text]
----
# any bytes from SP-1 to SP-28 may be written multiple times before the instruction completes
sw  ra, -4(sp);   
sw  s0, -8(sp);   
sw  s1,-12(sp);   
sw  s2,-16(sp);  
sw  s3,-20(sp);   
sw  s4,-24(sp);   
sw  s5,-28(sp);   

# these must only execute once, and will only execute after all stores complete sucessfully
mv s0, a0;
mv s1, a1;
mv s2, a2;
addi sp, sp, -64; 
----

==== Software view of `POP/POPRET` sequence

From a software perspective the `POP/POPRET` sequence appears as:

* A sequence of loads, any of which may be executed multiple times
* A stack pointer adjustment
* An optional `RET`

If an implementation allows interrupts during the sequence, then any loads which were executed before the interrupt may update architectural state. The loads will be re-executed once the handler completes, so the values will be overwritten. Therefore it is permitted for an implementation to update some of the destination registers before taking the interrupt or other fault.

The register moves and stack pointer adjustment must only be committed once it is certain that all of the loads will complete successfully.

For `POPRET` once the stack pointer adjustment has been committed the `RET` must execute.

For example:

[source,sourceCode,text]
----
popret   {ra, s0-s3}, {s1}, 32 ; 
----

Appears to software as:

[source,sourceCode,text]
----
# any or all of these load instructions may execute multiple times
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);
lw   s2, 16(sp);
lw   s3, 12(sp);

# must only execute once, will only execute after all loads complete successfully
# all instructions must execute atomically
mv a0, s1
addi sp, sp, 32;
ret;
----
[[non-idem-mem]]
==== Non-idempotent memory

An implementation may have a requirement to issue `PUSH/POP/POPRET` to non-idempotent memory. 

==== Error detection

If the core implementation does not have a requirement to support `PUSH/POP/POPRET` to non-idempotent memories, and the core can use a PMA to detect that the memory is non-idempotent, then take a load(`POP/POPRET`) or store (`PUSH`) access fault exception.

==== Non-idempotent support

It is possible to support non-idempotent memory. One reason is to re-use `PUSH/POP` as a restricted form of a load/store multiple instruction to a peripheral (see <<ldstm>>), as there is no generic load/store multiple instruction currently in the RISC-V ISA. If load/store multiple is supported in the future then it should support non-idempotent memory.

Non-idempotent memory support requires additional restrictions:

. Do not allow interrupts during execution
. Do not allow external debug halt during execution
. Detect any virtual memory page faults or PMP faults for the whole instruction before starting execution (instead of during the sequence)
. Do not split / merge / reorder the generated memory accesses

It is possible that one of the following will still occur during execution:

. Watchpoint trigger
. Load/store access fault

In these cases the core will jump to the debug or exception handler. If execution is required to continue afterwards (so the event is not fatal to the code execution), then the handler is required to do so in software. 

By following these rules memory accesses will only ever be issued once, and in the order listed in the pseudo-code.

It is possible for implementations to follow these restricted rules and to safely access both types of memory. It is also possible for an implementation to use PMAs to detect the memory type and apply different rules, such as only allowing interrupts if accessing cacheable memory, for example.

=== Toolchain implementation

`PUSH/POP/POPRET` can be generated by the compiler, but can also be added as an optimisation in the linker. If they are inferred at link time then they can also be used to optimise precompiled library code. This means that the libraries can be shipped without these instructions, but platforms which implement them can still benefit from the code-size saving.

=== Assembly examples

[#push-example-1]
==== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, {a0-a2}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  ra, -4(sp);
sw  s0, -8(sp); 
sw  s1, -12(sp);
sw  s2, -16(sp); 
sw  s3, -20(sp);
sw  s4, -24(sp); 
sw  s5, -28(sp);
mv  s0, a0;
mv  s1, a1;
mv  s2, a2;
addi sp, sp, -64;
----

==== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, {a0-a1} -32
----

Encoding: rcount=2, spimm=1

Equivalent sequence:

[source,sourceCode,text]
----
sw  ra, -4(sp);
sw  s0, -8(sp); 
sw  s1, -12(sp);
mv s0, a0;
mv s1, a1;
addi sp, sp, -32;
----

==== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   ra, 156(sp);
lw   s0, 152(sp);  
lw   s1, 148(sp);  
lw   s2, 144(sp);  
lw   s3, 140(sp);  
lw   s4, 136(sp);  
lw   s5, 132(sp);  
lw   s6, 128(sp);  
lw   s7, 124(sp);  
lw   s8, 120(sp);  
addi sp, sp, 160
----

[#popret-example-1]
==== C.POPRET RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7},{s0}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   ra, 156(sp);
lw   s0, 152(sp);  
lw   s1, 148(sp);  
lw   s2, 144(sp);  
lw   s3, 140(sp);  
lw   s4, 136(sp);  
lw   s5, 132(sp);  
lw   s6, 128(sp);  
lw   s7, 124(sp);  
lw   s8, 120(sp);  
addi sp, sp, 160;
mv a0, s0;
ret
----

==== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {ra, s0-s9}, {s0}, 256
----

Encoding: ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 252(sp);
lw   s0, 248(sp);
lw   s1, 244(sp);  
lw   s2, 240(sp)
lw   s3, 236(sp);  
lw   s4, 232(sp);
lw   s5, 228(sp);  
lw   s6, 224(sp)
lw   s7, 220(sp);  
lw   s8, 216(sp);
lw   s9, 212(sp); 
mv   a0, s0
addi sp, sp, 256
----

[[ldstm]]
=== Appendix: Usage as load/store-multiple

`PUSH/POP` encodings can be reused as generic load/store multiple instructions. For example:

[source,sourceCode,text]
----

lui t0, 0xffff
sw  s5, 4c(t0)
sw  s4, 50(t0)
sw  s3, 54(t0)
sw  s2, 58(t0)
sw  s1, 5c(t0)
sw  s0, 60(t0)

----

Can be replaced by

[source,sourceCode,text]
----

lui t0, 0xffff
addi sp, t0, 64
push {s0-s5}, -64

----

This requires that  `sp` is saved before and restored after the sequence. Also `POP` can be used to replace the equivalent series of loads. 

Even though there is not much code-size saving once the `sp` save/restore code has been included, and the restricted memory layout targetted by the instructions, there may be a performance benefit to doing this for small embedded cores. A load/store-multiple sequence may be issued to the peripheral bus as a single burst instead of multiple single accesses which individually require arbitration. In some cases this can save one or more cycles per access as the arbiter remains locked to the core until the sequence has completed.

If the target memory is non-idempotent then see <<non-idem-mem>> for additional constraints.

= Verification notes

== Existing functionality

Many of the instructions are 16-bit encodings of existing 32-bit instructions, therefore the verification should be a simple extension to existing tests and coverage. Additionally, the instructions are all very simple.
. C.SEXT.B, C.SEXT.H, (C.SEXT.W is a pseudo-instruction)
. C.ZEXT.B, C.ZEXT.H, C.ZEXT.W
. C.MUL, C.NOT, C.NEG
. C.LBU, C.LHU, C.SB, C.SH

== Simple extensions to existing functionality

These instructions are extremely similar to existing instructions, so the verification tests and coverage should be a simple extension from existing tests and coverage:

. BEQI, BNEI
.. these are immediate forms of BEQ and BNE, they compare a register value against an immediate instead of two register values
. LWGP, LWTP
.. these have the same functionality as LW, but the base register is explicitly GP or TP and the immediate offset range is larger
. SWGP, SWTP
.. these have the same functionality as SW, but the base register is explicitly GP or TP and the immediate offset range is larger
. MULI, MULIW
.. same as MUL, MULW with an immediate operand, note that the register specifiers are only 3-bit (x8-x15)

== New arithmetic functionality

MULIADD[W], ADDIADD[W] are different because they have two register sources and an immediate source. They are all the fused version of two or three instructions. 

`MULIADD` is equivalent to two or three fused instructions:

[source,sourceCode,text]
----
muliadd s0, s1, s2, 32
----

is equivalant to

[source,sourceCode,text]
----
muli s0, s2, 32
add  s0, s0, s1
----

or without using any Zce instructions:

[source,sourceCode,text]
----
li  s0, 32
mul s0, s0, s2
add s0, s0, s1
----

`ADDIADD` is equivalent to a fused version of two instructions:

[source,sourceCode,text]
----
addiadd s0, s1, s2, 32
----

is equivalent to:

[source,sourceCode,text]
----
addi s0, s2, 32
add  s0, s0, s1
----

Therefore the coverage is the same as the combined covergroups of the set of two or three sequential instructions, covering all combinations which are possible within the fused set for the legal set of operands to `MULIADD` and `ADDIADD`. Because of the 3-bit register specifiers the coverage space is smaller than you might imagine, and additionally the immediate range is smaller than the of the expanded sequence.

== New branch functionality

`DECBGEZ` and `C.DECBGEZ` are also fused versions of two instructions:

[source,sourceCode,text]
----
decbgez  s2, 1, -48
----

is equivalent to:

[source,sourceCode,text]
----
addi s2, s2, -1
bgez s2, -48
----

Therefore the coverage is the same as for `ADDI/BGEZ` combined, noting the limited range of subtraction values (1,2,4,8) and the range of the branch offset (especially for `C.DECBGEZ`).

== Sequenced functionality

`PUSH/POP/POPRET` execute a sequence of micro-ops to execute the whole instruction. As a result they are considerably more complex to verify than the other instructions.

=== Cover all possible sets of operands

`mv, rcount, ra, spimm` are all fields in the encoding.

[#32pushpopsourcecoverage]
.Coverage for PUSH/POP/POPRET source operands
[options="header",width=100%]
|==============================================================================
|Instruction|Variables                                        | Coverage bins
| PUSH (`mv`=0) | `rcount`(0 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 416
| PUSH (`mv`=1) | `rcount`(1 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 384
| PUSH (`mv`=2) | `rcount`(2 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 352
| PUSH (`mv`=3) | `rcount`(3 to 12) x `ra` (0 to 1) x `spimm` (0 to 15) | 288
| POP         | `rcount`(0 to 12) x `ret_val` (0 to 3) x `ra` (0 to 1) x `spimm` (0 to 15) | 1664
| POPRET      | `rcount`(0 to 12) x `ret_val` (0 to 3) x `spimm` (0 to 15) | 834
|==============================================================================

The 16-bit encodings have ffar ewer coverage bins:

[#16pushpopsourcecoverage]
.Coverage for C.PUSH/C.POP/C.POPRET source operands
[options="header",width=100%]
|==============================================================================
|Instruction|Variables                                        | Coverage bins
| C.PUSH      | `rcount`(0 to 7) x `spimm` (0 to 7) | 64
| C.POP       | `rcount`(0 to 3) x `spimm` (0 to 1) | 8
| C.POPRET    | `rcount`(0 to 7) x `ret_val` (0 to 1) x `spimm` (0 to 7) | 128
|==============================================================================

=== Test the functionality

Execution of every PUSH/POP/POPRET instruction must result in the same architectural state updates as executing the sequence that it expands into. For example:

[source,sourceCode,text]
----
popret   {ra, s0-s3}, {s1}, 32; 
----

causes identical architectural state updates to the expanded sequence:

[source,sourceCode,text]
----
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);
lw   s2, 16(sp);
lw   s3, 12(sp);
mv   a0, s1
addi sp, sp, 32;
ret
----

Therefore a suggestion is to generate pairs of tests, one with the expanded sequences and one with `PUSH/POP/POPRET`. Each test must give identical results, including having the same contents in the memory.

It is also possible to introduce

. interrupts
. debug triggers on the loads/stores in the sequence
. external debug halts
. load/store access faults due to bus errors or PMP faults
. load/store page faults

on the loads and stores in the sequence. `mepc` will be different between the two tests but `mcause` and `mtval` must match. Note that interrupts and external debug halts are asynchronous events, so to make the results from the two tests match then the handler must not (for example) count the number of interrupts taken.

Implementations may choose for the sequences to be uninterruptible, or to be interruptible and to restart after the `mret`. The overall result is the same - the sequence will eventually complete and correctly update the architectural state, providing any debug triggers are disabled in the handler before resuming execution (so they don't trigger again)

== Table jump, jump table mode only

Table jump is quite simple architecturally. 

`tbljal #n;` references memory address `m = xTBLJALVEC + n * XLEN/8`

The core to jump to address `m`, and link to the register referenced by bits[1:0] of the data at address `m`, including the illegal case where [1:0]=11

For verification we must show that the different link registers work and that the core jumps to the correct location each time.

= Rejected and postponed instructions

== Not benchmarked: PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]

Please read <<pushpoppopret>> before reading this section.

These instructions are variants of `PUSH/POP/POPRET` which also allow `F` registers to be saved/restored.

=== Assembler Syntax

These instructions require a register list including `fs` registers.

[source,sourceCode,text]
----
<fsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range> | <sreg_range> "," <freg_range> | <freg_range>
<rfsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range>
<freg_range> ::= <fs0> | <fs0-fsM> (valid values of M are 1,2,3,5,8,11)

//legal syntax

push.[fdq]   {<fsreg_list>},     -stack_adjustment
pop.[fdq]    {<fsreg_list>},      stack_adjustment
popret.[fdq] {<rfsreg_list>},     stack_adjustment //popret must include ra

----

To be a legal encoding:

1.  The stack adjustment must be negative for `PUSH.[FDQ]` and positive for `POP.[FDQ]/POPRET.[FDQ]`
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register lists must be valid (see above)
7.  For `POPRET.[FDQ]`, `rfsreg_list` must include `ra`

Additionally:

. If `sp` is not 16-byte aligned then take a load (`PUSH.[FDQ]`) or store (`POP.[FDQ]/POPRET.[FDQ]`) address misaligned exception, and do not issue any loads or stores.

[NOTE]
  When moving from loading or storing `x` registers to `f` registers there may be a gap as the registers may be different widths, and all registers must be aligned in memory

==== Rationale: why include the .[fdq] suffix

It is required to hard-code the length of the `f` registers in the opcode, and not just save/restore the whole register. We must allow code compiled for the F-extension
to run on a  core which supports D and possibly Q. We must also allow code compiled for the D-extension to run on a core which supports Q.

If we don't explicitly state the `f` register width and always store the whole register, then the registers will be stored at different addresses to the ones expected 
by the compiler. 

An alternative would be to use `misa.[FDQ]`
to directly control the behaviour and so set `misa.[DQ]=0` when running F code. Nothing else in the architecture requires this, so it seems unreasonable to 
add this requirement here. This approach also wouldn't work for `Z[FDQ]inx` cores as `misa.[FDQ]` are all hardwired to zero.

=== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

==== PUSH.[FDQ] Pseudo-code

The `PUSH.FDQ` instruction stores the set of registers from `fsreg_list` to consecutive memory locations, and decrements the stack pointer.
The pseudo-code uses assembly inserts so that it can use `fsw/fsd` etc.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])            {take_illegal_instruction_exception();}
if (rcount>12)          {take_illegal_instruction_exception();}
if (rcount>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw ra, 0(addr)");
    8:  asm("sd ra, 0(addr)");
    16: asm("sq ra, 0(addr)");
  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw s[i], 0(addr)");
    8:  asm("sd s[i], 0(addr)");
    16: asm("sq s[i], 0(addr)");
  }
}
switch (opcode) {
  //if FLEN > XLEN, then get the address back into alignment before saving the F registers
  "PUSH.D": while(addr% 8) {addr-=bytes;}
  "PUSH.Q": while(addr%16) {addr-=bytes;}
}
for(i in freg_list)  {
  switch (opcode) {
    "PUSH.F": {addr-= 4;asm("fsw fs[i], 0(addr)");}
    "PUSH.D": {addr-= 8;asm("fsd fs[i], 0(addr)");}
    "PUSH.Q": {addr-=16;asm("fsq fs[i], 0(addr)");}
  }
}
sp+=stack_adjustment; //decrement
----

==== POP.[FDQ]/POPRET/[FDQ] Pseudo-code

A `POP/POPRET` instruction loads the set of registers from `fsreg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `flw/fld/ret`.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])     {take_illegal_instruction_exception();}
if (rcount>12)          {take_illegal_instruction_exception();}
if (rcount>2 && misa.E) {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw ra, 0(addr)");
    8:  asm("ld ra, 0(addr)");
    16: asm("lq ra, 0(addr)");

  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw s[i], 0(addr)");
    8:  asm("ld s[i], 0(addr)");
    16: asm("lq s[i], 0(addr)");
  }
}
switch (opcode) {
  //if FLEN > XLEN, then get the address back into alignment before saving the F registers
  "POP.D", "POPRET.D": while(addr% 8) {addr-=bytes;}
  "POP.Q", "POPRET.Q": while(addr%16) {addr-=bytes;}
}
for(i in freg_list)  {
  switch (opcode) {
    "POP.F", "POPRET.F": {addr-= 4;asm("flw fs[i], 0(addr)");}
    "POP.D", "POPRET.D": {addr-= 8;asm("fld fs[i], 0(addr)");}
    "POP.Q", "POPRET.Q": {addr-=16;asm("flq fs[i], 0(addr)");}
  }
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET") { 
   asm("ret");
}
----

[#pushpoppopret32bitencodings]
=== 32-bit Encodings

[NOTE]

  These encodings are provisional.


.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31:27              |26|25     |24 |23|22|21:20         |19:18|17:16|15 | 14:12   | 11:10 |9: 7      | 6 : 0 | instruction
15+|`PUSH.[FDQ]` encodings
2+|0000000         2+|00         2+|01   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.F
2+|0000000         2+|00         2+|10   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.D
2+|0000000         2+|00         2+|11   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.Q
15+|`POP.[FDQ]` encodings
2+|0000000         2+|01         2+|01   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.F
2+|0000000         2+|01         2+|10   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.D
2+|0000000         2+|01         2+|11   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.Q
15+|`POPRET.[FDQ]` encodings
2+|0000000         2+|10         2+|01   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.F
2+|0000000         2+|10         2+|10   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.D
2+|0000000         2+|10         2+|11   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.Q
|=========================================================================================================================

[NOTE]
  bits [23:22] are the `fdq` field
  
[NOTE]
  `ra=1` for all `popret` encodings, it is not specified in the encoding


==== Illegal instructions 

The encoding takes the same behaviour as any floating point instruction if executed when disabled:

* if `frcount>0` and `misa.F==0`
* if `frcount>0` and `fdq==1` and `misa.D==0`
* if `frcount>0` and `fdq==2` and `misa.Q==0`

The following cases do not decode as `PUSH*/POP*/POPRET*`

* No registers are specified (`rcount, frcount` are both zero)
* `rcount>14`
* `fdq=3`
* `rcount==13` and `frcount>0` and the opcode doesn't have an `[fdq]` suffix

==== Rational: `rcount=13, frcount=0` saving all saved registers

The debian distro does save all `s` and `fs` registers on a few occasions, so there is a special encoding for this case. I saw no justification for saving all `fs` registers *without* saving all `s` registers. It seems useful to have a form which saves all saved registers.

The programmable range for `frcount` doesn't save many `fs` registers as `FPMark` only saves one or two and Debian rarely saves more than that.

=== Encoding Fields

See <<spimm>>.

[source,sourceCode,text]
----
//the padding calculation requires SP to be 16-byte aligned before executing the instruction
if (FLEN>XLEN && 
    number_of_registers_in_freg_list>0 && 
    number_of_registers_in_reg_list % (FLEN/XLEN)>0) {
  //need padding to ensure FLEN registers are aligned
  padding = (FLEN/XLEN - number_of_registers_in_reg_list % (FLEN/XLEN)) * XLEN/8;
} else {
  padding = 0
}
total_register_bytes = number_of_registers_in_reg_list * XLEN/8 + padding + number_of_registers_in_freg_list * FLEN/8;
stack_adjustment = Align16(total_register_bytes) + 16*spimm;
----

The bytes required for padding is simple - if FLEN==XLEN it's always zero. If FLEN=2*XLEN it is 0 or 4. RV32Q is more complex (see below) but this is an unlikely configuration.
`n` is an integer in the tables so `2n` is always even, `2n+1` is always odd.

[#padding-examples-RV32D]
.RV32D padding examples, XLEN=32, FLEN=64
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1   |4-bytes
|====================================

[#padding-examples-RV64Q]
.RV64Q padding examples, XLEN=64, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1  |4-bytes
|====================================

[#padding-examples-RV32Q]
.RV32Q padding examples, XLEN=32, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 4n     |none                     
| 4n+1   |4-bytes
| 4n+2   |8-bytes                     
| 4n+3   |12-bytes
|====================================

==== `mv, ret_val, ra, frcount, rcount` for the 32-bit encodings

The registers in the `reg_list` are controlled by these fields

Note that `frcount`, `mv` and `ret_val` are in the same location in the encoding.

[#32bit-frcount]
.`frcount` values for the 32-bit encodings for `PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]`
[options="header"]
|=====================
|frcount | ABI names  
| 0      |none or `fs0-fs11` (see `rcount=13`)
| 1      |fs0         
| 2      |fs0-fs1
| 3      |fs0-fs5
|=====================

See <<32bit-mv>> for `mv`.

See <<32bit-ra>> for `ra`.

[#32bit-frcount]
.`rcount` field values for PUSH.[FDQ]/POP.[FDQ]/POPRET.[FDQ]
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
2+|  `rcount=13` is valid if `frcount=0` for `[.fdq]` opcodes
| 13     |s0-s11,fs0-fs11
2+|these values could be used for interrupt save/restore
| 14-15  | *reserved*
|==========================

=== Assembly examples

==== PUSH.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, fdq=0, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sw  ra,   -4(sp);
sw  s0,   -8(sp); 
sw  s1,  -12(sp); 
sw  s2,  -16(sp); 
sw  s3,  -20(sp); 
sw  s4,  -24(sp); 
fsw fs0, -28(sp)
addi sp, sp, -64;
----

==== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, fdq=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sd  ra,  -8(sp);
sd  s0,  -16(sp); 
sd  s1,  -24(sp);
sd  s2,  -32(sp); 
sd  s3,  -40(sp);
sd  s4,  -48(sp); 
fsd fs0, -56(sp)
addi sp, sp, -64;
----

==== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {fs0-fs7}, -128
----

Encoding: rcount=0, frcount=12, fdq=2, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsd  fs0,  -8(sp);
fsd  fs1, -16(sp); 
fsd  fs2, -24(sp);
fsd  fs3, -32(sp); 
fsd  fs5, -40(sp); 
fsd  fs4, -48(sp);
fsd  fs6, -56(sp);
fsd  fs7, -64(sp); 
fsd  fs8, -72(sp); 
fsd  fs9, -80(sp); 
fsd  fs10,-88(sp); 
fsd  fs11,-96(sp); 
addi sp, sp, -128; 
----

== Benchmarking results too low

=== BGEUI, BLTUI

These allocate reserved encodings, and are similar to <<cmpimmbr>> but have lower value. It's possible that future use of these instructions will be found in later versions of `Zce`.

[rejected-cmpimmbr-32bit-encodings]
.Rejected 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26:25  |24   |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 010   2+| offset[5:1]       |1000011| BGEUI
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 011   2+| offset[5:1]       |1000011| BLTUI
|=========================================================================================================================

[#rejected-cmpimmbr-branch_semantics]
.Rejected compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BGEUI         | if (rs1>=~u~ zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BLTUI         | if (rs1<~u~  zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
bgeu a5, 1,offset # if(a5>= 1) branch_to(PC+offset) # unsigned comparison
bltu a5, 1,offset # if(a5<  1) branch_to(PC+offset) # unsigned comparison
----

=== C.LBUSP, C.LHUSP, C.SBSP, C.SHSP

These encodings require too much space for the benefit.

[#ldstbhsprel-16encodings]
.Rejected load/store half/byte SP relative 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
|================================================================================================

[#ldstbhsprel-semantics]
.Rejected load/store byte/half SP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh_sprel_32bit]
.load/store byte/half SP relative assembly syntax and 32-bit equivalent instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBUSP     | lbu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SBSP      | sb     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SHSP      | sh     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   
----

=== C.LSBNOT / C.LSBSET

The encodings are cheap, but the benefit is low.

[#dyadic-16encodings]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 110     2+| 00  | C.LSBNOT
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 111     2+| 00  | C.LSBSET
|=============================================================================================

[#monsemantics]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LSBNOT      | rd' = rd' XOR 1
| C.LSBSET      | rd' = rd' OR 1
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LSBNOT    | lsbnot rd             | all registers x8-x15, rd==rs1      | I-extension
|C.LSBKEEP   | lsbset rd             | all registers x8-x15, rd==rs1      | I-extension
|======================================================================================================


Assembly Examples

[source,sourceCode,text]
----
lsbnot a5;      # a5 = a5 XOR 1
----


= Future ideas

== Multiple move instructions

These instructions have some problems: 

. They either two register file write ports, or to be issued in a sequence.
. C.MVA* use ABI names when specifying source registers, which is efficient but non-standard
. There is no 32-bit encoding which makes sense, because each does the work of 2 x 16-bit encodings

Therefore ratification is delayed, and some more thought is needed.

=== C.MVP

The generic move uses standard x register numbers, and so it more standard than `C.MVA*S07`, however it takes a lot more encoding space. Both register pairs must be even/odd pairs (`rdp[0]=0, rsp[0]=0`) to reduce the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.

[#mvp-encoding]
.generic double move 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     3+|101    4+| rdp[4:1] 4+|  rsp[4:1]       2+| 00    | C.MVP
|================================================================================================

[#mvp-semantics]
.generic double move semantics
[width="100%",options=header]
|=======================================================================
|instruction            | definition
| C.MVP rdp, rsp        | mv rdp, rsp;  mv rdp+1, rsp+1
|=======================================================================

[#mvp-syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax          | requirements for 16-bit encoding   | 32-bit extension
|C.MVP       | mv(rdp,rsp),(rdp+1,rsp+1)| none                               | N/A
|======================================================================================================

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

Assembly examples.
[source,sourceCode,text]
----
# c.mvp: sreg1 = 0; sreg2 = 0;
mv (x2, x3), (x18, x19) ; # mv x2, x2; mv x18, x19
----

=== C.MVA01S07, C.MVA23S07

Register moves are the most common in GCC output in both the benchmark suite and the Debian distro. These two instructions combine two very common pairs of moves into single 16-bit encodings:

* move from two `s[0-7]` registers into `a0` and `a1`.
* move from two `s[0-7]` registers into `a2` and `a3`.

[NOTE]

  The syntax takes ABI names not `x` register names, so it is unusual. However this allows much more frequent usage without increasing the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.


[#proposed-16bit-encodings-4]
.`C.MV01S07, C.MV23S07` 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     2+|10     3+| 000      3+|sreg1      3+|sreg2    2+| 00    | C.MVA01S07
3+|  100     2+|10     3+| 001      3+|sreg1      3+|sreg2    2+| 00    | C.MVA23S07
|================================================================================================

[#mvs07_semantics]
.`C.MV01S07, C.MV23S07` semantics
[width="100%",options=header]
|=======================================================================
|instruction                | definition
| C.MVA01S07 sreg1, sreg2   | mv a0, s[sreg1];  mv a1, s[sreg2]
| C.MVA23S07 sreg1, sreg2   | mv a2, s[sreg1];  mv a3, s[sreg2]
|=======================================================================

[#mvs07_syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.MVAS01S07 | mv(a0,a1),(sreg1,sreg2)| none                               | N/A
|C.MVAS23S07 | mv(a2,a3),(sreg1,sreg2)| none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva01s: sreg1 = 0; sreg2 = 0;
mv (a0, a1), (s0, s0) ; # mv a0, s0; mv a1, s0

# c.mva23s: sreg1 = 1; sreg2 = 3;
mv (a2, a3), (s1, s3) ; # mv a2, s1; mv a3, s3
----

