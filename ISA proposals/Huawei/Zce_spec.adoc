= RISC-V Zce code-size reduction extension proposal v0.1
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes the `Zce` extension to reduce code-size.

== Issues

* there are probably too many instructions listed, so we need to reduce the list
** we don't need `both c.mvp` and also `c.mvas*`
* we need to check the sizes of the immediate fields, so we don't waste encoding space

== Zce proposal

Zce is split into subsets. It includes 

* `Zces` sequenced instructions
** 16-bit: `C.POP, C.POPRET, C.PUSH, C.MVA01S07, C.MVA23S07, C.MVP`     
** 32-bit: `POP, POPRET, PUSH, POP.[FDQ}, POPRET.[FDQ], PUSH.[FDQ]`
* `Zced` instructions which conflict with the D-extension
** 16-bit: `C.LBU, C.LHU, C.SB, C.SH, C.DECBGEZ`
** 32-bit: `DECBGEZ, LWGP, SWGP, BEQI, BNEI`
* `Zcec` common instructions
** all others

If `Zce` is specified, and `D` is _not_ specified then `Zces_Zced_Zcec` are configured.

If `Zce` is specified, and `D` _is_  specified then `Zces_Zcec` are configured.

If `Zces` is not required then `Zcec` and optionally `Zced` must be specified.

== C-extension subsets

The C-extension already reuses encodings between different architectures. `Zce` extends this concept further.

The shared encoding column in the tables assigns an arbitrary number to show which encodings are grouped together (I can't find a better way of highlighting groups of cells in the table in adoc format). `Zce` instructions are in *bold*.

[#zce_quad0]
.C-extension quadrant 0
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension
|000       |C.ADDI4SPN| |Zci |✓|✓ |✓  |C

8+|The encodings for `C.FLD/C.LQ` are replaced by `C.LBU` and `C.DECBGEZ`
|001       |C.FLD     |1|Zcd |✓|✓ |   |C+D
|001       |C.LQ      |1|Zcq |  |  |✓  |C
|001       |*C.LBU*     |1|*Zced*|✓|✓ |  |C+*Zce*
|001       |*C.DECBGEZ* |1|*Zced*|✓|✓ |  |C+*Zce*

|010       |C.LW      | |Zci |✓|✓ |✓  |C

|011       |C.FLW     |2|Zcf |✓|   |   |C+F
|011       |C.LD      |2|Zc64/Zc128| |✓|✓|C

|100       |*C.POP*     | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.POPRET*  | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.PUSH*    | |*Zces*|	✓|	✓|	✓|	C+*Zce*

|100       |*C.TBLJAL*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SHSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SBSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LHUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LBUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LSBNOT*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MUL*     | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA01S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA23S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVP*	    | |*Zcec*|  ✓|  ✓| 	✓|  C+*Zce*

|101       |C.FSD     |3|Zcd|✓|✓| |C+D
|101       |C.SQ      |3|Zcq| | |✓|D
|101       |*C.SB*      |3|*Zced*|✓|✓| |C+*Zce*

|110       |C.SW      | |Zci|✓|✓|✓|C

|111       |C.FSW     |4|Zcf|✓| | |C+F
|111       |C.SD      |4|Zc64/Zc128| |✓|✓|C
|===============================================================================

[#zce_quad1]
.C-extension quadrant 1
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.NOP	| |Zci	|✓	|✓	|✓	|C
|000       |C.ADDI	| |Zci	|✓	|✓	|✓	|C


|001       |C.JAL	        |5|Zc32	        |✓	|	|	|C
|001       |C.ADDIW (rd=0:RSV)  |5|Zc64/Zc128	|	|✓	|✓	|C

|010       |C.LI (rd=0:HINT) | |Zci	|✓	|✓	|✓	|C


|011       |C.ADDI16SP (nzimm=0:RSV)	| | Zci	|✓	|✓	|✓	|C
|011       |C.LUI (nzimm=0: RSV; rd=0:HINT)	| |Zci	|✓	|✓	|✓	|C


|100       |C.SRLI (RV32:NSE, nzuimm[5]=1)        |6|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRLI64 (RV32:HINT)                  |6|Zc128	|	|	|✓	|C
|100       |C.SRAI (RV32:NSE, nzuimm[5]=1)        |7|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRAI64 ( RV32/64:HINT)              |7|Zc128	|	|	|✓       |C
|100       |C.ANDI                                | |Zci	|✓	|✓	|✓	|C
|100       |C.SUB                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.XOR                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.OR                                  | |Zci	|✓	|✓	|✓	|C
|100       |C.AND                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.SUBW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C
|100       |C.ADDW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C

|101       |C.J	       | |Zci	|✓	|✓	|✓	|C


|110       |C.BEQZ	| |Zci	|✓	|✓	|✓	|C


|111       |C.BNEZ	| |Zci	|✓	|✓	|✓	|C
|===============================================================================

[#zce_quad2]
.C-extension quadrant 2
[width="100%",options=header]
|======================================================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.SLLI (rd=0:HINT; RV32 && nzuimm[5]=1:NSE)| 8|Zc32/Zc64	|✓	|✓	|	|C
|000       |C.SLLI64 (RV32/64 or rd=0:HINT)	       | 8|Zc128	        |	|	|✓	|C
|001       |C.FLDSP	                               | 9|Zcd	        |✓	|✓	|	|C+D
|001       |C.LQSP (rd=0:RSV)	                     | 9|Zc128	        |	|	|✓	|C
|001       |*C.LHU*	                               | 9|*Zced* 	|✓	|✓	| 	|C+*Zce*
|001       |*unallocated*	                         | 9|*Zced* 	|✓	|✓	| 	|C+*Zce*
|010       |C.LWSP (rd=0:RSV)	                     |  |Zci	        |✓	|✓	|✓	|C
|011       |C.FLWSP	                               |10|Zcf	        |✓	|	|	|C+F
|011       |C.LDSP (rd=0:HINT)	                   |10|Zc64/Zc128	|	|✓	|✓	|C
|100       |C.JR     (rd=0:RSV)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.MV   (rd=0:HINT)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.EBREAK	                             |  |Zci   	|✓	|✓	|✓	|C
|100       |C.JALR	                               |  |Zci   	|✓	|✓	|✓	|C
|100       |C.ADD (rd=0:HINT)	                     |  |Zci   	|✓	|✓	|✓	|C
|101       |C.FSDSP	                               |11|Zcd	        |✓	|✓	|	|C+D
|101       |C.SQSP	                               |11|Zc128		|       | 	|✓	|C
|101       |*C.SH*	                               |11|*Zced**	|✓	|✓	| 	|C+*Zce*
|110       |C.SWSP	                               |  |Zci	        |✓	|✓	|✓	|C
|111       |C.FSWSP	                               |12|Zcf	        |✓	|	|	|C+F
|111       |C.SDSP	                               |12|Zc128	        |	|✓	|✓	|C
|======================================================================================================

== Allocation of new 16-bit encodings

This section gives a short-hand lookup of exactly where the new encodings are allocated to make it easier to review.

|======================================
|[15:13]|[12:10]|[1:0]|Instruction

|100    |000    |00   |C.POP, C.POPRET, C.PUSH
|100    |001    |00   |C.[SZ]EXT.[BH], C.LSBNOT, C.MUL
|100    |01x    |00   |C.L[BH]USP, C.S[BH]SP
|100    |100    |00   |C.MVA01S07, C.MVA23S07
|100    |101    |00   |C.MVP
|100    |11x    |00   |C.TBLJAL

|001    |xxx    |00   |C.DECBGEZ

|101    |0xx    |00   |C.SB
|101    |1xx    |00   |C.LBU

|011    |000    |00   |C.NOT
|011    |001    |00   |C.NEG


|101    |0xx    |10   |C.SH
|101    |1xx    |10   |C.LHU
|======================================


=== Spare 16-bit encodings

Some spare encodings are noted in the tables below. The remaining unallocated space is listed here:

[#spare encodings]
.spare 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These three are RV32 only
3+|  000       |1 10+|  xxxxx                                   2+| 10  | *reserved*
3+|  100       |1   |0  9+| xxxx                                2+| 01  | *reserved*
3+|  100       |1 2+|11 8+| xxxx                                2+| 00  | *reserved*
17+|This conflicts with the D-extension
3+|  001     11+|xxxx                                           2+| 10 | *reserved*
|================================================================================================

== `Zces` definition

`Zces` is optional as cores may not want to build the sequencer to issue the instructions.

=== PUSH/POP
[[pushpop16]]
==== C.PUSH, C.POP, C.POPRET

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here].

[NOTE]

  The reserved 16-bit encodings could be used for EABI versions in the future.

[#proposed-16bit-encodings-1]
.PUSH/POP 16-bit encodings
[width="100%",options=header]
|===============================================================================
|15 |14 |13 |12 |11 |10  |9 |8  |7 |6   |5 |4 |3 |2           |1 |0 |instruction
17+|`C.POP` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0  |0 2+|rcount[1:0]|0 |0 2+|00 | spimm[0] 2+| 00  |C.POP
3+|100  |0  |0  |0  |1 2+|xx         |0 |0 3+|xxx           2+| 00  |*reserved*
3+|100  |0  |0  |0 3+|xxx            |0 |0 2+|!=00| x       2+| 00  |*reserved*
17+|`C.POPRET` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET
3+|100  |0  |0  |0   |1 2+|xxx        |x|1 |1 2+|xx         2+| 00  |*reserved*
17+|`C.PUSH` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH
3+|100  |0  |0  |0   |1 2+|xx      |1 |0   |1 2+|xx         2+| 00  |*reserved*
|===============================================================================

  * For `C.POPRET`, `ret_val[0]=ret0` as specified in the encoding, `ret_val[1]=0`. 
  * For `C.POP` `ret_val[1:0]=0`.
  * Some encodings remain *reserved* for the time being so we can add them later if they can be justified
  ** For `C.POP`, `rcount[2]=1` is reserved
  ** For `C.POP`, `spimm > 1` is reserved
  ** For `C.PUSH/C.POPRET`, `rcount[2]=1 && spimm[2]=1` is reserved

[#pushpop_semantics]
.PUSH/POP semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.POP         | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers]
| C.POPRET      | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers and return]
| C.PUSH        | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[PUSH registers]
|=======================================================================

[#pushpop-32bit]
.PUSH/POP assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.POP       | pop    <args>         | <args> map to a 16-bit encoding | Zce
|C.POPRET    | popret <args>         | <args> map to a 16-bit encoding | Zce
|C.PUSH      | push   <args>         | <args> map to a 16-bit encoding | Zce
|======================================================================================================

Assembly examples are https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc#assembly-examples[here].

[[pushpop32]]
==== PUSH, POP, POPRET, PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]

[NOTE]

  These encodings are in custom=0, as no official encodings have been allocated yet


.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
18+|`PUSH` encodings
4+|00000                     2+|00   2+|mv          2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH
4+|00000                     2+|01   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.Q
18+|`POP` encodings
4+|00000                     2+|00   2+|ret_val     2+|rcount     |ra | 010   4+| spimm             |0001011| POP
4+|00000                     2+|01   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.Q
18+|`POPRET` encodings
4+|00000                     2+|00   2+|ret_val     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET
4+|00000                     2+|01   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.Q
|=========================================================================================================================

[NOTE]
  bits [28:27] are the `flen` field
  `ra=1` for all `popret` encodings, it is not specified in the encoding

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here] and the 16-bit encoding is in <<pushpop16>>.


=== C.MVA01S07, C.MVA23S07

Register moves are the most common in GCC output in both the benchmark suite and the Debian distro. These two instructions combine two very common pairs of moves into single 16-bit encodings:

* move from two `s[0-7]` registers into `a0` and `a1`.
* move from two `s[0-7]` registers into `a2` and `a3`.

[NOTE]

  The syntax takes ABI names not `x` register names, so it is unusual. However this allows much more frequent usage without increasing the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.

[#proposed-16bit-encodings-4]
.`C.MV01S07, C.MV23S07` 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     2+|10     3+| 000      3+|sreg1      3+|sreg2    2+| 00    | C.MVA01S07
3+|  100     2+|10     3+| 001      3+|sreg1      3+|sreg2    2+| 00    | C.MVA23S07
|================================================================================================

[#mvs07_semantics]
.`C.MV01S07, C.MV23S07` semantics
[width="100%",options=header]
|=======================================================================
|instruction                | definition
| C.MVA01S07 sreg1, sreg2   | mv a0, s[sreg1];  mv a1, s[sreg2]
| C.MVA23S07 sreg1, sreg2   | mv a2, s[sreg1];  mv a3, s[sreg2]
|=======================================================================

[#mvs07_syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.MVAS01S07 | mv(a0,a1),(sreg1,sreg2)| none                               | N/A
|C.MVAS23S07 | mv(a2,a3),(sreg1,sreg2)| none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva01s: sreg1 = 0; sreg2 = 0;
mv (a0, a1), (s0, s0) ; # mv a0, s0; mv a1, s0

# c.mva23s: sreg1 = 1; sreg2 = 3;
mv (a2, a3), (s1, s3) ; # mv a2, s1; mv a3, s3
----


=== C.MVP

The generic move uses standard x register numbers, and so it more standard than `C.MVA*S07`, however it takes a lot more encoding space. Both register pairs must be even/odd pairs (`rdp[0]=0, rsp[0]=0`) to reduce the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional as they require 2 register file write ports, or are sequenced.

[#mvp-encoding]
.generic double move 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     3+|101    4+| rdp[4:1] 4+|  rsp[4:1]       2+| 00    | C.MVP
3+|  001     3+|>0 8+|xxxx                              2+| 10 | *reserved*
|================================================================================================

[#mvp-semantics]
.generic double move semantics
[width="100%",options=header]
|=======================================================================
|instruction            | definition
| C.MVP rdp, rsp        | mv rdp, rsp;  mv rdp+1, rsp+1
|=======================================================================

[#mvp-syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax          | requirements for 16-bit encoding   | 32-bit extension
|C.MVP       | mv(rdp,rsp),(rdp+1,rsp+1)| none                               | N/A
|======================================================================================================

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

Assembly examples.
[source,sourceCode,text]
----
# c.mvp: sreg1 = 0; sreg2 = 0;
mv (x2, x3), (x18, x19) ; # mv x2, x2; mv x18, x19
----


== `Zcec` definition

=== Table Jump

[[tablejump16]]
==== C.TBLJAL

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

The 32-bit encoding is in <<tablejump32>>.

[#tbljal-16encoding]
.C.TBLJAL 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1     9+|index9                             2+| 00 | C.TBLJAL
|=============================================================================================

[[tablejump32]]
==== TBLJAL

[NOTE]

  This encoding is in custom=0, as no official encoding has been allocated yet

The 16-bit encoding is in <<tablejump16>> and the specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

[zcec-32bit-encodings-table-jump]
.*temporary* TBLJAL 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
8+|00000                             4+|index13[12:5]                 | 000   4+| index13[4:0]      |0001011| TBLJAL
|=========================================================================================================================

=== C.[SZ]EXT.[BH], C.LSBNOT, C.MUL

These instructions are 16-bit versions of existing 32-bit instructions.

[#dyadic-16encodings]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|Single source/dest with room for 3 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 010     2+| 00  | C.SEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 011     2+| 00  | C.SEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 100     2+| 00  | C.LSBNOT
3+|  100       | 0  | 0  | 1 3+| xxx      | 0  | 0  3+| >=101   2+| 00  | *reserved*
17+|Dyadic with room for 2 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 1  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 0  | 0  | 1 3+| xxx    2+| 1x      3+| xxx     2+| 00  | *reserved*
|=============================================================================================

[#monsemantics]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.LSBNOT      | rd' = rd' XOR 1
| C.MUL         | rd' = rd' * rs2'
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.ZEXT.B    | zext.b rd             | all registers x8-x15, rd==rs1      | I-extension
|C.ZEXT.H    | zext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.B    | sext.b rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.H    | sext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.LSBNOT    | lsbnot rd             | all registers x8-x15, rd==rs1      | I-extension
|C.MUL       | mul    rd, rs1, rs2   | all registers x8-x15, rd==rs1      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
zext.b a5, a5;  # a5 = zero_ext(a5[7:0])
zext.h a5, a5;  # a5 = zero_ext(a5[15:0])
sext.b a5, a5;  # a5 = sign_ext(a5[7:0])
sext.h a5, a5;  # a5 = sign_ext(a5[15:0])

lsbnot a5;      # a5 = a5 XOR 1

mul a5, a5, a6; # a5 = a5 * a6
----


=== C.NOT, C.NEG

These instructions are 16-bit versions of existing 32-bit instructions.

[#monadic-16encodings]
.B-extension monadic instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These are taken from the B-extension draft specification
3+|  011       |0   | 0  | 0 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NOT
3+|  011       |0   | 0  | 1 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NEG
|=============================================================================================

[#monadic-semantics]
.B-extension monadic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.NOT         | rd' = ~rd' / rd' = rd' XOR -1
| C.NEG         | rd' = -rd'
|=======================================================================

[#monadic-32bit]
.B-extension monadic instructions 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.NOT       | not    rd, rs1        | all registers x8-x15, rd==rs1      | I-extension
|C.NEG       | sub    rd, 0, rs2     | all registers x8-x15, rd==rs2      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion
----


=== C.LBUSP, C.LHUSP, C.SBSP, C.SHSP

[#ldstbhsprel-16encodings]
.load/store half/byte SP relative 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
|================================================================================================

[#ldstbhsprel-semantics]
.load/store byte/half SP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh_sprel_32bit]
.load/store byte/half SP relative asswebmly syntax and 32-bit equivalent instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBUSP     | lbu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SBSP      | sb     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SHSP      | sh     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   
----

== `Zced` definition

The D-extension takes priority over these encodings.

=== Decrement and branch

[[decbr16]]
==== C.DECBGEZ

This instruction is a combined decrement and branch, used for inferring loops with an optionally scaled loop counter.

This example is from /lib/riscv64-linux-gnu/libgcc_s.so.1 in the RV64 Debian distro

[source,sourceCode,text]
----
    d124:	6094                	ld	a3,0(s1) ;# start of loop
    d126:	01093783          	ld	a5,16(s2)
    d12a:	8722                	mv	a4,s0
    d12c:	00d93823          	sd	a3,16(s2)
    d130:	e09c                	sd	a5,0(s1)
    d132:	4681                	li	a3,0
    d134:	864e                	mv	a2,s3
    d136:	85d6                	mv	a1,s5
    d138:	8552                	mv	a0,s4
    d13a:	347d                	addiw	s0,s0,-1 ;# loop counter 1
    d13c:	ef1ff0ef          	jal	ra,d02c <_Unwind_Backtrace@@GCC_3.3+0xf0>
    d140:	14e1                	addi	s1,s1,-8 ;# loop counter 2
    d142:	f06d                	bnez	s0,d124 <_Unwind_Backtrace@@GCC_3.3+0x1e8>
----

The instructions at PCs `d13a` and `d142` can be combined into a single 16-bit encoding.

[source,sourceCode,text]
----
decbgez rd', 1, #offset; # executes as: rd' = rd' - 1; bge rd', zero, -#offset;
----

This reduces the loop by one 16-bit instruction to:

[source,sourceCode,text]
----
    d124:	6094                	ld	a3,0(s1) ;# start of loop
    d126:	01093783          	ld	a5,16(s2)
    d12a:	8722                	mv	a4,s0
    d12c:	00d93823          	sd	a3,16(s2)
    d130:	e09c                	sd	a5,0(s1)
    d132:	4681                	li	a3,0
    d134:	864e                	mv	a2,s3
    d136:	85d6                	mv	a1,s5
    d138:	8552                	mv	a0,s4
    d13c:	ef1ff0ef          	jal	ra,d02c <_Unwind_Backtrace@@GCC_3.3+0xf0>
    d140:	14e1                	addi	s1,s1,-8 ;# loop counter 2
    d142:	f06d                	decbgez	s0,1,d124 <_Unwind_Backtrace@@GCC_3.3+0x1e8>
----

[#proposed-16bit-encodings-dec_br]
.proposed 16-bit encodings for dec-and-branch
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  001          3+|uimm[6:4] 3+| rd'  3+|uimm[3:1] 2+|scale 2+| 00 | C.DECBGEZ
|=============================================================================================

[#deccmpbrsemantics]
.decrement, compare and branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.DECBGEZ     | rd' = rd' - (1<<scale); bge rd', zero, -zero_ext(uimm);
|=======================================================================

[#v1.0-32bit]
.32-bit equivalent instructions for decrement, compare and branch semantics
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.DECBGEZ   | decbgez, rd, imm, offset | rd is x8-x15, imm is [1248], offset is in range   | Zce
|======================================================================================================

==== DECBGEZ

This reuses the encoding for `FDIV.D`.

The 16-bit encoding and specification is in <<decbr16>>.

[decbgez-32bit-encodings]
.proposed 32-bit encodings for arithmetic instructions
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
5+|0001101                   6+|imm[9:0]                              |scale  4+| rd                |1010011| DECBGEZ
|=========================================================================================================================

[#decbgezsemantics32]
.decrement, compare and branch 32-bit semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| DECBGEZ       | rd = rd - (1<<scale); bge rd, zero, sign_ext(imm);
|=======================================================================


=== C.LBU, C.LHU, C.SB, C.SH

The D-extension takes priority over these encodings

[#ldstbh]
.proposed 16-bit encodings for load/store byte/half
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  101       |1 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.LBU
3+|  101       |1 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.LHU
3+|  101       |0 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.SB
3+|  101       |0 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.SH
|=============================================================================================

[#ldstbhsemantics]
.Load/store byte/half semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh-32bit]
.Load/store byte-half 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBU       | lbu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.LHU       | lhu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SB        | sb     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SH        | sh     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|======================================================================================================

[source,sourceCode,text]
----
lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0])
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0]
----

=== MULI, MULIADD, ADDIADD

See https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension].
Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[this document], which is implemented on silicon.

[zcec-32bit-encodings-arithmetic]
.arithmetic instructions 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
18+| *https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension]*
8+|imm[11:0]                                          |00 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULI
7+|imm[11:0]                           |rs2'          |00 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULIADD
7+|imm[11:0]                           |rs2'          |00 2+|rs1'   2+| 11101         3+| rd'       |0011011| ADDIADD
|=========================================================================================================================

[#arithmetic_semantics]
.Arithmetic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULI           |rd' = rs1' * sign_ext(imm)
|MULIADD        |rd' = rs1' + rs2' * sign_ext(imm)
|ADDIADD        |rd' = rs1' + rs2' + sign_ext(imm)
|=======================================================================

=== BEQI, BNEI

These reuse the encodings for `FMADD.D/FMSUB.D`.

The encodings allow a comparison of a register and an immediate value. `BEQI` in particular is very useful for _switch_ statements. 

Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_condbr_imm_extension.rst[this document], which is implemented on silicon.

[zced-32bit-encodings]
.proposed 32-bit encodings for `Zced`
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 001   4+| offset[5:1]       |1000011| BEQI
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 010   4+| offset[5:1]       |1000111| BNEI
|=========================================================================================================================

[#compare-immediate branch_semantics]
.Compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BEQI          | if (rs1==sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI          | if (rs1!=sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

=== LWGP, SWGP

These reuse the encodings for `FLD/FSD`.

`tp` is used as a second `gp` for systems which do not have thread local storage. `LWGP/SWGP` allow a larger offset than the normal `LW/SW` relative to `gp` or `tp`. This allows two 18-bit memory spaces to be within reach of a 32-bit load or store word instruction.

[zced-32bit-encodings]
.proposed 32-bit encodings for `Zced`
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
 8+|imm[11:2, 17:16]                                2+|imm[15:12]|tp  | 011   4+| rd                |0000111| LWGP
 5+|imm[11:5]                3+| rs2                2+|imm[15:12]|tp  | 011   4+| imm[4:2, 17:16]   |0100111| SWGP
|=========================================================================================================================

[#lwgp_semantics]
.Load/store word GP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| LWGP          | base=(tp==1)?tp:gp; rd=zero_ext(Memory[base+sign_ext(imm)][31:0]);
| SWGP          | base=(tp==1)?tp:gp; Memory[base+sign_ext(imm)][31:0])=rs2[31:0];
|=======================================================================


== B-extension reuse

Some instructions will be reused from the B-extension. No work has been done on which instructions to choose yet.....


