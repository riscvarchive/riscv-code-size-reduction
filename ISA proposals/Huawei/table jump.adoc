= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions.
The 32-bit instruction will ensure that 64-bit sequences are not needed to call functions, and additional functionality may be added TBD.

== Issues 

. what functionality to add in the 32-bit verson, if any, for example is there any reason to table the table index field larger?

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	001f8317          	auipc	t1,0x1f8
  e084c2:	18a302e7          	jalr	t0,394(t1) # 1000648 <__riscv_save_0>
  e084c6:	86b2                	mv	a3,a2
  e084c8:	862e                	mv	a2,a1
  e084ca:	800005b7          	lui	a1,0x80000
  e084ce:	fff5c593          	not	a1,a1
  e084d2:	f61ff0ef          	jal	ra,e08432 <vsnprintf>
  e084d6:	001f8317          	auipc	t1,0x1f8
  e084da:	19630067          	jr	406(t1) # 100066c <__riscv_restore_0>
----

using table jump we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e079ce <fwrite>:
  e079ce:	xxxx              	tbljal #0 ;#<mapped to __riscv_save_0>, saving 6-bytes
  e079d6:	84ae                	mv	s1,a1
  e079d8:	02c58933          	mul	s2,a1,a2
  e079dc:	4401                	li	s0,0
  e079de:	c191                	beqz	a1,e079e2 <fwrite+0x14>
  e079e0:	8432                	mv	s0,a2
  e079e2:	8636                	mv	a2,a3
  e079e4:	85ca                	mv	a1,s2
  e079e6:	xxxx             	jal	ra,e07942 <__fwritex> ;# don't replace with c.tlbjal as there are only two calls in the elf file, so no code size is saved
  e079ea:	00a90463          	beq	s2,a0,e079f2 <fwrite+0x24>
  e079ee:	02955433          	divu	s0,a0,s1
  e079f2:	8522                	mv	a0,s0
  e079f4:	xxxx             	tblj #1 ;#<mapped to __riscv_restore_0>

----

The principle is to have a single lookup table of addresses for `C.TBLJ` and `C.TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 46-byte function is reduced to 34-bytes giving ~ 26% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines.

Note that `C.TBLJ` is less frequent than `C.TBLJAL` so the 16-bit encoding can be optimised to have a smaller index into the table.

== 16-bit Opcode Assignment

|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  4+| 1011       5+| index5              2+| 00  | C.TBLJ
3+|  100       | 1  | 1  2+| 11 7+|         index7              2+| 00  | C.TBLJAL
|=============================================================================================

With the proposed encoding, routines called with `C.TBLJ` must be in the lowest quarter of the table. 

== 32-bit Opcode Assignment

|============================================================================
|31:22  |21:15  |14:12 |11:7  |6:0     |name
|xxxxxx |index7 |000   |xxxxx |xxxxxxx |TBLJ
|xxxxxx |index7 |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

In the 32-bit encoding, the full range is allowed for `TBLJ`. It would be possible to make the table index field larger, but it's not clear that this would be useful.

== CSR and Modes

Two modes are proposed for the lookup table

- simple jump table (`MTBLJVEC.scale`=0)
- vector table, similar to the interrupt handler vector (`MTBLJVEC.scale>0`)

|=============================================================================================
| 31:4          | 3: 0  | CSR
| base[31:4]    | scale | MTBLJVEC
|=============================================================================================

=== Jump table mode

In jump table mode the behaviour is to load the target address from `MTBLJVEC.base` with an offset which is four times the parameter.

[source,sourceCode,text]
----
# tmp is temporary internal state, it doesn't represent a real register
c.tblj   #n ;# LW tmp, Mem[{MTLBJVEC.base[31:4],4'b0} + n<<2]; JR tmp
c.tbljal #n ;# LW tmp, Mem[{MTLBJVEC.base[31:4],4'b0} + n<<2]; JALR ra, tmp
----

For the `fwrite` example above, the table contains the base addresses of the functions.

[source,sourceCode,text]
----
MTLBJVEC.base+0 = # 1000648 <__riscv_save_0>
MTLBJVEC.base+4 = # 100066c <__riscv_restore_0>
----

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding.

=== Vector table mode

In vector table mode, execution passes directly to the offset from the base register.
The entry points are scaled, according to `MTLBJVEC.scale`

|==================================================================
| `MTLBJVEC.scale` | `tablescale` 
| 0               | jump table mode
| 1               | 16-bytes, enough for minimum code + `ret`
| 2               | 32-bytes
| 3-14            | to be defined / *reserved?*
| 15              | 4k to match minimum TLB page size
|==================================================================

[source,sourceCode,text]
----
c.tblj   #n ;# JR       Mem[{MTLBJVEC.base[31:4],4'b0} + n*tablescale];
c.tbljal #n ;# JALR ra, Mem[{MTLBJVEC.base[31:4],4'b0} + n*tablescale];
----

This method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

If the scale is set to 4K then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `MTLBJVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example like a true flash patch mechanism, but it can form the basis of such a mechanism.

For the `fwrite` example above __riscv_save_0 / __riscv_restore_0 each take 12 bytes. Therefore `MTLBJVEC.scale=1` is stuiable (16 bytes per entry) and the actual code is placed in the table.

[source,sourceCode,text]
----

MTLBJVEC.base+0  <__riscv_save_0>:
 MTLBJVEC.base+0 :	1141                	addi	sp,sp,-16
 MTLBJVEC.base+2 :	c04a                	sw	s2,0(sp)
 MTLBJVEC.base+4 :	c226                	sw	s1,4(sp)
 MTLBJVEC.base+6 :	c422                	sw	s0,8(sp)
 MTLBJVEC.base+8 :	c606                	sw	ra,12(sp)
 MTLBJVEC.base+10:	8282                	jr	t0

MTLBJVEC.base+16 <__riscv_restore_0>:
 MTLBJVEC.base+16:	4902                	lw	s2,0(sp)
 MTLBJVEC.base+18:	4492                	lw	s1,4(sp)
 MTLBJVEC.base+20:	4422                	lw	s0,8(sp)
 MTLBJVEC.base+22:	40b2                	lw	ra,12(sp)
 MTLBJVEC.base+24:	0141                	addi	sp,sp,16
 MTLBJVEC.base+26:	8082                	ret


----

Clearly some memory is wasted.






