= RISC-V Push/Pop Extension (UABI only version)
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describesï¼š

* 32-bit encodings for `PUSH/PUSH.[FDQ]`, `POP/POP.[FDQ]` and `POPRET/POPRET.[FDQ]`
* 16-bit encodings for `C.PUSH, C.POP` and `C.POPRET` instructions 

The instructions are defined for RV32, RV64 and RV128 architectures I variants only, using the UABI. 

Future revisions may include:

* The E variant
* EABI support

These instructions are to reduce the code-size of function prologues and epilogues by using a single encoding to replace a sequence of instructions. 
They are designed to replace common function prologue/epilogue sequences, but will not replace all possible cases. 

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

* allocate encodings for the 32-bit versions
* whether to allow x-registers to be specified in the assembler syntax instead of only ABI names
** only using ABI names should make it easier to work with the EABI as well, as those names don't change but the x-register mappings do. Providing the hardware knows which ABI is in use then this can work, so the disassembly works seamlessly. TBD.
* whether the fault handling should be profile defined

== Assembler Syntax

[source,sourceCode,text]
----
//these encodings may be 16-bit or 32-bit depending upon the parameters
push           {<xreg_list>},  -<stack_adjustment>
pop            {<xreg_list>},   <stack_adjustment> 
popret         {<xreg_list>},   <stack_adjustment> 

//these encodings are 32-bit as F registers are included in the list, the length of the F registers is specified in the encoding
push.[fdq]     {<fxreg_list>}, -<stack_adjustment> 
pop.[fdq]      {<fxreg_list>},  <stack_adjustment> 
popret.[fdq]   {<fxreg_list>},  <stack_adjustment> 
----

. `PUSH` pushes the registers specified in `[f]xreg_list` to the stack, and then adjust the stack pointer by the `stack_adjustment`.
. `POP` pops the registers in `[f]xreg_list to the stack` from the stack, and then adjusts the stack pointer by the `stack_adjustment`.
. `POPRET` has the same behaviour as `POP`, followed by `RET`.

32-bit and 16-bit forms are available, the assembler should choose the 16-bit form if the parameters permit and the C extension is implemented.

The registers in `xreg_list` are in a comma separated list. The list must not be empty.

[source,sourceCode,text]
----
<reg_list>   ::= <xreg_list> | <fxreg_list>
<xreg_list>  ::= <ra> "," <xreg_range> | <ra> | <xreg_range>
<fxreg_list> ::= <ra> "," <xreg_range> ", " <freg_range> | <ra> "," <freg_range> | <xreg_range> "," <freg_range> | <freg_range>
<xreg_range> ::= <s0>  | <s0-sN>   (where `N` is in the range [1, 11])
<freg_range> ::= <fs0> | <fs0-fsM> (valid values of `M` are 0,1,2,3,5,8,11)
----

For the 16-bit encodings

. `ra` must be included
. `s0-sN` may be included, valid values of `N` are 0,1,2,3,5,8,11
. `fs0-fsM` must not be included
. the `stack_adjustment` must be no more than the total memory required for `xreg_list`, rounded up to a multiple of 16-bytes, plus an addition (0..7)*16-bytes.

[NOTE]
  To save encoding space some opcodes do not allow the full range of `spimm` which reduces the possible `stack adjustment` range further, see <<#16bitencodings>>

For the 32-bit encodings

. the `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..15)*16-bytes.

For example

. `push   {ra,s0-s2}, -64` can use a 16-bit encoding
. `push.f {ra,s0-s2, fs0}, -64` must use a 32-bit encoding as `fs0` is in the register list
. `push   {ra,s0-s2}, -256` must use a 32-bit encoding as the `stack_adjustment` is out of range

To be a legal encoding:

1.  The stack adjustment must be negative for all `PUSH` variants and positive for all `POP[RET]` variants
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register list must be valid (see above)
4.  If any F registers are included in the list there must be a `.[fdq]` suffix
5.  It there is a `.[fdq]` suffix, there must be F registers in the list

Additionally:

. If `sp` is not 16-byte aligned then take an illegal instruction exception

[NOTE]
  When moving from accessing `x` registers to `f` registers there may be a gap as the registers may be different widths, and all registers must be aligned in memory

== Determining XLEN and FLEN to decode and execute the instructions

The width of `x` registers in the register list depends upon XLEN and so `misa.MXL`. From the ELF file header, XLEN is determined by the following flags:

* ELFCLASS64 for RV64
* ELFCLASS32 for RV32 

[NOTE]

  I don't think there's an ELFCLASS128 for RV128

If using a debugger then `misa.MXL` can be read, if XLEN is not known for the core.

FLEN is explicitly specified in the opcode as the presence of any F registers requires a `.[fdq]` suffix on the opcode.

Follow this link for details of the https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#file-header[ELF file header]

=== Rationale: why include the .[fdq] suffix

It is required to hard-code the length of the F registers in the opcode, and not just save/restore the whole register. We must allow code compiled for the F-extension
to run on a  core which supports D and possibly Q. We must also allow code compiled for the D-extension to run on a core which supports Q.

If we don't explicitly state the F register width and always store the whole register, then the registers will be stored at different addresses to the ones expected 
by the compiler. 

An alternative would be to use `misa.[FDQ]`
to directly control the behaviour and so set `misa.[DQ]=0` when running F code. Nothing else in the architecture requires this, so it seems unreasonable to 
add this requirement here.

== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

=== PUSH Pseudo-code

All variants of the `PUSH` instruction store the set of registers from `reg_list` to consecutive memory locations, and decrement the stack pointer.
The pseudo-code uses assembly inserts so that it can use `fsw/fsd` etc.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])     {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw ra, 0(addr)");
    8:  asm("sd ra, 0(addr)");
    16: asm("sq ra, 0(addr)");
  }
}
for(i in xreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw s[i], 0(addr)");
    8:  asm("sd s[i], 0(addr)");
    16: asm("sq s[i], 0(addr)");
  }
}
if (freq_list) {
  switch (opcode) {
    //if FLEN > XLEN, then get the address back into alignment before saving the F registers
    "PUSH.D": while(addr% 8) {addr-=bytes;}
    "PUSH.Q": while(addr%16) {addr-=bytes;}
  }
  for(i in freg_list)  {
    switch (opcode) {
      "PUSH.F": {addr-= 4;asm("fsw fs[i], 0(addr)");}
      "PUSH.D": {addr-= 8;asm("fsd fs[i], 0(addr)");}
      "PUSH.Q": {addr-=16;asm("fsq fs[i], 0(addr)");}
    }
  }
}
sp+=stack_adjustment; //decrement
----

=== POP[RET] Pseudo-code

A `POP[RET]` instruction loads the set of registers from `reg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `flw/fld/ret`.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])     {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw ra, 0(addr)");
    8:  asm("ld ra, 0(addr)");
    16: asm("lq ra, 0(addr)");

  }
}
for(i in xreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw s[i], 0(addr)");
    8:  asm("ld s[i], 0(addr)");
    16: asm("lq s[i], 0(addr)");
  }
}
if (freq_list) {
  switch (opcode) {
    //if FLEN > XLEN, then get the address back into alignment before saving the F registers
    "POP.D", "POPRET.D": while(addr% 8) {addr-=bytes;}
    "POP.Q", "POPRET.Q": while(addr%16) {addr-=bytes;}
  }
  for(i in freg_list)  {
    switch (opcode) {
      "POP.F", "POPRET.F": {addr-= 4;asm("flw fs[i], 0(addr)");}
      "POP.D", "POPRET.D": {addr-= 8;asm("fld fs[i], 0(addr)");}
      "POP.Q", "POPRET.Q": {addr-=16;asm("flq fs[i], 0(addr)");}
    }
  }
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET*) { 
   asm("ret");
}
----

== 32-bit Encodings

.proposed 32-bit encodings
[options="header",width="100%"]
|============================================================================
|31:30  |29:28|27:25   |24 |23:20  |19:15 |14:12 |11:7  |6:0     |name
|xx     |xx   |0000    |ra |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH
|xx     |xx   |0000    |ra |rcount |spimm |001   |xxxxx |xxxxxxx |POP
|xx     |xx   |0000    |ra |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET

|xx     |00   |frcount |ra |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH.F
|xx     |00   |frcount |ra |rcount |spimm |001   |xxxxx |xxxxxxx |POP.F
|xx     |00   |frcount |ra |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET.F

|xx     |01   |frcount |ra |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH.D
|xx     |01   |frcount |ra |rcount |spimm |001   |xxxxx |xxxxxxx |POP.D
|xx     |01   |frcount |ra |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET.D

|xx     |10   |frcount |ra |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH.Q
|xx     |10   |frcount |ra |rcount |spimm |001   |xxxxx |xxxxxxx |POP.Q
|xx     |10   |frcount |ra |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET.Q

10+|*reserved as `rcount` is out of range*
|xx     |xx   |xxxx    |x  |>12    |xxxx  |xxx   |xxxxx |xxxxxxx |*reserved*
10+|*reserved as no registers are specified*
|xx     |xx   |0000    |0  |0000   |xxxx  |xxx   |xxxxx |xxxxxxx |*reserved*
10+|*reserved as `flen` is out of range (bits [29:28]) and `frcount>0`*
|xx     |11   |>0     |0  |0000   |xxxx  |xxx    |xxxxx |xxxxxxx |*reserved*
|============================================================================

[NOTE]
  bits [29:28] are the `flen` field

=== Illegal instructions for the 32-bit encodings

The encoding takes the same behaviour as any floating point instruction if executed when disabled:

* if `frcount>0` and `misa.F==0`
* if `frcount>0` and `flen==1` and `misa.D==0`
* if `frcount>0` and `flen==2` and `misa.Q==0`

The following cases do not decode as `PUSH*/POP*/POPRET*`

* No registers are specified (`ra, rcount, frcount` are all zero)
* `rcount>12`
* `flen=3`

[#16bitencodings]
== 16-bit Encodings

.proposed 16-bit encodings
[options="header",width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction
3+|100|1|0|0|0 2+|rcount|0 |0 2+|00 | spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|0 |1 3+|spimm 2+|00|C.POPRET
3+|100|1|0|0 3+|rcount|1 |0 3+|spimm 2+|00|C.PUSH
|=======================================================================

[NOTE]
  * For `C.POP`, `spimm[2:1]=0`, and `rcount[2]=0` are reserved, as these encodings  give minimal benefit
  * For `C.PUSH/C.POPRET`, if `rcount[2]=1` then `spimm[2]=0` as these encodings  give minimal benefit
  * These encodings remain *reserved* for the time being so we can add them later if they can be justified

== Encoding Fields

[#spimm]
=== `spimm` encoding field

The `stack_adjustment` field in the assembly syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

The 16-bit encoding allows up to 7 additional 16-byte blocks (as `spimm` has up to 3-bits), and the 32-bit encoding allows up to 31.

[NOTE]
  we may change the size of `spimm` in the 32-bit encoding once benchmarking work has completed

[source,sourceCode,text]
----
//the padding calculation requires SP to be 16-byte aligned before executing the instruction
if (FLEN>XLEN && 
    number_of_registers_in_freg_list>0 && 
    number_of_registers_in_reg_list % (FLEN/XLEN)>0) {
  //need padding to ensure FLEN registers are aligned
  padding = (FLEN/XLEN - number_of_registers_in_reg_list % (FLEN/XLEN)) * XLEN/8;
} else {
  padding = 0
}
total_register_bytes = number_of_registers_in_reg_list * XLEN/8 + padding + number_of_registers_in_freg_list * FLEN/8;
stack_adjustment = Align16(total_register_bytes) + 16*spimm;
----

The bytes required for padding is simple - if FLEN==XLEN it's always zero. If FLEN=2*XLEN it is 0 or 4. RV32Q is more complex (see below) but this is an unlikely configuration.
`n` is an integer in the tables so `2n` is always even, `2n+1` is always odd.

[#padding-examples-RV32D]
.RV32D padding examples, XLEN=32, FLEN=64
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1   |4-bytes
|====================================

[#padding-examples-RV64Q]
.RV64Q padding examples, XLEN=64, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1  |4-bytes
|====================================

[#padding-examples-RV32Q]
.RV64Q padding examples, XLEN=32, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 4n     |none                     
| 4n+1   |4-bytes
| 4n+2   |8-bytes                     
| 4n+3   |12-bytes
|====================================

=== `ra, frcount, rcount` for the 32-bit encodings

The registers in the `reg_list` are controlled by these three fields

[#32bit-ra]
.`ra` field
[options="header"]
|====================================
|ra      | ABI names               
| 0      |none                     
| 1      |ra
|====================================

[#32bit-frcount]
.`frcount` values for the 32-bit encodings
[options="header"]
|=====================
|frcount | ABI names  
| 0      |none        
| 1      |fs0         
| 2      |fs0-fs1     
| 3      |fs0-fs2     
| 4      |fs0-fs3     
| 5      |fs0-fs5     
| 6      |fs0-fs8     
| 7      |fs0-fs11     
|=====================

[NOTE]
  We save 1-bit of encoding space by grouping the floating point registers

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
| 13-15  | *reserved*
|==========================

=== `rcount` for the 16-bit encodings

[#rcount-table]
.`rcount` values for the 16-bit encodings
[options="header",width=100%]
|============================
|rcount| ABI names
|0     |ra
|1     |ra, s0
|2     |ra, s0-s1
|3     |ra, s0-s2
2+|Following options for `C.PUSH/C.POPRET` only
|4     |ra, s0-s3
|5     |ra, s0-s5
|6     |ra, s0-s8
|7     |ra, s0-s11
|============================

[#fault-handling]
== Fault handling

The sequence required to execute the instruction may be interrupted, or may not be able to start execution for several reasons.

* virtual memory page fault or PMP fault
** these can be detected before execution, or during execution if the memory addresses cross a page/PMP boundary
* watchpoint trigger
** these can be detected before execution, or during execution depending on the trigger type (load data triggers require the sequence to have started executing, for example)
* external debug halt
** the halt can treat the whole sequence atomically, or interrupt mid sequence (implementation defined)
* debug halt caused by a trigger
** same comment as watchpoint trigger above
* load access fault
** these are detected while the sequence is executing
* store access fault (precise or imprecise)
** these may be detected while the sequence is executing, or afterwards if imprecise
* interrupts
** these may arrive at any time. An implementation can choose whether to interrupt the sequence or not.

Because some faults can only be detected during the sequence the core implementation is able to recover from the fault and re-execute the sequence. This may involve executing some or all of the loads and stores from the sequence multiple times before the sequence completes (as multiple faults or multiple interrupts are possible).

Therefore correct execution requires that `sp` refers to idempotent memory.

[#software-view]
== Software view of execution

=== Software view of `PUSH` sequence

From a software perspective the `PUSH` sequence appears as:

* A sequence of stores writing a contiguous block of memory. Any of the bytes may be written multiple times.
* A stack pointer adjustment

Because the memory is idempotent and the stores are non-overlapping, they may be reordered, grouped into larger accesses, split into smaller access or any combination of these.

If an implementation allows interrupts during the sequence, and the interrupt handler uses `sp` to allocate stack memory, then any stores which were executed before the interrupt maybe be overwritten by the handler. This is safe because the memory is idempotent and the stores will be re-executed once the handler completes.

The stack pointer adjustment must only be committed once it is certain that all of the stores will complete within triggerring any precise faults (stores may return imprecise bus errors which are received after the instruction has completed execution).

Referring to the example in <<push-example-1>> 

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Appears to software as:

[source,sourceCode,text]
----
# any bytes from SP-1 to SP-28 may be written multiple times before the instruction completes
sw  ra, -4(sp);   
sw  s0, -8(sp);   
sw  s1,-12(sp);   
sw  s2,-16(sp);  
sw  s3,-20(sp);   
sw  s4,-24(sp);   
sw  s5,-28(sp);   

# this must only execute once, and will only execute after all stores complete sucessfully
addi sp, sp, -64; 
----

=== Software view of `POP[RET]` sequence

From a software perspective the `POP[RET]` sequence appears as:

* A sequence of loads, any of which may be executed multiple times
* A stack pointer adjustment
* An optional `RET`

If an implementation allows interrupts during the sequence, then any loads which were executed before the interrupt may update architectural state. The loads will be re-executed once the handler completes, so the values will be overwritten. Therefore it is permitted for an implementation to update some of the destination registers before taking the interrupt or other fault.

The stack pointer adjustment must only be committed once it is certain that all of the loads will complete successfully.

For `POPRET` once the stack pointer adjustment has been committed the `RET` must execute.

Referring to the example in <<popret-example-1>> 

[source,sourceCode,text]
----
popret.f   {ra, s0-s3, fs0-fs1}, 32 ; 
----

Appears to software as:

[source,sourceCode,text]
----
# any or all of these load instructions may execute multiple times
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);
lw   s2, 16(sp);
lw   s3, 12(sp);
flw  fs0, 8(sp);
flw  fs1, 4(s0);

# must only execute once, will only execute after all loads complete successfully
# both instructions must execute atomically
addi sp, sp, 32;
ret;
----

== Initial benchmarking results

Using the `PUSH/POP` support in HCC (Huawei GCC branch) allows the full range of register lists in the 16-bit encodings, and up to 5-bits of `spimm`.

https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/push_pop_encoding_results.xlsx[This spreadsheet] shows the results across the whole benchmark suite to show which instructions were inferred (not broken down by benchmark).

The target for the 16-bit encodings has been to minimise encoding space while keeping ~ 95% of the cases on the benchmark suite (94.9% achieved)

The overall saving compared to -msave-restore is 4.8% using HCC (this result is subject to change as the benchmark suite is updated). Minimising the encoding space reduces this benefit to 4.6%.

[#results-table]
.16-bit encoding code-size benefit
[options="header",width=100%]
|==================================================================
|Instruction|percentage of calls from HCC|overall code-size saving
|All        | 94.9%                      | 4.6% (94.9% of 4.8%)
|`C.PUSH`   | 47.5%                      | 2.3%
|`C.POPRET` | 37.6%                      | 1.8%
|`C.POP`    | 9.8%                       | 0.5%
|==================================================================

== Assembly examples

[#push-example-1]
=== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  ra, 60(sp);
sw  s0, 56(sp); 
sw  s1, 52(sp);
sw  s2, 48(sp); 
sw  s3, 44(sp);
sw  s4, 40(sp); 
sw  s5, 36(sp);
----

=== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rcount=2, spimm=1

Equivalent sequence:

[source,sourceCode,text]
----
addi sp, sp, -32;
sw  ra, 28(sp);
sw  s0, 24(sp); 
sw  s1, 20(sp);
----

=== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   ra, 156(sp);
lw   s0, 152(sp);  
lw   s1, 148(sp);  
lw   s2, 144(sp);  
lw   s3, 140(sp);  
lw   s4, 136(sp);  
lw   s5, 132(sp);  
lw   s6, 128(sp);  
lw   s7, 124(sp);  
lw   s8, 120(sp);  
addi sp, sp, 160
----

=== PUSH.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, flen=0, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  ra,  60(sp);
sw  s0,  56(sp); 
sw  s1,  52(sp); 
sw  s2,  48(sp); 
sw  s3,  44(sp); 
sw  s4,  40(sp); 
fsw fs0, 36(sp)
----

=== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, flen=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sd  ra,  56(sp);
sd  s0,  48(sp); 
sd  s1,  40(sp);
sd  s2,  32(sp); 
sd  s3,  24(sp);
sd  s4,  16(sp); 
fsd fs0,  8(sp)
----

=== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {fs0-fs7}, -128
----

Encoding: rcount=0, frcount=12, flen=2, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -128; 
fsd  fs0, 120(sp);
fsd  fs1, 112(sp); 
fsd  fs2, 104(sp);
fsd  fs3,  96(sp); 
fsd  fs5,  88(sp); 
fsd  fs4,  80(sp);
fsd  fs6,  72(sp);
fsd  fs7,  64(sp); 
fsd  fs8,  56(sp); 
fsd  fs9,  48(sp); 
fsd  fs10, 40(sp); 
fsd  fs11, 32(sp); 
----

=== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {ra, s0-s9}, 256
----

Encoding: ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 252(sp);
lw   s0, 248(sp);
lw   s1, 244(sp);  
lw   s2, 240(sp)
lw   s3, 236(sp);  
lw   s4, 232(sp);
lw   s5, 228(sp);  
lw   s6, 224(sp)
lw   s7, 220(sp);  
lw   s8, 216(sp);
lw   s9, 212(sp);  
addi sp, sp, 256
----

[#popret-example-1]
=== POPRET.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
popret.f   {ra, s0-s3, fs0-fs1}, 32
----

Encoding: ra=1, rcount=4, frcount=2, flen=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);  
lw   s2, 16(sp);
lw   s3, 12(sp);  
flw  fs0, 8(sp);
flw  fs1, 4(s0);  
addi sp, sp, 32; 
ret
----

