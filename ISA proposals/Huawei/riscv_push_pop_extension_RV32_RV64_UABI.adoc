= RISC-V Push/Pop Extension
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 32-bit and 16-bit encodings for `[C.]PUSH`,
`[C.]POP` and `[C.]POPRET` instructions for RV32 and RV64 architectures I variants only, using the UABI.

These instructions are to reduce the code-size of funciton prologues and epilogues by using a single encoding to replace a sequence of instructions.

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

* should these instructions check alignment? if you use gcc -msave-restore there's no alignment check, and if the compiler produces the prologue/epilogue directly there's no alignment check, so is it worth it?
* whether to share an encoding with `POP[RET]` and so maybe have fewer `POP` rcount values to save encoding space.
* we could squeeze `rcount` and `frcount` into 1 bit fewer for the 32-bit encodings if we reduce the available options

== Assembler Syntax

[source,sourceCode,text]
----
push   {<reg_list>}, -<stack_adjustment>
pop    {<reg_list>},  <stack_adjustment>
popret {<reg_list>},  <stack_adjustment>
----

. `PUSH` pushes the registers in `reg_list` to the stack, and then adjusts the stack pointer by the `stack_adjustment`.
. `POP` pops the registers in `reg_list` from the stack, and then adjusts the stack pointer by the `stack_adjustment`.
. `POPRET` has the same behaviour as `POP`, followed by `RET`.

32-bit and 16-bit forms are available, the assembler should choose the 16-bit form if the parameters permit and the C extension is implemented.

The registers in `reg_list` are in a comma separated list, and may include up to three components:

. `ra`
. `s0-sN` where `N` is in the range [0, 11]
.. If `N=0` the correct syntax is `s0`
. `fs0-fsM` where `M` is in the range [0, 11]
.. If `M=0` the correct syntax is `fs0`

Any combination of these three may be present, and `reg_list` must not be empty.

For the 16-bit encoding

. `ra` must be included
. `s0-sN` may be included, valid values of `N` are 0,1,2,3,5,8,11
. `fs0-fsM` may not be included
. the `stack_adjustment` must be no more than the total memory required for `reg_list` + 7*16-bytes.

For the 32-bit encoding

. the register list must not be empty
. the `stack_adjustment` must be no more than the total memory required for `reg_list` + 15*16-bytes.

For example

. `push {ra,s0-s2}, -64` can use a 16-bit encoding
. `push {ra,s0-s2,fs0}, -64` must use a 32-bit encoding as `fs0` is in the register list
. `push {ra,s0-s2}, -256` must use a 32-bit encoding as the `stack_adjustment` is out of range

[NOTE]
 Should we allow the x-register syntax? It breaks up the ranges which is annoying as s1 and s2  do not map to consecutive registers

To be a legal encoding:

1.  The stack adjustment must be negative for a `PUSH` and positive for a `POP[RET]`
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register list must be valid (see above)

== PUSH Operation

A `PUSH` instruction stores the set of registers from `reg_list` to memory, and decrements the stack pointer.

. Register `r` in `reg_list`` is stored to address `sp-(XLEN/8)*r`.
. `sp` is decremented by the `stack_adjustment` value.

An implementation may choose to adjust the stack pointer before or after the stores.

== POP[RET] Operation

A `POP` instruction loads the set of registers from `reg_list` from memory, and then increments the stack pointer.

. Register `r` in the list is loaded from address `sp+stack_adjustment-(XLEN/8)*r`.
. `sp` is incremented by the `stack_adjustment` value.
. `POPRET` executes a `RET` as the final step

An implementation may choose to adjust the stack pointer before or after the loads.

== Opcode Assignment

.proposed 32-bit encodings
[options="header",width="100%"]
|============================================================================
|31:28  | 27 |26:24   |23:20  |19:15 |14:12 |11:7  |6:0     |name
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSH
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POP
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPRET
|============================================================================

.proposed 16-bit encodings
[options="header",width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction
3+|100|1|0|0 3+|rcount|0|0 3+|spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|0|1 3+|spimm 2+|00|C.POPRET
3+|100|1|0|0 3+|rcount|1|0 3+|spimm 2+|00|C.PUSH
|=======================================================================

[#spimm]
=== `spimm` encoding field

The `stack_adjustment` field in the assembly syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

The 16-bit encoding allows up to 7 additional 16-byte blocks (as `spimm` has 3-bits), and the 32-bit encoding allows up to 15.

[source,sourceCode,text]
----
total_register_bytes = number_of_registers_in_reg_list * XLEN / 8
stack_adjustment = Align16(total_register_bytes) + 16*spimm
----

=== `ra, frcount, rcount` for the 32-bit encodings

The registers in the `reg_list` are controlled by these three fields

[#32bit-ra]
.`ra` field
[options="header"]
|====================================
|ra      | ABI names               
| 0      |none                     
| 1      |ra
|====================================

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0         
| 2      |s0-s1      
| 3      |s0-s2      
| 4      |s0-s3          
| 5      |s0-s4          
| 6      |s0-s5          
| 7      |s0-s6          
| 8      |s0-s7          
| 9      |s0-s8          
| 10     |s0-s9          
| 11     |s0-s10         
| 12     |s0-s11         
| 13-15  | *reserved*
|==========================

[#32bit-frcount]
.`frcount` values for the 32-bit encodings
[options="header"]
|=====================
|frcount | ABI names  
| 0      |none        
| 1      |fs0         
| 2      |fs0-fs1     
| 3      |fs0-fs2     
| 4      |fs0-fs3     
| 5      |fs0-fs4     
| 6      |fs0-fs5     
| 7      |fs0-fs6     
| 8      |fs0-fs7     
| 9      |fs0-fs8     
| 10     |fs0-fs9     
| 11     |fs0-fs10    
| 12     |fs0-fs11    
| 13-15  |*reserved*               
|=====================

`reg_list` is formed as follows:

[source,sourceCode,text]
----
reg_list = {}; //empty list
if (ra) reg_list = {ra};
if (rcount>0) {
    for (i=1; i<=rcount; i++)  reglist += {s[i-1]};  //add s registers
}
if (frcount>0) {
    for (i=1; i<=frcount; i++) reglist += {fs[i-1]}; //add fs registers
}
----

=== `rcount` for the 16-bit encodings

[#rcount-table]
.`rcount` values for the 16-bit encodings
[options="header",width=100%]
|============================
|rcount| ABI names           
|      |                     
|      |                     
|0     |ra                   
|1     |ra, s0               
|2     |ra, s0-s1            
|3     |ra, s0-s2            
|4     |ra, s0-s3            
|5     |ra, s0-s5            
|6     |ra, s0-s8            
|7     |ra, s0-s11
|============================

== Assembly examples

=== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s5, -28(sp);
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra, -4(sp);
addi sp, sp, -64;
----

=== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rcount=2, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s1, -12(sp);
sw  s0,  -8(sp); 
sw  ra,  -4(sp);
addi sp, sp, -32;
----

=== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {x1, x8-x9, x18-x24}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw  x24, 120(sp);  lw  x23, 124(sp);  
lw  x22, 128(sp);  lw  x21, 132(sp);  
lw  x20, 136(sp);  lw  x19, 140(sp);  
lw  x18, 144(sp);  lw   x9, 148(sp);  
lw   x8, 152(sp);  lw   x1, 156(sp);
addi sp, sp, 160
----

=== PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-28(sp)
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra,  -4(sp);
addi sp, sp, -64;
----

=== PUSH RV64 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-56(sp)
sw  s4, -48(sp); sw  s3, -40(sp);
sw  s2, -32(sp); sw  s1, -24(sp);
sw  s0, -16(sp); sw  ra,  -8(sp);
addi sp, sp, -64;
----

=== PUSH RV64 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push  {fs0-fs11}, -128
----

Encoding: eabi=0, rcount=0, frcount=12, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw  fs11,-96(sp); fsw  fs10,-88(sp);
fsw  fs9, -80(sp); fsw  fs8, -72(sp);
fsw  fs7, -64(sp); fsw  fs6, -56(sp);
fsw  fs5, -48(sp); fsw  fs4, -40(sp);
fsw  fs3, -32(sp); fsw  fs2, -24(sp);
fsw  fs1, -16(sp); fsw  fs0,  -8(sp);
addi sp, sp, -128;
----

=== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {x1, x8-x9, x18-x25}, 256
----

Encoding: eabi=0, ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw  x25, 212(sp);  lw  x24, 216(sp);
lw  x23, 220(sp);  lw  x22, 224(sp)
lw  x21, 228(sp);  lw  x20, 232(sp);
lw  x19, 236(sp);  lw  x18, 240(sp)
lw   x9, 244(sp);  lw   x8, 248(sp);
lw   x1, 252(sp);
addi sp, sp, 256
----

=== POPRET RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
popret   {x1, x8-x9, x18-x19, f8-f9}, 32
----

Encoding: eabi=0, ra=1, rcount=4, frcount=2, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
flw  f9,  4(s0);  flw  f8,  8(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
lw   x1, 28(sp);
addi sp, sp, 32; ret
----

