<<<

[#insns-pushpop,reftext="PUSH/POP Register Instructions"]
== PUSH/POP register instructions

These instructions are collectively referred to as PUSH/POP: 

* <<#insns-c_push_areg_list>> 
* <<#insns-push_areg_list>> 
* <<#insns-c_popret>> 
* <<#insns-popret>> 
* <<#insns-c_pop>> 
* <<#insns-pop>>

The term PUSH refers to both 16 and 32-bit encodings (C.PUSH, PUSH).

The term POP refers to both 16 and 32-bit encodings of POP (C.POP, POP).

The term POPRET refers to both 16 and 32-bit encodings of POPRET (C.POPRET, POPRET).

Common details for these instructions are in this section.

[NOTE]

  This version does not fully include _areg_list_ and will need to be updated if it's included in _push/c.push_.

=== PUSH/POP overview

PUSH, POP, POPRET along with the 16-bit forms are used to reduce the size of function prologues and epilogues.

. The PUSH instruction 
** pushes(stores)  the registers specified in _reg_list_ to the stack
** if _areg_list_ is included, moves the registers in the _areg_list_ into _s_ registers
*** _areg_list_ is determined automatically from _rlist_, it cannot be arbitrarily specified. The definition is in <<#insns-c_push_areg_list>>  and <<#insns-push_areg_list>> ;
** adjusts the stack pointer by the _stack_adjustment_ 

. The POP instruction 
** pops(loads) the registers in _reg_list_ from the stack
** if _ret_val_ is included, moves the specified constant value into _a0_ as the return value
** adjusts the stack pointer by the _stack_adjustment_.

. POPRET has the same behaviour as POP, followed by RET.

<<<
=== Example usage

This example gives an illustration of the use of PUSH and POPRET.

[source,SAIL]
----
int function(void *buf, size_t len)
{
        return function2(buf, len);
}
----

compiles with GCC10 to:

[source,sourceCode,text]
----
20405458 <function>:
20405458: 1141                addi sp,sp,-16	;#PUSH(1)
2040545a: c04a                sw   s2,0(sp)	    ;#PUSH(2)
...
20405464: c422                sw   s0,8(sp)	    ;#PUSH(3)
20405466: c226                sw   s1,4(sp)	    ;#PUSH(4)
20405468: c606                sw   ra,12(sp)	;#PUSH(5)
2040546a: 842a                mv   s0,a0		;#PUSH(6)
2040546c: 84ae                mv   s1,a1		;#PUSH(7)
<function body>
20405494: 4501                li   a0,0		    ;#POPRET(1)
20405496: 40b2                lw   ra,12(sp)	;#POPRET(2)
20405498: 4422                lw   s0,8(sp)	    ;#POPRET(3)
2040549a: 4492                lw   s1,4(sp)	    ;#POPRET(4)
2040549c: 4902                lw   s2,0(sp)	    ;#POPRET(5)
2040549e: 0141                addi sp,sp,16	    ;#POPRET(6)
204054a0: 8082                ret               ;#POPRET(7)
----

with the GCC option _-msave-restore_ the output is the following:

[source,sourceCode,text]
----
204089ac <function>:
204089ac: f97f72ef            jal  t0,20400942 <__riscv_save_0> ;#PUSH(1)
...
204089b8: 842a                mv   s0,a0                        ;#PUSH(2)
204089ba: 84ae                mv   s1,a1                        ;#PUSH(3)
<function_body>
204089e2: 4501                li   a0,0                         ;#POPRET(1)
204089e4: f83f706f            j    20400966 <__riscv_restore_0> ;#POPRET(2)
----

with PUSH/POPRET this reduces to

[source,sourceCode,text]
----
20405458 <function>:
20405458: <16-bit>            push   {ra,s0-s2},{a0-a2},-16
<function body>           
20405496: <16-bit>            popret {ra,s0-s2},{0}, 16

----

The prologue / epilogue reduce from 28-bytes in the original code, to 14-bytes with _-msave-restore_, and to 4-bytes with PUSH and POPRET. As well as reducing the code-size PUSH and POPRET eliminate the branches from calling the millicode _save/restore_ routines so also perform better. 
  
[NOTE]

  The calls to _<riscv_save_0>/<riscv_restore_0>_ become 64-bit when the target functions are out of the Â±1MB range, increasing the prologue/epilogue size to 22-bytes.

[NOTE]

  The C.PUSH has an additional register move included _mv s2, a2_ which wasn't in the original prologue. This is included to simplify the encoding and definition of C.PUSH/PUSH and will cost some performance.

[NOTE]

  POP is used for tail-calling which is not included in this example.

[#pushpop-fault-handling]
=== PUSH/POP Fault handling

The sequence required to execute the PUSH/POP instruction may be interrupted, or may not be able to start execution for several reasons.

* virtual memory page fault or PMP fault
** these can be detected before execution, or during execution if the memory addresses cross a page/PMP boundary
** MTVAL is set to any address which causes the fault
* watchpoint trigger
** these can be detected before execution, or during execution depending on the trigger type (load data triggers require the sequence to have started executing, for example)
** MTVAL is set to any address which causes the fault
* external debug halt
** the halt can treat the whole sequence atomically, or interrupt mid sequence (implementation defined)
* debug halt caused by a trigger
** same comment as watchpoint trigger above
* load access fault
** these are detected while the sequence is executing
** MTVAL is set to the fault address.
* store access fault (precise or imprecise)
** these may be detected while the sequence is executing, or afterwards if imprecise
** MTVAL is set to the fault address.
* interrupts
** these may arrive at any time. An implementation can choose whether to interrupt the sequence or not.

In all case MEPC contain the PC of the PUSH/POP instruction, and MCAUSE is set as expected for the type of fault.

For debug halts DPC is set to the PC of the PUSH/POP instruction.

Because some faults can only be detected during the sequence the core implementation is able to recover from the fault and re-execute the sequence. 
This may involve executing some or all of the loads and stores from the sequence multiple times before the sequence completes (as multiple faults or multiple interrupts are possible).

Therefore correct execution requires that _sp_ refers to idempotent memory (also see <<pushpop_non-idem-mem>>).

[#pushpop-software-view]
=== Software view of execution

==== Software view of the PUSH sequence

From a software perspective the PUSH sequence appears as:

* A sequence of stores writing a contiguous block of memory. Any of the bytes may be written multiple times.
* A stack pointer adjustment

Because the memory is idempotent and the stores are non-overlapping, they may be reordered, grouped into larger accesses, split into smaller access or any combination of these.

If an implementation allows interrupts during the sequence, and the interrupt handler uses _sp_ to allocate stack memory, then any stores which were executed before the interrupt may be overwritten by the handler. 
This is safe because the memory is idempotent and the stores will be re-executed execution resumes.

The stack pointer adjustment must only be committed once it is certain that all of the stores will complete within triggerring any precise faults 
(stores may return imprecise bus errors which are received after the instruction has completed execution).

For example:

[source,sail]
--
c.push  {ra, s0-s5}, {a0-a3}, -64
--

Appears to software as:

[source,sail]
--
# any bytes from sp-1 to sp-28 may be written multiple times before the instruction completes
sw  s5, -4(sp);   
sw  s4, -8(sp);   
sw  s3,-12(sp);   
sw  s2,-16(sp);  
sw  s1,-20(sp);   
sw  s0,-24(sp);   
sw  ra,-28(sp);   

# these must only execute once, and will only execute after all stores complete sucessfully
mv   s0, a0
mv   s1, a1
mv   s2, a2
mv   s3, a3
addi sp, sp, -64; 
--

==== Software view of the POP/POPRET sequence

From a software perspective the POP/POPRET sequence appears as:

* A sequence of loads, any of which may be executed multiple times
* A stack pointer adjustment
* An optional RET

If an implementation allows interrupts during the sequence, then any loads which were executed before the interrupt may update architectural state. 
The loads will be re-executed once the handler completes, so the values will be overwritten. 
Therefore it is permitted for an implementation to update some of the destination registers before taking the interrupt or other fault.

The load immediate and stack pointer adjustment must only be committed once it is certain that all of the loads will complete successfully.

For POPRET once the stack pointer adjustment has been committed the RET must execute.

For example:

[source,sail]
--
popret   {ra, s0-s3}, {1}, 32 ; 
--

Appears to software as:

[source,sail]
--
# any or all of these load instructions may execute multiple times
lw   s3, 28(sp);
lw   s2, 24(sp);
lw   s1, 20(sp);
lw   s0, 16(sp);
lw   ra, 12(sp);

# must only execute once, will only execute after all loads complete successfully
# all instructions must execute atomically
li a0, 1
addi sp, sp, 32;
ret;
--

[[pushpop_non-idem-mem]]
=== Non-idempotent memory handling

An implementation may have a requirement to issue a PUSH/POP instruction to non-idempotent memory. 

==== Error detection

If the core implementation does not have a requirement to support PUSH/POP to non-idempotent memories, 
and the core can use a PMA to detect that the memory is non-idempotent, then take a load(POP/POPRET) or store (PUSH) access fault exception.

==== Non-idempotent support

It is possible to support non-idempotent memory. One reason is to re-use PUSH/POP as a restricted form of a load/store multiple instruction to a peripheral,
as there is no generic load/store multiple instruction in the RISC-V ISA. 

If accessing non-idempotent memory then it is _recommended_ to:

. Not allow interrupts during execution
. Not allow external debug halt during execution
. Detect any virtual memory page faults or PMP faults for the whole instruction before starting execution (instead of during the sequence)
. Not split / merge / reorder the generated memory accesses

It is possible that one of the following will still occur during execution:

. Watchpoint trigger
. Load/store access fault

In these cases the core will jump to the debug or exception handler. If execution is required to continue afterwards (so the event is not fatal to the code execution), then the handler is required to do so in software. 

By following these rules memory accesses will only ever be issued once, and in the order listed in the SAIL.

It is possible for implementations to follow these restricted rules and to safely access both types of memory. 
It is also possible for an implementation to use PMAs to detect the memory type and apply different rules, such as only allowing interrupts if accessing cacheable memory, for example.

=== Compiling PUSH/POP for size or performance

There are cases where there are choices about whether to select the 16-bit or 32-bit encoding. The 32-bit encodings offer a smaller stack adjustment range than using a 16-bit encoding and an additional C.ADDI16SP instruction. Therefore using the 32-bit encoding will not reduce the code size if the stack adjustment is out of range of the 16-bit encoding.

The main performance/code-size trade-offs are

* whether the register list available in the 16-bit encodings matches the required list, and so whether extra registers are included by the 16-bit encoding
* whether areg_list includes redundant moves

The recommendation is that the 32-bit encoding should be selected only if compiling for performance and either

* the register list is not available in the 16-bit encoding
* areg_list includes redundant moves

In addition, for POPRET, the 32-bit encoding allows more return values than the 16-bit encoding. Therefore the recommendation is that the 32-bit encoding should be selected if the 32-bit encoding allows the required return value.


Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zces (<<#zces>>)
|0.52
|Plan
|===
